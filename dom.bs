<pre class=metadata>
Group: WHATWG
Title:DOM标准
H1: DOM
Shortname: dom
Text Macro: TWITTER thedomstandard
Text Macro: LATESTRD 2022-06
Abstract: DOM标准定义了与实现平台无关的evnts、aborting activities和node trees模型
Translation: ja https://triple-underscore.github.io/DOM4-ja.html
Translate IDs: slottable slotable
Indent: 1
</pre>

<pre class=anchors>
urlPrefix: https://www.w3.org/TR/xml/#NT-
 type: type
  text: Name; url: Name
  text: Char; url: Char
  text: PubidChar; url: PubidChar
urlPrefix: https://www.w3.org/TR/xml-names/#NT-
 type: type
  text: QName; url: QName
url: https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment
 type: method; text: createContextualFragment(); for: Range
type: interface
 url: https://w3c.github.io/touch-events/#idl-def-touchevent
  text: TouchEvent
 url: https://w3c.github.io/deviceorientation/spec-source-orientation.html#devicemotion
  text: DeviceMotionEvent
  text: DeviceOrientationEvent
urlPrefix: https://tc39.es/ecma262/#; spec: ECMASCRIPT
 text: Construct; url: sec-construct; type: abstract-op
 type: dfn
  text: realm; url: realm
  text: surrounding agent; url: surrounding-agent
urlPrefix: https://w3c.github.io/hr-time/#; spec: HR-TIME
 type:typedef; urlPrefix: dom-; text: DOMHighResTimeStamp
 type:dfn; text: time origin; url: dfn-time-origin
 type:dfn; text: current high resolution time; url: dfn-current-high-resolution-time
 type:dfn; text: relative high resolution coarse time; url: dfn-relative-high-resolution-coarse-time
</pre>

<pre class=link-defaults>
spec:html; type:element
 text: title
 text: script
</pre>



<h2 id=infrastructure oldids=terminology,dependencies>基础设施</h2>

<p>此规范依赖于Infra标准. [[!INFRA]]

<p>本规范中使用的一些术语在<cite>Encoding</cite>,
<cite>Selectors</cite>, <cite>Web IDL</cite>, <cite>XML</cite>, 以及 <cite>XML的命名空间</cite>中定义。
[[!ENCODING]]
[[!SELECTORS4]]
[[!WEBIDL]]
[[!XML]]
[[!XML-NAMES]]

<p>当需要扩展时，可以相应地更新 DOM 标准，或者可以编写一个新标准来挂钩到
<dfn export lt="other applicable specifications">适用规范</dfn>提供的可扩展性挂钩中。
<!-- https://www.w3.org/mid/17E341CD-E790-422C-9F9A-69347EE01CEB@iki.fi -->

<h3 id=trees lt="trees">Trees：树</h3> <!-- Sorry reddit, this is not /r/trees -->

<p><dfn export id=concept-tree>tree</dfn>是一种有限的分层树结构。<a>tree</a>的遍历
<dfn export id=concept-tree-order lt="tree order">顺序</dfn>采用深度优先先序遍历。
<!-- https://en.wikipedia.org/wiki/Depth-first_search -->
为什么采用深度优先先序遍历？其实是由于深度优先先序遍历方式与我们阅读HTML文档顺序是一致的，看以下例子：
<pre class=lang-markup>
 &lt;F>
   &lt;B>
     &lt;K>&lt;/K>
     &lt;D>
       &lt;C>&lt;/C>
       &lt;E>&lt;/E>
     &lt;/D>
   &lt;/B>
   &lt;G>
     &lt;I>
       &lt;H>&lt;/H>
     &lt;/I>
   &lt;/G>
 &lt;/F>
 &lt;!--我们的阅读顺序:
     F B K D C E G I H
     深度优先先序遍历顺序：
     F B K D C E G I H
 -->
</pre>

<p>
<dfn export for=tree id=concept-tree-participate lt="participate|participate in a tree|participates in a tree">参与</dfn>
<a>tree</a>的对象有一个<dfn export for=tree id=concept-tree-parent>parent</dfn>，它存放父对象，是 null 或一个对象；
还有一个
<dfn export for=tree id=concept-tree-child lt="child|children">children</dfn>，存放子对象，它是一组
<a data-lt="ordered set">有序</a>的对象。对象B是对象A的父对象，那么对象A是对象B的子对象。

如果一个对象没有父对象(即它的<a for=tree>parent</a>属性为null)，那么该对象的
<dfn export for=tree id=concept-tree-root lt="root">根</dfn>就是对象本身。
如果对象确实有父对象(即它的<a for=tree>parent</a>属性不为null)，则对象的根是其父对象的根。换句话说，任何对象的根是对象所属层次结构中的最高对象。
<a>tree</a>的<a for=tree lt="root">根</a>是<a for=tree lt="participate">参与</a>该<a>tree</a>
的其<a for=tree>parent</a>为空的对象。

对象<var>A</var>称为对象<var>B</var>的
<dfn export for=tree id=concept-tree-descendant lt="descendant">后代</dfn>，
如果对象<var>A</var>是对象<var ignore>C</var>的<a for=tree lt="child">孩子</a>，
而对象<var>C</var>则是<var>B</var>的<a lt="descendant">后代</a>。

<dfn export for=tree id=concept-tree-inclusive-descendant lt="inclusive descendant">包容性后代</dfn>是一个对象或其
<a lt="descendants">后代</a>之一。

当且仅当<var>B</var>是<var>A</var>的<a lt="descendant">后代</a>，<var>A</var>才能被称为<var>B</var>的
<dfn export for=tree id=concept-tree-ancestor lt="ancestor">祖先</dfn>。

<dfn export for=tree id=concept-tree-inclusive-ancestor lt="inclusive ancestor">包容性祖先</dfn>
是一个对象或其<a lt="ancestors">祖先</a>之一。

当且仅当<var>B</var>和<var>A</var>拥有相同的非空<a for=tree lt="parent">父对象</a>时，对象<var>A</var>才称为对象<var>B</var>的
<dfn export for=tree id=concept-tree-sibling lt="sibling">兄弟</dfn>对象。

<dfn export for=tree id=concept-tree-inclusive-sibling lt="inclusive sibling">包容性兄弟</dfn>是一个对象或其
<a for=tree lt="siblings">兄弟</a>之一。

如果<var>A</var>和<var>B</var>在同一棵<a>tree</a>中并且<var>A</var>在<a lt="tree order">tree的顺序</a>中位于<var>B</var>的
<dfn export for=tree id=concept-tree-preceding lt="preceding">前面</dfn>，
则对象<var>A</var>在对象<var>B</var>之前。

如果<var>A</var>和<var>B</var>在同一棵<a>tree</a>中并且<var>A</var>在<a lt="tree order">tree的顺序</a>中位于<var>B</var>的
<dfn export for=tree id=concept-tree-following lt="following">后面</dfn>，
则对象<var>A</var>在对象<var>B</var>之后。

<p>对象的<dfn export for=tree id=concept-tree-first-child>first child</dfn>是它第一个<a for=tree lt="child">孩子</a>，
如果没有<a for=tree lt="children">孩子</a>，则为null。

<p>对象的<dfn export for=tree id=concept-tree-last-child>last child</dfn>是它最后一个<a for=tree lt="child">孩子</a>，
如果没有<a for=tree lt="children">孩子</a>，则为null。

对象的<dfn export for=tree id=concept-tree-previous-sibling>previous sibling</dfn>是它第一个<a lt="preceding">前面</a>的<a for=tree lt="sibling">兄弟</a>，
如果没有<a lt="preceding">前面</a>的<a for=tree lt="sibling">兄弟</a>则为null。

对象的<dfn export for=tree id=concept-tree-next-sibling>next sibling</dfn>是它第一个<a lt="following">后面</a>的<a for=tree lt="sibling">兄弟</a>，
如果没有<a lt="following">后面</a>的<a for=tree lt="sibling">兄弟</a>则为null。

<p>对象的<dfn export for=tree id=concept-tree-index>index</dfn>是其<a lt="preceding">前面</a><a for=tree lt="sibling">兄弟</a>的数量，如果没有则为 0。


<h3 id="ordered-sets" lt="ordered-sets">Ordered sets：有序集</h3>

<p><dfn export id=concept-ordered-set-parser lt="ordered set parser">有序集解析器</dfn>接受字符串输入，并且会运行以下步骤：

<ol>
 <li><p>将<a lt="split on ASCII whitespace">输入字符串以空格拆分</a>，赋值给inputTokens。

 <li><p>将tokens设置为新的<a lt="ordered set">有序集</a>。
 
 <li><p><a for=list lt="For each">遍历</a>inputTokens中的token，将token<a for=set id="append" lt="append">添加</a>到tokens中。

 <li>返回tokens。
</ol>

<p><dfn export id=concept-ordered-set-serializer lt="ordered set serializer">有序集序列化</dfn>将集合使用空格(unicode空格编码，U+0020)
<a for=string lt="concatenate">串联为字符串</a>并以此作为返回值


<h3 id=selectors lt="selectors">Selectors：选择器</h3>

<p>针对节点<dfn export lt="scope-match a selectors string">匹配给定的字符串选择器时</dfn>，将运行以下步骤：

<ol>
 <li><p><a lt="parse a selector">解析</a>输入的字符串选择器是否正确，并将其结果赋值给变量s。[[!SELECTORS4]]

 <li><p>如果s的值为失败，则<a lt="throw">抛出</a> "{{SyntaxError!!exception}}(语法错误)"的{{DOMException}}(DOM异常)。

 <li><p>使用<a lt="scoping root">作用域根</a>节点返回 <a lt="match a selector against a tree">选择器与树(具有s和节点的<a for=tree lt="root">根</a>)的匹配结果</a>。
</ol>

<p class=note>注意：选择器中对名称空间的支持没有计划，也不会添加。


<h3 id=namespaces lt="Namespaces">Namespaces：命名空间</h3>

<p><dfn export lt="validate">验证</dfn>qualifiedName，qualifiedName若不能匹配<code><a type>QName</a></code>定义的规则，则匹配失败，<a lt="throw">抛出</a>"
{{InvalidCharacterError!!exception}}(无效的字符错误)"的{{DOMException}}(DOM异常)。

<p>要<dfn export lt="validate and extract">验证和提取</dfn>namespaces和qualifiedName，请运行以下步骤：

<ol>
 <li><p>如果namespace为空字符串，则将其设置为 null。
 
 <li><p><a lt="Validate">验证</a>qualifiedName。

 <li><p>让<var>prefix</var>为null。

 <li><p>让localName成为qualifiedName。

 <li>
  <p>如果<var>qualifiedName</var>包含符号":"(Unicode码：U+003A)，则：

  <ol>
   <li><p>给定符号":"(Unicode码：U+003A)<a lt="strictly split">严格拆分</a><var>qualifiedName</var>，设<var>splitResult</var>为其返回结果。

   <li><p>设<var>prefix</var>为<var>splitResult</var>[0]。

   <li><p>设<var>localName</var>为<var>splitResult</var>[1]。
  </ol>

 <li><p>如果<var>prefix</var>不为null但<var>namespace</var>为null，则<a lt="throw">抛出</a>一个"{{NamespaceError!!exception}}(命名空间错误)"的
 {{DOMException}}(DOM异常)。

 <li><p>如果<var>prefix</var>是"<code>xml</code>"但<var>namespace</var>不是<a lt="XML namespace">XML命名空间</a>，则<a lt="throw">抛出</a>
 一个"{{NamespaceError!!exception}}(命名空间错误)"的{{DOMException}}(DOM异常)。

 <li><p>如果<var>qualifiedName</var>或<var>prefix</var>是"<code>xmlns</code>"但<var>namespace</var>不是<a lt="XMLNS namespace">XMLNS命名空间</a>，
 则<a lt="throw">抛出</a>一个"{{NamespaceError!!exception}}(命名空间错误)"的{{DOMException}}(DOM异常)。
 
 <li><p>如果<var>namespace</var>是<a lt="XMLNS namespace">XMLNS命名空间</a>但<var>qualifiedName</var>和<var>prefix</var>都不是"<code>xmlns</code>"，
 则<a lt="throw">抛出</a>一个"{{NamespaceError!!exception}}(命名空间错误)"的{{DOMException}}(DOM异常)。

 <li><p>返回<var>namespace</var>，<var>prefix</var>，和<var>localName</var>。
</ol>



<h2 id=events lt="Events">Events：事件</h2>

<h3 id=introduction-to-dom-events>DOM事件简介</h3>

在整个Web平台中，<a>events</a>(事件)被<a>dispatched</a>(分派)给对象以表示发生的事件，
例如网络活动或用户交互。这些对象实现{{EventTarget}}接口，因此可以通过调用{{EventTarget/addEventListener()}}添加
<a lt="event listeners">event listeners(事件侦听器)</a>来观察<a lt="events">事件</a>：

<pre class=lang-javascript>
obj.addEventListener("load", imgFetched)

function imgFetched(ev) {
  // great success
  &hellip;
}
</pre>

可以通过调用{{EventTarget/removeEventListener()}}方法并传递相同的参数来删除<a lt="event listeners">Event listeners(事件侦听器)</a>。

<pre class=lang-javascript>
obj.removeEventListener("load", imgFetched)
</pre>

你还可以通过向{{EventTarget/addEventListener()}}方法传递{{AbortSignal}}信号，然后调用该信号的控制器的{{AbortController/abort()}}
方法来删除<a lt="event listeners">event listeners(事件监听器)</a>

<pre class=lang-javascript>
const controller=new AbortController()
const signal = controller.signal

obj.addEventListener("load", imgFetched,{
  signal:signal
})

controller.abort() //调用该方法删除事件监听器
</pre>

<a lt="events">事件</a>也是一个对象，它实现了{{Event}}接口(或派生接口)。在第一个例子中，函数的参数ev是一个<a>event</a>对象，ev作为参数传递
给<a lt="event listener">event listener(事件监听器)</a>的<a for="event listener" lt="callback">回调函数</a>(通常是如上所示的
JavaScript函数)。<a lt="event listener">event listener(事件监听器)</a>使用<a>event</a>的{{Event/type}}属性来表示监听哪种事件
(上诉例子中的"load")。<a>event</a>的{{Event/target}}属性则表明了事件被<a lt="dispatched">分配</a>到哪个对象中(上述例子中的obj)。

<p id="synthetic-events">尽管<a lt="events">事件</a>通常作为用户交互或完成某些任务的结果由用户代理进行<a lt="dispatched">分派</a>，但应用
程序可以使用合成事件的方式自行<a lt="dispatched">分派</a><a lt="events">事件</a>：

<pre class='lang-javascript'>
// add an appropriate event listener
obj.addEventListener("cat", function(e) { process(e.detail) })

// create and dispatch the event
var event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
obj.dispatchEvent(event)
</pre>

除了信号以外，<a lt="events">事件</a>有时还用于让应用程序控制操作接下来发生的事情。例如，表单提交时将<a lt="dispatched">调度</a>一个
{{Event/type}}属性值为"submit"的<a lt="events">事件</a>。如果调用此<a lt="event">事件</a>的{{Event/preventDefault()}}
方法，表单提交将终止。希望通过应用程序<a lt="dispatched">分派</a>的<a lt="events">事件</a>(合成事件)使用此功能的应用程序
可以使用{{EventTarget/dispatchEvent()}}方法的返回值：

<pre class=lang-javascript>
if(obj.dispatchEvent(event)) {
  // 如果事件没有被取消
  &hellip;
}
</pre>

<p>当<a lt="event">事件</a>被<a lt="dispatched">分派</a>到<a lt="participates">参与</a><a>tree</a>的对象
(例如一个<a for=/ lt="element"/>元素</a>)时，该对象的<a lt="ancestors">祖先</a>的<a lt="event listeners">
event listeners(事件监听器)</a>也会接收到分派的事件。当该对象的<a lt="inclusive ancestor">包容性祖先</a>
的<a lt="event listeners">event listeners(事件监听器)</a>的<a for="event listener">capture</a>属性为true时，
它们接收到分派事件的顺序为<a lt="tree order">树的顺序</a>；当该对象的<a lt="inclusive ancestor">包容性祖先</a>
的<a lt="event listeners">event listeners(事件监听器)</a>的<a for="event listener">capture</a>属性为false，
且<a>event</a>的{{Event/bubbles}}属性为true时，它们接收到分派事件的顺序为树的逆向顺序。

<p>让我们看一个<a>event</a>如何在<a>tree</a>中工作的例子:
<pre class=lang-markup>
&lt;!doctype html>
&lt;html>
 &lt;head>
  &lt;title>Boring example&lt;/title>
 &lt;/head>
 &lt;body>
  &lt;p>Hello &lt;span id=x>world&lt;/span>!&lt;/p>
  &lt;p>在事件捕获中，事件从最外层元素传播到目标元素。它与事件冒泡相反，事件从目标向外传播到外部元素。
  捕获发生在冒泡之前。事件传播的三个阶段是：捕获、目标和冒泡。&lt;/p>
  &lt;script>
   function test(e) {
    console.info('（捕获阶段）currentTarget：'+e.currentTarget.nodeName)
   } 
   function test2(e) {
    console.info('（冒泡阶段）currentTarget：'+e.currentTarget.nodeName)
   }
   // 捕获阶段
   document.addEventListener("hey", test,{capture:true})
   document.body.addEventListener("hey", test,{capture:true})
   document.getElementById("x").addEventListener("hey", test,{capture:true})
   // 冒泡阶段
   document.addEventListener("hey", test2)
   document.body.addEventListener("hey", test2)
   document.getElementById("x").addEventListener("hey",test2)

   var ev = new Event("hey", {bubbles:true})  //bubbles:是否冒泡
   document.getElementById("x").dispatchEvent(ev)

   /**  控制台输出：
    * （捕获阶段）currentTarget：#document
      （捕获阶段）currentTarget：BODY
      （捕获阶段）currentTarget：SPAN
      （冒泡阶段）currentTarget：SPAN
      （冒泡阶段）currentTarget：BODY
      （冒泡阶段）currentTarget：#document
    * 
    **/
  &lt;/script>
 &lt;/body>
&lt;/html>
</pre>

<p>test与test2函数分别会被调用3次。test的调用处于捕获阶段，因此其顺序为<a>document</a>—>body—>span；
test2的调用处于冒泡阶段，因此顺序span—>body—><a>document</a>。

<h3 id=interface-event>{{Event}}接口</h3>

<pre class=idl>
[Exposed=*]
interface Event {
  constructor(DOMString type, optional EventInit eventInitDict = {});

  readonly attribute DOMString type;
  readonly attribute EventTarget? target;
  readonly attribute EventTarget? srcElement; // legacy
  readonly attribute EventTarget? currentTarget;
  sequence&lt;EventTarget> composedPath();

  const unsigned short NONE = 0;
  const unsigned short CAPTURING_PHASE = 1;
  const unsigned short AT_TARGET = 2;
  const unsigned short BUBBLING_PHASE = 3;
  readonly attribute unsigned short eventPhase;

  undefined stopPropagation();
           attribute boolean cancelBubble; // legacy alias of .stopPropagation()
  undefined stopImmediatePropagation();

  readonly attribute boolean bubbles;
  readonly attribute boolean cancelable;
           attribute boolean returnValue;  // legacy
  undefined preventDefault();
  readonly attribute boolean defaultPrevented;
  readonly attribute boolean composed;

  [LegacyUnforgeable] readonly attribute boolean isTrusted;
  readonly attribute DOMHighResTimeStamp timeStamp;

  undefined initEvent(DOMString type, optional boolean bubbles = false, optional boolean cancelable = false); // legacy
};

dictionary EventInit {
  boolean bubbles = false;
  boolean cancelable = false;
  boolean composed = false;
};
</pre>

<p>一个{{Event}}对象可以简单的被称为一个<dfn export id=concept-event lt="event">事件</dfn>。它允许用
信号的方式通知某些事情已经发生，例如图像已经完成下载。</p>

<p><dfn export lt="potential event target">event的target属性值可能</dfn>为null或{{EventTarget}}对象。

每个<a lt="event">事件</a>都与<dfn export for=Event>target</dfn>(该属性值可能为null或{{EventTarget}}对象)有关，
除非另有说明，否则为空。

每个<a lt="event">事件</a>都可能与<dfn export for=Event>relatedTarget</dfn>(该属性值可能为null或{{EventTarget}}对象)有关，
除非另有说明，否则为空。

<p class=note><a for=Event>relatedTarget</a>属性主要存在于{{FocusEvent}}、{{MouseEvent}}和{{TouchEvent}}在这些事件类型中，
它指的是与事件相关的元素。例如，在{{MouseEvent}}中，该属性可以引用用户将光标移动到的元素，或者他们单击的元素。在{{FocusEvent}}中，
该属性可以指用户将焦点移动到的元素，或者他们模糊处理的元素。在{{TouchEvent}}中，该属性可以引用在多点触摸手势中触摸的元素。
<a for=Event>relatedTarget</a>属性的确切含义可能因具体事件和使用它的上下文而异。[[UIEVENTS]]

每个<a lt="event">事件</a>都可能与<dfn export for=Event>targetTouches</dfn>(该属性值可能为由0个或多个null或
{{EventTarget}}对象组成的<a for=/ lt="list">列表</a>)有关，除非另有说明，否则为空。

<p class=note><a for=Event>targetTouches</a>属性仅存在于{{TouchEvent}}事件类型，它用于标识当前处于活动状态并与事件的目标元素相交的触摸点列表，
该属性是一个Touch对象数组，每个对象代表设备表面上的一个触摸点。它可用于确定页面上特定元素上发生的多点触摸手势的细节，
例如涉及的手指数量和屏幕上每个触摸点的位置。通过使用该属性列表中对象的<a for=Event>target</a>属性，它还可以用于识别页面上当前正在被用户触摸的元素。[[TOUCH-EVENTS]]

<p>每个<a lt="event">事件</a>都与<dfn export for=Event>path</dfn>有关。<a for=Event>path</a>属性值是一个<a for=/ lt="structs">
结构体</a><a for=/ lt="list">列表</a>。每个<a for=/ lt="structs">结构体</a>都包含了
<dfn for=Event/path>invocation target</dfn>(属性值为{{EventTarget}}对象)，
<dfn for=Event/path>invocation-target-in-shadow-tree</dfn>(属性值为Boolean)，
<dfn for=Event/path>shadow-adjusted target</dfn>(属性值为{{EventTarget}}对象)，
<dfn id=event-path-relatedtarget for=Event/path>relatedTarget</dfn>(属性值为{{EventTarget}}对象)，
<dfn for=Event/path>touch target list</dfn>(属性值为{{EventTarget}}对象组成的<a for=/ lt="list">列表</a>)，
<dfn for=Event/path>root-of-closed-tree</dfn>(属性值为Boolean)，
<dfn for=Event/path>slot-in-closed-tree</dfn>(属性值为Boolean)，<a for=Event>path</a>的初始值为空列表。</p>

<dl class=domintro>
 <dt><code><var>event</var> = new <a constructor lt="Event()">Event</a>(<var>type</var> [, <var>eventInitDict</var>])</code>
 <dd>返回一个新事件，设置{{Event/type}}属性
 为传入的type参数。eventInitDict参数允许通过
 同名对象成员设置{{Event/bubbles}}和{{Event/cancelable}}属性。

 <dt><code><var>event</var> . {{Event/type}}</code>
 <dd>返回事件的类型，例如"<code>click</code>"、
 "<code>hashchange</code>"或"<code>submit</code>"。

 <dt><code><var>event</var> . {{Event/target}}</code>
 <dd>返回事件被<a lt="dispatched">分派</a>到的对象（它的<a for=Event>target</a>）。

 <dt><code><var>event</var> . {{Event/currentTarget}}</code>
 <dd>返回当前正在调用<a lt="event listener">事件侦听器</a>回调的对象。

 <dt><code><var>event</var> . {{Event/composedPath()}}</code>
 <dd>返回 <a for=Event>path</a>的<a for=Event/path>invocation target</a>对象(这些对象将调用侦听器)，
 <a for=/>shadow trees</a>中<a for=/ lt="shadow root">根节点</a>的<a for=ShadowRoot>mode</a>属性为
 "closed"且无法从事件的{{Event/currentTarget}}属性访问的节点将不被返回。

 <dt><code><var>event</var> . {{Event/eventPhase}}</code>
 <dd>返回<a lt="event">事件</a>的阶段，它的值为{{Event/NONE}}(无，值为0)、{{Event/CAPTURING_PHASE}}(捕获阶段，值为1)、
 {{Event/AT_TARGET}}(调度阶段，值为2)和{{Event/BUBBLING_PHASE}}(冒泡阶段，值为3)之一。

 <dt><code><var>event</var> . <a method for=Event lt="stopPropagation()">stopPropagation</a>()</code>
 <dd>调用此方法可防止事件到达当前对象以外的任何对象(该方法不仅可以阻止事件冒泡，且在捕获阶段仍然能阻止)。

 <dt><code><var>event</var> . <a method for=Event lt="stopImmediatePropagation()">stopImmediatePropagation</a>()</code>
 <dd>调用此方法可防止事件到达当前对象以外的任何对象，除此之外，调用此方法可防止事件在当前事件完成运行后到达当前对象已注册的同类型
 (event的type相同)的<a lt="event listeners">事件侦听器</a>。

 <dt><code><var>event</var> . {{Event/bubbles}}</code>
 <dd>返回true或false，true代表允许事件按照树的逆向顺序从<a for=Event lt="target">目标</a>向外传播到外部元素(事件冒泡)，反之则不允许
 
 <dt><code><var>event</var> . {{Event/cancelable}}</code>
 <dd>根据事件的初始化方式返回true或false。它的返回值并不总是有意义的，因为它仅表示事件的默认行为是否可以取消，
 即使该event.cancelable属性是true，也不能保证调用{{Event/preventDefault()}}方法实际上会阻止触发默认行为。
 这是因为 {{Event/preventDefault()}}方法只有在默认行为发生之前被调用时才有效。如果已经触发了默认行为，则调用
  {{Event/preventDefault()}}不会有任何效果。true表示允许通过调用 {{Event/preventDefault()}}方法取消
  <a lt="dispatched">分派</a>事件的部分操作，false表示不允许。

 <dt><code><var>event</var> . <a method for=Event lt="preventDefault()">preventDefault</a>()</code>
 <dd>如果在{{Event/cancelable}}属性值为true时调用，并且在为{{AddEventListenerOptions/passive}}属性设置
 为false的事件执行侦听器时，向导致事件被<a lt="dispatched">分派</a>的操作发出信号，表明它需要被取消。

 <dt><code><var>event</var> . {{Event/defaultPrevented}}</code>
 <dd>如果成功调用{{Event/preventDefault()}}以指示取消，则返回true；否则返回false。

 <dt><code><var>event</var> . {{Event/composed}}</code>
 <dd>根据事件的初始化方式返回true或false。如果事件通过其目标的根节点是{{ShadowRoot}}节点调用侦听器，则为真；否则为假。

 <dt><code><var>event</var> . {{Event/isTrusted}}</code>
 <dd>如果事件是由用户代理<a lt="dispatched">分派</a>的，则返回true，否则返回false。

 <dt><code><var>event</var> . {{Event/timeStamp}}</code>
 <dd>返回事件的时间戳，作为相对于时间原点测量的毫秒数。
</dl>

<p><dfn attribute for=Event><code>type</code></dfn>属性必须返回它被初始化的值。创建<a lt="event">事件</a>时，必须将属性初始化为空字符串。

<p><dfn attribute for=Event><code>target</code></dfn>的get方法返回<a>this</a>的<a for=Event>target</a>属性值。

<p><dfn attribute for=Event><code>srcElement</code></dfn>的get方法返回<a>this</a>的<a for=Event>target</a>属性值。

<p><dfn attribute for=Event><code>currentTarget</code></dfn>属性必须返回它被初始化的值。创建<a lt="event">事件</a>时，必须将属性初始化为null。

<p><dfn method for=Event><code>composedPath()</code></dfn>方法执行步骤：

<ol>
 <li><p>设composedPath为空<a for=/ lt="list">列表</a>。

 <li><p>设path为<a>this</a>.<a for=Event>path</a>。

 <li><p>如果path<a for=list lt="is empty">为空</a>，则返回<var>composedPath</var>。

 <li><p>设currentTarget为this.{{Event/currentTarget}}的属性值。

 <li><p>将<var>currentTarget</var><a for=list lt="Append">添加</a>到<var>composedPath</var>。

 <li><p>设<var>currentTargetIndex</var>为0。

 <li><p>设<var>currentTargetHiddenSubtreeLevel</var>为0。

 <li><p>设<var>index</var>为<var>path</var>的<a for=list>size</a>-1。

 <li>
  <p>当 <var>index</var>大于等于0：

  <ol>
   <li><p>如果path[<var>index</var>]的<a for=Event/path>root-of-closed-tree</a>为true，<var>currentTargetHiddenSubtreeLevel</var>增加1。

   <li><p>如果path[<var>index</var>]的<a for=Event/path>invocation target</a>等于<var>currentTarget</var>，
   则将<var>currentTargetIndex</var>设置为<var>index</var>并且break出循环。

   <li><p>如果path[<var>index</var>]的<a for=Event/path>slot-in-closed-tree</a>为true，<var>currentTargetHiddenSubtreeLevel</var>减1。

   <li><p>将<var>index</var>减1。
  </ol>

 <li><p>设<var>currentHiddenLevel</var>和<var>maxHiddenLevel</var>的值为<var>currentTargetHiddenSubtreeLevel</var>。

 <li><p>设<var>index</var>为<var>currentTargetIndex</var>&minus; 1。

 <li>
  <p>当 <var>index</var>大于等于0：

  <ol>
   <li><p>如果path[<var>index</var>]的<a for=Event/path>root-of-closed-tree</a>为true，<var>currentHiddenLevel</var>增加1。

   <li><p>如果<var>currentHiddenLevel</var>小于等于<var>maxHiddenLevel</var>， 则将<var>path</var>[<var>index</var>]的
   <a for=Event/path>invocation target</a>添加到<var>composedPath</var>之前。

   <li>
    <p>如果<var>path</var>[<var>index</var>]的<a for=Event/path>slot-in-closed-tree</a>为true，则：

    <ol>
     <li><p><var>currentHiddenLevel</var>减1。

     <li><p>如果<var>currentHiddenLevel</var>小于<var>maxHiddenLevel</var>，则将<var>maxHiddenLevel</var>设置为<var>currentHiddenLevel</var>。
    </ol>

   <li><p>将<var>index</var>减1。
  </ol>

 <li><p>设<var>currentHiddenLevel</var>和<var>maxHiddenLevel</var>为
 <var>currentTargetHiddenSubtreeLevel</var>。

 <li><p>将<var>index</var>设置为<var>currentTargetIndex</var> + 1。

 <li>
  <p>当<var>index</var>小于<var>path</var>的<a for=list>size</a>:

  <ol>
   <li><p>如果<var>path</var>[<var>index</var>]的<a for=Event/path>slot-in-closed-tree</a>为true，
   则将<var>currentHiddenLevel</var>增加1。

   <li><p>如果<var>currentHiddenLevel</var>小于等于<var>maxHiddenLevel</var>， 则将
   <var>path</var>[<var>index</var>]的<a for=Event/path>invocation target</a><a for=list lt="append">添加到</a><var>composedPath</var>。

   <li>
    <p>如<var>path</var>[<var>index</var>]的<a for=Event/path>root-of-closed-tree</a>为true，则：

    <ol>
     <li><p><var>currentHiddenLevel</var>减1。

     <li><p>如果<var>currentHiddenLevel</var>小于<var>maxHiddenLevel</var>，则将
     <var>maxHiddenLevel</var>设置为<var>currentHiddenLevel</var>。
    </ol>

   <li><p>将<var>index</var>增加1。
  </ol>

 <li><p>返回<var>composedPath</var>。
</ol>

<p><dfn attribute for=Event><code>eventPhase</code></dfn>属性必须返回它被初始化的值，它必须是以下之一：

<dl>
 <dt><dfn const for=Event>NONE</dfn> (值为0)
 <dd>处于<a>event</a>未<a lt="dispatched">分派</a>阶段(事件处于未分派阶段)。

 <dt><dfn const for=Event>CAPTURING_PHASE</dfn> (值为1)
 <dd>当<a>event</a>被<a lt="dispatched">分派</a>给<a lt="participates">参与</a><a lt="tree">树</a>的对象时，
 它将在到达<a for=Event>target</a>之前处于此阶段(事件处于捕获阶段)。

 <dt><dfn const for=Event>AT_TARGET</dfn> (值为2)
 <dd>当一个<a lt="event">事件</a>被<a lt="dispatched">分派</a>时，它将在它的<a for=Event>target</a>上处于这个阶段(事件处于到达目标阶段)。

 <dt><dfn const for=Event>BUBBLING_PHASE</dfn> (numeric value 3)
 <dd>当<a lt="event">事件</a>被<a lt="dispatched">分派</a>给<a lt="participates">参与</a><a lt="tree">树</a>的对象时，
 它将在到达其<a for=Event>target</a>后处于此阶段(事件处于冒泡阶段)。
</dl>

<p>该属性必须初始化为{{Event/NONE}}

<hr>

<p>每个<a lt="event">事件</a>都有以下关联的标志，这些标志最初都是未设置的：

<ul>
 <li><dfn export for=Event id=stop-propagation-flag>stop propagation flag</dfn>(停止传播标志)
 <li><dfn export for=Event id=stop-immediate-propagation-flag>stop immediate propagation flag</dfn>(停止直系传播标志)
 <li><dfn export for=Event id=canceled-flag>canceled flag</dfn>(取消标志)
 <li><dfn export for=Event id=in-passive-listener-flag>in passive listener flag</dfn>(被动监听标志)
 <li><dfn export for=Event id=composed-flag>composed flag</dfn>(组合标志)
 <li><dfn export for=Event id=initialized-flag>initialized flag</dfn>(初始化标志)
 <li><dfn export for=Event id=dispatch-flag>dispatch flag</dfn>(分派标志)
</ul>

<p><dfn method for=Event><code>stopPropagation()</code></dfn>方法将会设置<a>this</a>的<a>stop propagation flag</a>。</p>

<p>如果<a>this</a>的<a>stop propagation flag</a>被设置，<dfn attribute for=Event><code>cancelBubble</code></dfn>
的get()方法将会返回true，否则返回false。

<p>{{Event/cancelBubble}}的set()方法是在给定值为true时设置<a>this</a>的<a>stop propagation flag</a>；否则什么也不做。

<p><dfn method for=Event><code>stopImmediatePropagation()</code></dfn>方法将会设置<a>this</a>的<a>stop propagation flag</a>
和<a>this</a>的<a>stop immediate propagation flag</a>。

<p><dfn attribute for=Event><code>bubbles</code></dfn>和<dfn attribute for=Event><code>cancelable</code></dfn>
必须返回其初始化的值。

<p>给定一个<a lt="event">事件</a>，如果其{{Event/cancelable}}属性为true并且其<a>in passive listener flag</a>未被设置， 
则将设置它的<a>canceled flag</a>。

<p>如果<a>this</a>的<a>canceled flag</a>被设置，则<dfn attribute for=Event><code>returnValue</code></dfn>的get()方法
将返回false，否则返回true。

<p>{{Event/returnValue}}的set()方法是在给定值为false时设置<a>this</a>的<a>canceled flag</a>；否则什么也不做。

<p><dfn method for=Event><code>preventDefault()</code></dfn>方法将会设置<a>this</a>的<a>canceled flag</a>。

<p class=note>在某些情况下调用{{Event/preventDefault()}}无效。鼓励用户代理在开发人员控制台中记录准确的原因，以帮助调试。

<p>如果<a>this</a>的<a>canceled flag</a>被设置，则<dfn attribute for=Event><code>defaultPrevented</code></dfn>的get()方法
将返回true；否则放返回false。

<p>如果<a>this</a>的<a>composed flag</a>被设置，则<dfn attribute for=Event><code>composed</code></dfn>的get()方法将返回true;
否则返回false。

<hr>

<p><dfn attribute for=Event><code>isTrusted</code></dfn>属性必须返回它被初始化的值。创建<a lt="event">事件</a>时，
必须将属性初始化为 false。

<p class=note>{{Event/isTrusted}}表示<a lt="event">事件</a>是否由用户代理<a lt="dispatched">分派</a>(调用
{{EventTarget/dispatchEvent()}}分派该属性则为false)。唯一的遗留异常是{{HTMLElement/click()}}方法，它会导致用户代理分派一个
{{Event/isTrusted}}属性初始化为false的<a lt="event">事件</a>。

<p><dfn attribute for=Event><code>timeStamp</code></dfn>属性必须返回它被初始化的值。

<hr>

<p>通过<var>type</var>， <var>bubbles</var>和<var>cancelable</var>
<dfn export for=Event id=concept-event-initialize lt="initialize">初始化</dfn>事件，将运行一下步骤:

<ol>
 <li><p>设置<var>event</var>的<a>initialized flag</a>。

 <li><p>取消<var>event</var>的<a>stop propagation flag</a>，<a>stop immediate propagation flag</a>和<a>canceled flag</a>。

 <li><p>设置<var>event</var>的{{Event/isTrusted}}属性为false。

 <li><p>设置<var>event</var>的<a for=Event>target</a>为null。

 <li><p>设置<var>event</var>的{{Event/type}}属性为<var>type</var>参数。

 <li><p>设置<var>event</var>的{{Event/bubbles}}属性为<var>bubbles</var>参数。

 <li><p>设置<var>event</var>的{{Event/cancelable}}属性为<var>cancelable</var>参数。
</ol>

<p>
<dfn method for=Event><code>initEvent(<var>type</var>， <var>bubbles</var>， <var>cancelable</var>)</code></dfn>
方法执行步骤:

<ol>
 <li><p>如果<a>this</a>的<a>dispatch flag</a>被设置，则return。

 <li><p><a lt="Initialize">初始化</a><a>this</a>的<var>type</var>，<var>bubbles</var>和<var>cancelable</var>。
</ol>

<p class="note">{{Event/initEvent()}}方法与<a lt="event">事件</a>构造函数是冗余的，<a lt="event">事件</a>构造函数是一种更加现代和
标准的创建事件的方式，而{{Event/initEvent()}}方法是一种已被废弃的旧方法，且它无法设置事件的{{Event/composed}}属性。
由于它是遗留问题，因此才保留它。

<h3 id=interface-window-extensions>遗留扩展：{{Window}}接口</h3>

<pre class=idl>
partial interface Window {
  [Replaceable] readonly attribute (Event or undefined) event; // legacy
};
</pre>

<p>{{Window}}对象中存在一个关联的<dfn for=Window lt="current event">当前事件</dfn>(属性值为undefined或{{Event}}对象)。
除非另有说明，否则它是未定义的。

<p><dfn attribute for=Window><code>event</code></dfn>get()方法返回<a>this</a>的<a for=Window lt="current event">当前事件</a>.

<p class=note>强烈建议Web开发人员使用传递给事件侦听器的{{Event}}对象替代该属性，因为这将产生移植性更高的代码，
且此属性在worker或worklet中不可用，对于影子树中调度的事件也不准确。


<h3 id=interface-customevent>{{CustomEvent}}接口</h3>

<pre class=idl>
[Exposed=*]
interface CustomEvent : Event {
  constructor(DOMString type, optional CustomEventInit eventInitDict = {});

  readonly attribute any detail;

  undefined initCustomEvent(DOMString type, optional boolean bubbles = false, optional boolean cancelable = false, optional any detail = null); // legacy
};

dictionary CustomEventInit : EventInit {
  any detail = null;
};
</pre>

<a lt="Events">事件</a>使用{{CustomEvent}}定义能够携带自定义数据。

<dl class=domintro>
 <dt><code><var>event</var> = new <a constructor lt="CustomEvent()">CustomEvent</a>(<var>type</var> [, <var>eventInitDict</var>])</code>
 <dd>与{{Event}}构造函数类似，除了{{CustomEvent/detail}}参数现在也允许设置detail属性。

 <dt><code><var>event</var> . {{CustomEvent/detail}}</code>
 <dd>返回事件创建时自定义的数据，通常适用于合成事件。
</dl>

<p><dfn attribute for=CustomEvent><code>detail</code></dfn>属性必须返回它被初始化的值。

<p><dfn method for=CustomEvent><code>initCustomEvent(<var>type</var>, <var>bubbles</var>, <var>cancelable</var>, <var>detail</var>)</code></dfn>
方法执行步骤:

<ol>
 <li><p>如果<a>this</a>的<a>dispatch flag</a>被设置，则直接return。

 <li><p><a lt="Initialize">初始化</a><a>this</a>的<var>type</var>， <var>bubbles</var>和<var>cancelable</var>。

 <li><p>设<a>this</a>的{{CustomEvent/detail}}属性为传入的<var>detail</var>参数.
</ol>


<h3 id=constructing-events>事件构造过程</h3>


<a lt="Other applicable specifications">规范</a>定义了所有或一些<dfn export id=concept-event-constructor-ext>事件创建过程</dfn>。
如<a lt="inner event creation steps">内部事件创建步骤</a>所示，向算法传递一个<a>event</a>参数以及一个{{EventInit}}参数。

<p class=note>这种构造方法可以被{{Event}}子类使用，这些{{Event}}子类具有比其初始化字典成员和IDL属性之间的简单1:1映射更复杂的结构。

<p>当一个{{Event}}接口或者一个继承于{{Event}}的接口的<dfn export for=Event id=concept-event-constructor>constructor</dfn>(构造函数)被调用，
给定参数type和eventInitDict，将运行以下步骤：

<ol>
 <li><p>使用事件接口，null，now，<var>eventInitDict</var>四个参数运行<a lt="inner event creation steps">内部事件创建步骤</a>，
 将返回结果赋值给<var>event</var>。

 <li><p>使用<var>type</var>参数初始化<var>event</var>的{{Event/type}}属性。

 <li><p>返回<var>event</var>。
</ol>

<p>使用Event接口或继承其的接口<dfn export id=concept-event-create lt="creating an event|create an event">创建事件</dfn>，
给定可选择的<a>realm</a>参数，将运行以下步骤：</p>

<ol>
 <li><p>如果未给定参数<var>realm</var>，则设置其为null。

 <li>
  <p>将JavaScript中undefined值<a lt="converted to an IDL value">转换</a>为构造函数接受的字典类型(该字典类型要么是{{EventInit}}
  要么是从它继承的字典)，设<var>dictionary</var>为其返回结果。

  <p class=XXX>如果字典存在强制成员，这将不起作用；请参阅<a href="https://github.com/whatwg/dom/issues/600">whatwg/dom#600</a>。

 <li>
  <p>使用事件接口、<var>realm</var>、事件发出信号的发生时间、<var>dictionary</var>四个参数运行<a lt="inner event creation steps">内部事件创建步骤</a>，
  设<var>event</var>为其返回结果。

  <p class=example id=example-timestamp-initialization>在macOS中，输入操作的发生时间可通过NSEvent对象的<code>timestamp</code>属性获得。

 <li><p>初始化<var>event</var>的{{Event/isTrusted}}属性为true。

 <li><p>返回<var>event</var>。
</ol>

<p class=note><a lt="Create an event">创建事件</a>旨在供其他规范使用，这些规范需要单独<a lt="create an event">创建</a>
和<a lt="dispatch">分发</a>事件，而不是简单地<a lt="fire an event">触发</a>它们。它确保事件的属性被初始化为正确的默认值。</p>

<p><dfn noexport lt="inner event creation steps">内部事件创建步骤</dfn>，给定参数<var>interface</var>、
<var>realm</var>、<var>time</var>和<var>dictionary</var>，将运行：</p>

<ol>
 <li>
  <p>让<var>event</var>成为使用传入interface参数创建新对象的结果。如果<var>realm</var>不为null，则使用该参数；
  否则使用webIDL中定义的默认行为。

  <p class=XXX>截至撰写本文时，Web IDL 尚未定义任何默认行为；参见<a href="https://github.com/whatwg/webidl/issues/135">whatwg/webidl#135</a>。
  
 <li><p>设置<var>event</var>的<a>initialized flag</a>.

 <li><p>给定<var>time</var>和<var>event</var>的<a lt="relevant global object">相关全局对象</a>，将<var>event</var>的{{Event/timeStamp}}
 属初始化为<a lt="relative high resolution coarse time">相对高分辨率的粗略时间</a>。

 <li><p><a for=map lt="For each">遍历</a><var>dictionary</var>的每个成员以及其<var>value</var>，如果<var>event</var>
 存在与字典成员相同的<a spec=webidl>identifier</a>，则将<var>event</var>的属性初始化为成员的<var>value</var>。

 <li><p>使用<var>event</var>和<var>dictionary</var>参数运行<a lt="event constructing steps">事件构造步骤</a>。

 <li><p>返回<var>event</var>。
</ol>


<h3 id=defining-event-interfaces>定义事件接口</h3>

通常，在定义继承自{{Event}}的新接口时，请始终征求<a href=https://whatwg.org/>WHATWG</a>或
<a href=https://www.w3.org/2008/webapps/>W3C WebApps WG</a>社区的反馈。

{{CustomEvent}}接口可以用作起点。但是，不要引入任何{{Event/initEvent()}}方法，因为它们相对于构造函数是冗余的。
继承自具有此类方法的{{Event}}接口的接口仅出于历史原因而保留它。


<h3 id=interface-eventtarget>{{EventTarget}}接口</h3>

<pre class=idl>
[Exposed=*]
interface EventTarget {
  constructor();

  undefined addEventListener(DOMString type, EventListener? callback, optional (AddEventListenerOptions or boolean) options = {});
  undefined removeEventListener(DOMString type, EventListener? callback, optional (EventListenerOptions or boolean) options = {});
  boolean dispatchEvent(Event event);
};

callback interface EventListener {
  undefined handleEvent(Event event);
};

dictionary EventListenerOptions {
  boolean capture = false;
};

dictionary AddEventListenerOptions : EventListenerOptions {
  boolean passive;
  boolean once = false;
  AbortSignal signal;
};
</pre>

<p>{{EventTarget}}对象代表一个目标，事件发生时可以将<a lt="event">事件</a><a lt="dispatched">分派</a>到该目标。

<p>每个{{EventTarget}}对象都有一个相关的<dfn for=EventTarget lt="event listener list">事件监听列表</dfn>
(零个或多个事件侦听器的列表)。它最初为一个空列表。
<!-- Intentionally not exported. -->

<p><dfn export id=concept-event-listener lt="event listener">事件监听器</dfn>用于观察特定的事件<a>event</a>，
它由以下内容组成：

<ul class=brief>
 <li><dfn for="event listener">type</dfn>(类型，string)
 <li><dfn for="event listener">callback</dfn>(回调函数，null或{{EventListener}})
 <li><dfn for="event listener">capture</dfn>(是否捕获阶段触发，boolean，初值为false)
 <li><dfn for="event listener">passive</dfn>(是否不允许调用event.preventDefault()，null或boolean，初值null)
 <li><dfn for="event listener">once</dfn>(是否仅调用一次，boolean，初值false)
 <li><dfn for="event listener">signal</dfn>(信号对象，允许使用{{AbortController/abort()}}方法移除监听器，null或{{AbortSignal}})
 <li><dfn for="event listener">removed</dfn> (用于内部处理，boolean，初值false)
</ul>

<p class=note>尽管<a for="event listener">callback</a>是一个{{EventListener}}对象，但<a lt="event listener">事件监听器</a>
是一个更广泛的概念，如上所示。

<p>每个{{EventTarget}}对象还有一个相关的<dfn export lt="get the parent">获取父级</dfn>算法，它接受一个<a>event</a>参数，
并返回一个{{EventTarget}}对象。除非另有说明，否则返回 null。

<p class=note><a for=/>Nodes</a>, <a for=/>shadow roots</a>以及<a>documents</a>
覆盖了<a lt="get the parent">获取父级</a>算法。

<p>每个{{EventTarget}}对象都可以有一个相关的<dfn export for=EventTarget lt="activation behavior">激活行为</dfn>算法。
如<a lt="dispatch">调度</a>算法中所示，需要向<a for=EventTarget lt="activation behavior">激活行为</a>算法传递一个
<a>event</a>。</p>

<p class=note>它的存在是因为用户代理对某些{{EventTarget}}对象执行某些操作，例如<{area}>元素，以响应其{{Event/type}}属性为
<code>click</code>的{{MouseEvent}}事件。考虑Web平台兼容性问题，它没有被删除。在定义任何激活时，它现在也是被尊重的方式。[[!HTML]]

<p>每个具有<a for=EventTarget lt="activation behavior">激活行为</a>的{{EventTarget}}对象都可以另外具有(或都不具有)
<dfn export for=EventTarget lt="legacy-pre-activation behavior">遗留预激活行为</dfn>算法和
<dfn export for=EventTarget lt="legacy-canceled-activation behavior">遗留取消激活行为</dfn>算法。

<p class=note>这些算法仅适用于checkbox和radio <{input}>元素，不能用于其他任何内容。[[!HTML]]

<dl class=domintro>
 <dt><code><var>target</var> = new <a constructor for=EventTarget lt=EventTarget()>EventTarget</a>();</code>
 <dd><p>创建一个{{EventTarget}}对象，开发人员能够使用该对象<a lt="dispatch">调度</a>和监听<a lt="events">事件</a>。

 <dt><code><var>target</var> . <a method for=EventTarget lt=addEventListener()>addEventListener</a>(<var>type</var>, <var>callback</var> [, <var>options</var>])</code>
 <dd>
  <p>给{{Event/type}}属性为传入的<var>type</var>参数的<a lt="events">事件</a>，添加一个<a lt="event listener">事件监听器</a>。
  <var>callback</var>参数设置了当<a lt="events">事件</a>被<a lt="dispatched">调度</a>时调用的<a for="event listener" lt="callback">回调函数</a>。
 
  <p><var>options</var>参数设置了监听器的可选择的特定参数。为了兼容性，该参数可以是一个boolean值，此时该值则是设定<var>options</var>中的{{EventListenerOptions/capture}}
  参数。

  <p>当<var>options</var>的{{EventListenerOptions/capture}}设置为true时，会阻止在<a lt="event">事件</a>的{{Event/eventPhase}}属性值为{{Event/BUBBLING_PHASE}}
  (事件处于冒泡阶段)时调用<a for="event listener" lt="callback">回调函数</a>。如果设置为false(或不存在)，则当<a lt="event">事件</a>的{{Event/eventPhase}}属性值为
  {{Event/CAPTURING_PHASE}}(事件处于捕获阶段)时不会调用<a for="event listener" lt="callback">回调函数</a>。无论哪种方式，当<a lt="event">事件</a>的
  {{Event/eventPhase}}属性值为{{Event/AT_TARGET}}(事件处于到达目标阶段)时，都会调用<a for="event listener" lt="callback">回调函数</a>。

  <p>当<var>options</var>的{{AddEventListenerOptions/passive}}设置为true时，表示<a for="event listener" lt="callback">回调函数</a>不会通过调用
  {{Event/preventDefault()}}来取消事件。这用于启用[[#observing-event-listeners]]描述的性能优化。

  <p>当<var>options</var>的{{AddEventListenerOptions/once}}设置为true时，表示<a for="event listener" lt="callback">回调函数</a>只会被调用一次，
  之后事件监听器将被删除。

  <p>如果为<var>options</var>的{{AddEventListenerOptions/signal}}参数传递了{{AbortSignal}}信号，则当信号被中止时事件侦听器将被删除。

  <p><a lt="event listener">事件侦听器</a>添加到目标的<a for=EventTarget lt="event listener list">事件侦听器列表</a>，如果它具有相同的
  <a for="event listener">type</a>、<a for="event listener">callback</a>和<a for="event listener">capture</a>，则不添加。

 <dt><code><var>target</var> . <a method for=EventTarget lt=removeEventListener()>removeEventListener</a>(<var>type</var>, <var>callback</var> [, <var>options</var>])</code>
 <dd><p>移除目标<a for=EventTarget lt="event listener list">事件侦听器列表</a>中具有相同<var>type</var>、<var>callback</var>和<var>options</var>的
 <a lt="event listener">事件侦听器</a>。

 <dt><code><var>target</var> . <a method for=EventTarget lt=dispatchEvent()>dispatchEvent</a>(<var>event</var>)</code>
 <dd><p>如果任一事件的{{Event/cancelable}}属性值为false或其{{Event/preventDefault()}}方法未被调用，则将事件<a lt="Dispatches">分派</a>到目标并返回true；
 否则返回false。
 
</dl>

<p><dfn export for=Event id=concept-flatten-options>flatten</dfn>(将一个多层嵌套的数据结构转换为一个单层的数据结构)
<var>options</var>，将<var>options</var>转换为一个布尔值，将运行以下步骤：

<ol>
 <li><p>如果<var>options</var>是布尔值，则直接返回<var>options</var>。

 <li><p>否则，则返回options中{{EventListenerOptions/capture}}对象内容。
</ol>

<p><dfn export for=Event lt="flatten more">flatten more</dfn><!-- sorry --> <var>options</var>，将<var>options</var>
对象转换为一组单独的值，将运行以下步骤：


<ol>
 <li><p>函数首先调用<a>flattening</a>(第一个例子)，将<var>options</var>对象转换为一个名为<var>capture</var>的布尔值。

 <li><p>设<var>once</var>为false。

 <li><p>设|passive|和|signal|为null。

 <li>
  <p>如|options|是一个<a for=/>dictionary</a>(字典), 则：

  <ol>
   <li><p>设|once|为options中{{AddEventListenerOptions/once}}对象的值。

   <li><p>如果|options|中的{{AddEventListenerOptions/passive}}对象存在，则设|passive|为
   |options|中{{AddEventListenerOptions/passive}}对象的值。

   <li><p>如果|options|中的{{AddEventListenerOptions/signal}}对象存在，则设|signal|为
   |options|中{{AddEventListenerOptions/signal}}对象的值。
  </ol>

 <li><p>返回<var>capture</var>、<var>passive</var>、<var>once</var>和<var>signal</var>。
</ol>

<p>使用EventTarget构造函数创建一个新对象时，不需要执行任何操作。

<p class=note>使用{{EventTarget}}构造函数创建的对象其他行为与属性的默认值：
  <ol>
   <li><p><a>get the parent</a>算法为null。这是一个指向父级对象的算法，它通常用于在事件冒泡过程中向上遍历事件路径。
   这个算法的默认值为null，意味着默认情况下，这个对象没有父级对象。
   <li><p>没有<a lt="activation behavior">激活行为</a>。激活行为指当事件触发时，对象所执行的操作。例如，如果对象是一个按钮，
   那么激活行为可能是触发点击事件，执行回调函数。这个对象没有激活行为，意味着默认情况下，这个对象不会执行任何操作。
   <li><p>没有<a lt="legacy-pre-activation behavior">遗留预激活行为</a>。遗留预激活行为指的是在旧版本的浏览器中，某些事件
   可能会在事件触发前执行的操作。   
   <li><p>没有<a lt="legacy-canceled-activation behavior">遗留取消激活行为</a>。遗留取消激活行为是指在旧版本的浏览器中，
   可能会使用特定的方式来阻止事件的默认行为，例如使用preventDefault()方法来阻止事件的默认行为。
  </ol>
</p>

<p class=note>将来我们可以允许自定义<a>get the parent</a>算法。让我们知道这是否对您的程序有用。
目前，所有作者创建的{{EventTarget}}都不参与树结构。

<p>给定参数|type|和|eventTarget|，确定<dfn lt="default passive value">passive默认值</dfn>流程如下：

<ol>
 <li>
  <p>以下两个条件都满足，则返回true：

  <ul>
   <li><p>|type|为"<code>touchstart</code>"，"<code>touchmove</code>"，
   "<code>wheel</code>"或者"<code>mousewheel</code>"。[[TOUCH-EVENTS]] [[UIEVENTS]]

   <li><p>|eventTarget|是一个{{Window}}对象，或者是一个<a>document</a>对象，或者是一个<a>document element</a>对象，或者是一个
   <a lt="the body element">body element</a>对象。 [[!HTML]]
  </ul>

 <li><p>否则，返回false。
</ol>

<p><dfn export lt="add an event listener">添加一个事件监听器</dfn>，给定参数{{EventTarget}}
(<var>eventTarget</var>)和<a>event listener</a>(<var>listener</var>)，将运行以下步骤：

<ol>
 <li><p>如果<var>eventTarget</var>是一个{{ServiceWorkerGlobalScope}}对象,则设置它的
 <a for="ServiceWorkerGlobalScope">service worker</a>的
 <a for="service worker" lt="script resource">脚本资源</a>的
 <a for="script resource">has ever been evaluated flag</a>，并且<var>listener</var>的
 <a for="event listener">type</a>属性匹配任何
 <a lt="service worker events">service worker事件</a>的type属性值，然后
 <a lt="report a warning to the console">向控制台报告警告</a>(这可能不会给出预期的结果)。
 [[!SERVICE-WORKERS]]

 <li><p>如果<var>listener</var>的<a for="event listener">signal</a>值不为空，且为
 [=AbortSignal/aborted=]，则直接return。

 <li><p>如果<var>listener</var>的<a for="event listener" lt="callback">回调函数</a>为空，则直接return。

 <li><p>如果<var>listener</var>的<a for="event listener">passive</a>值为null，
 则给定参数|type|和|eventTarget|确定<a lt="default passive value">passive默认值</a>。

 <li><p>如果<var>eventTarget</var>的<a>event listener list</a>不<a for=list lt="contain">包含</a>
 <a for="event listener">type</a>属性值为<var>listener</var>的<a for="event listener">type</a>属性值、
 <a for="event listener">callback</a>属性值为<var>listener</var>的<a for="event listener">callback</a>属性值、
 <a for="event listener">capture</a>属性值为<var>listener</var>的<a for="event listener">capture</a>属性值的
 <a lt="event listener">事件监听器</a>，则将<var>listener</var><a for=list lt="append">添加</a>到<var>eventTarget</var>
 的<a>event listener list</a>中。

 <li>
  <p>如果<var>listener</var>的<a for="event listener">signal</a>值不为null，则向其<a for=AbortSignal lt=add>添加</a>以下中止步骤：

  <ol>
   <li>使用<var>eventTarget</var>和<var>listener</var><a lt="Remove an event listener">移除事件监听器</a>。
  </ol>
</ol>

<p class=note><a lt="add an event listener">添加事件侦听器</a>概念的存在是为了确保<a lt="event handlers">事件处理程序</a>使用相同的代码路径。[[HTML]]

<p><dfn method for=EventTarget><code>addEventListener(<var>type</var>, <var>callback</var>, <var>options</var>)</code></dfn>
方法将执行以下步骤：

<ol>
 <li><p>设<var>capture</var>, <var>passive</var>, <var>once</var>以及<var>signal</var>为<a lt="flatten more">flattening more</a><var>options</var>
 的返回值。

 <li><p>使用<var>type</var>、<var>callback</var>、<var>capture</var>、<var>passive</var>、<var>once</var>以及<var>signal</var>向<a>this</a>
 <a lt="add an event listener">添加事件侦听器</a>。
</ol>

<p><dfn export lt="remove an event listener">删除事件监听器</dfn>，给定参数{{EventTarget}}(<var>eventTarget</var>)
和<a>event listener</a>(<var>listener</var>)，将运行以下步骤：

<ol>
 <li><p>如果<var>eventTarget</var>是一个{{ServiceWorkerGlobalScope}}对象并且它的
 <a for="ServiceWorkerGlobalScope">service worker</a>的
 <a for="service worker" lt="set of event types to handle">要处理的事件类型集</a>中包含<var>type</var>，则
 <a lt="report a warning to the console">向控制台报告警告</a>(这可能不会给出预期的结果)。
 [[!SERVICE-WORKERS]]

 <li><p>设<var>listener</var>的<a for="event listener">removed</a>属性为true且
 <a for=list lt="remove">删除</a><var>eventTarget</var>的
 <a for=EventTarget>event listener list</a>属性中的<var>listener</var>。
</ol>

<p class=note>HTML需要它来定义事件处理程序。[[HTML]]

<p><dfn export lt="remove all event listeners">移除所有事件监听器</dfn>，给定参数{{EventTarget}}(<var>eventTarget</var>)，
<a for=list lt="for each">遍历</a><var>eventTarget</var>的<a for=EventTarget>event listener list</a>属性中的每个事件监听器，
使用<var>eventTarget</var>与<var>listener</var>删除事件监听器。

<p class=note>HTML需要它来定义<code>document.open()</code>。[[HTML]]

<p><dfn method for=EventTarget><code>removeEventListener(<var>type</var>, <var>callback</var>, <var>options</var>)</code></dfn>
方法将运行以下步骤：

<ol>
 <li><p>设<var>capture</var>为<a>flattening</a> <var>options</var>的返回结果。

 <li><p>如果<a>this</a>的
 如果<a>this</a>的<a for=EventTarget>event listener list</a>属性值<a for=list lt="contains">包含</a>一个
 <a for="event listener">type</a>属性为给定的<var>type</var>参数、
 <a for="event listener">callback</a>属性为给定的<var>callback</var>参数以及
 <a for="event listener">capture</a>属性为给定的<var>capture</var>参数的<a lt="event listener">事件监听器</a>，
 则使用<a>this</a>以及<a>event listener</a><a lt="remove an event listener">删除事件监听器</a>。
</ol>

<p class=note><a for=EventTarget>event listener list</a>不会包含多个具有相同<var>type</var>、<var>callback</var>
以及<var>capture</var>的事件监听器，因为<a lt="add an event listener">添加事件侦听器</a>会阻止这种情况。

<p><dfn method for=EventTarget><code>dispatchEvent(<var>event</var>)</code></dfn>方法将会运行以下步骤：

<ol>
 <li><p>如果<var>event</var>的<a>dispatch flag</a>被设置，或者它的<a>initialized flag</a>没有被设置，
 则<a lt="throw">抛出</a>一个"{{InvalidStateError!!exception}}(无效状态错误)"的{{DOMException}}(DOM异常)。

 <li><p>初始化<var>event</var>的{{Event/isTrusted}}属性为false。

 <li><p>将<a lt="dispatching">调度</a><var>event</var>的结果返回给<a>this</a>.
</ol>


<h3 id=observing-event-listeners>观察事件监听器</h3>

<p>通常，开发人员不希望<a lt="event listener">事件侦听器</a>的存在或不存在是可被观察到的。
<a lt="event listener">事件侦听器</a>的效果由其<a for="event listener" lt="callback">回调函数</a>决定。
也就是说，开发人员添加不执行任何操作的<a lt="event listener">事件侦听器</a>时不希望有任何副作用。

<p>不幸的是，一些事件API被设计为需要观察<a lt="event listener">事件侦听器</a>才能有效实现。
也就是说，即使是什么都不做的侦听器也会显着影响应用程序行为的处理能力，从而使其可以观察到是否有侦听器。
例如，使用触摸/滚轮事件可以阻止异步滚动。在某些情况下，可以通过指定事件仅在至少有一个non-{{AddEventListenerOptions/passive}}(passive为false)
侦听器时才可取消来缓解此问题。例如，non-{{AddEventListenerOptions/passive}}的{{TouchEvent}}侦听器必须阻止滚动，
但如果所有侦听器都是{{AddEventListenerOptions/passive}}的，则可以通过使{{TouchEvent}}不可取消(以便忽略对
{{Event/preventDefault()}}的调用)来允许滚动并行开始。因此，调度事件的代码能够观察到是否存在non-{{AddEventListenerOptions/passive}}
侦听器，并使用它来清除正在调度的事件的{{Event/cancelable}}属性。

<p>理想情况下，任何新的事件 API 都被定义为不需要此属性。(在<a href="https://github.com/whatwg/dom/issues">whatwg/dom</a>进行讨论)


<h3 id=dispatching-events>分派事件</h3>

<p><dfn export id=concept-event-dispatch lt="dispatch">分派</dfn>事件到<var>target</var>，
给定可选参数<var>legacy target override flag</var>与<var>legacyOutputDidListenersThrowFlag</var>，
将运行以下步骤：

<ol>
 <li><p>设<var>event</var>的<a>dispatch flag</a>。

 <li>
  <p>如果没给定<var>legacy target override flag</var>参数，则设<var>targetOverride</var>为原来的事件目标，也就是<var>target</var>，
  否则<var>targetOverride</var>的值就是<var>target</var>元素所属的文档(即<var>target</var>的<a>associated Document</a>)。
  [[!HTML]]

  <p class=note><var>legacy target override flag</var>指示事件目标是否应该被覆盖。它仅当<var>target</var>是一个{{Window}}对象时由HTML使用。
  也就是说，如果 target 不是一个 Window 对象，则无论遗留目标覆盖标志是 true 还是 false，事件目标都不会被覆盖。这个限制是为了防止黑客攻击。
  例如，如果一个黑客能够使用遗留目标覆盖标志来改变事件目标，那么他可能会尝试将事件目标设置为某个假的文档，从而在用户点击了该文档时执行恶意脚本。

 <li><p>设<var>activationTarget</var>为null。

 <li><p>设<var>relatedTarget</var>为<var>event</var>的<a for=Event>relatedTarget</a><a lt="retargeting">重定向</a>到<var>target</var>的结果。

 <li>
  <p>如果<var>target</var>不是<var>relatedTarget</var>或者<var>target</var>是<var>event</var>的
  <a for=Event>relatedTarget</a>，则：

  <ol>
   <li><p>设<var>touchTargets</var>为新的<a for=/>list</a>。

   <li><p><a for=list lt="For each">遍历</a><var>event</var>的<a for=Event>touch target list</a>属性中的<var>touchTarget</var>，
   将<var>touchTarget</var><a lt="retargeting">重定向</a>到<var>target</var>的结果<a for=list lt="append">添加</a>到<var>touchTargets</var>。

   <li><p>给定<var>event</var>、<var>target</var>、<var>targetOverride</var>、<var>relatedTarget</var>、<var>touchTargets</var>和false参数，
   执行<a lt="Append to an event path">添加事件路径</a>步骤。

   <li><p>如果<var>event</var>是{{MouseEvent}}对象且<var>event</var>的{{Event/type}}属性为"<code>click</code>"，则设<var>isActivationEvent</var>为true，
   否则设为false。

   <li><p>如果<var>isActivationEvent</var>为true且<var>target</var>存在<a for=EventTarget lt="activation behavior">激活行为</a>，
   则设<var>activationTarget</var>为<var>target</var>。

   <li><p>如果<var>target</var>是<a for=slottable lt="assigned">已分配</a>的<a>slottable</a>，则设<var>slottable</var>为<var>target</var>，否则为null。

   <li><p>设<var>slot-in-closed-tree</var>为false。

   <li><p>给定参数<var>event</var>调用<var>target</var>的<a>get the parent</a>算法，设<var>parent</var>为其返回结果。

   <li>
    <p>当<var>parent</var>不为null：</p>

    <ol>
     <li>
      <p>如果<var>slottable</var>不为null。

      <ol>
       <li><p>确定：<var>parent</var>是一个<a for=/>slot</a>。

       <li><p>设<var>slottable</var>为null。

       <li><p>如果var>parent</var>的<a for=tree>root</a>是一个<a for=ShadowRoot>mode</a>属性为"<code>closed</code>"的<a for=/>shadow root</a>，
       则设<var>slot-in-closed-tree</var>为true。
      </ol>

     <li><p>如果<var>parent</var>是一个 <a for=slottable lt="assigned">已分配</a>的<a>slottable</a>，则设<var>slottable</var>为<var>parent</var>。

     <li><p>设<var>relatedTarget</var>为<var>event</var>的<var>relatedTarget</var><a lt="retargeting">重定向</a>到<var>parent</var>的结果。

     <li><p>设<var>touchTargets</var>为新的<a for=/>list</a>。

     <li><p><a for=list lt="For each">遍历</a><var>event</var>的<a for=Event>touch target list</a>属性中的<var>touchTarget</var>，
     将<var>touchTarget</var><a lt="retargeting">重定向</a>到<var>parent</var>的结果添加到<var>touchTargets</var>。

     <li>
      <p>如果<var>parent</var>是一个{{Window}}对象，或者<var>parent</var>是一个<a for=/>node</a>并且<var>target</var>的<a for=tree>root</a>
      是<var>parent</var>的<a lt="shadow-including inclusive ancestor">shadow-including包容性祖先</a>，则：

      <ol>
       <li><p>如果<var>isActivationEvent</var>为true，<var>event</var>的{{Event/bubbles}}属性为true，
       var>activationTarget</var>为unll以及<var>parent</var>存在<a for=EventTarget lt="activation behavior">激活行为</a>，
       则设<var>activationTarget</var>为<var>parent</var>。

       <li><p>给定<var>event</var>、<var>parent</var>、null、<var>relatedTarget</var>、<var>touchTargets</var>和<var>slot-in-closed-tree</var>参数，
       执行<a lt="Append to an event path">添加事件路径</a>步骤。
      </ol>

     <li><p>否则，如果<var>parent</var>是<var>relatedTarget</var>，则设<var>parent</var>为null。

     <li>
      <p>否则，设<var>target</var>为<var>parent</var>并且：

      <ol>
       <li><p>如果<var>isActivationEvent</var>为true，<var>activationTarget</var>为null以及<var>target</var>
       存在<a for=EventTarget lt="activation behavior">激活行为</a>，则设<var>activationTarget</var>为<var>target</var>。

       <li><p>给定<var>event</var>、<var>parent</var>、<var>target</var>、<var>relatedTarget</var>、<var>touchTargets</var>
       和<var>slot-in-closed-tree</var>参数，执行<a lt="Append to an event path">添加事件路径</a>步骤。
      </ol>

     <li><p>如果<var>parent</var>不为null，给定参数<var>event</var>调用<var>parent</var>的<a>get the parent</a>算法，
     设<var>parent</var>为其结果。

     <li><p>设<var>slot-in-closed-tree</var>为false。
    </ol>

   <li><p>让<var>clearTargetsStruct</var>成为<var>event</var>的<a for=Event>path</a>中<a for=Event/path>shadow-adjusted target</a>
   不为null的最后一个结构。

   <li><p>如果<var>clearTargetsStruct</var>的<a for=Event/path>shadow-adjusted target</a>、<var>clearTargetsStruct</var>
   的<a for=Event/path>relatedTarget</a>或<var>clearTargetsStruct</var>的<a for=Event/path>touch target list</a>
   中的{{EventTarget}}对象是一个<a for=/>node</a>且它的<a for=tree>root</a>是<a for=/>shadow root</a>，
   则设<var>clearTargets</var>为true，否则为false。

   <li><p>如果<var>activationTarget</var>不为null且<var>activationTarget</var>存在
   <a for=EventTarget lt="legacy-pre-activation behavior">遗留预激活行为</a>，则执行
   <var>activationTarget</var>的<a for=EventTarget lt="legacy-pre-activation behavior">遗留预激活行为</a>。

   <li>
    <p>以倒序<a for=list lt="For each">遍历</a><var>event</var>的<a for=Event>path</a>结构：

    <ol>
     <li><p>如果结构的<a for=Event/path>shadow-adjusted target</a>不为null，则设<var>event</var>
     的{{Event/eventPhase}}属性为{{Event/AT_TARGET}}。

     <li><p>否则，则设<var>event</var>的{{Event/eventPhase}}属性为{{Event/CAPTURING_PHASE}}。

     <li><p>给定参数<var>struct</var>、<var>event</var>、"<code>capturing</code>"以及
     <var>legacyOutputDidListenersThrowFlag</var><a lt="Invoke">调用事件监听器</a>。
    </ol>

   <li>
    <p><a for=list lt="For each">遍历</a><var>struct</var>的<a for=Event>path</a>结构：

    <ol>
     <li><p>如果结构的<a for=Event/path>shadow-adjusted target</a>不为null，
     则设<var>event</var>的{{Event/eventPhase}}属性为{{Event/AT_TARGET}}。

     <li>
      <p>否则：

      <ol>
       <li><p>如果<var>event</var>的{{Event/bubbles}}属性值为false，则<a for=iteration>continue</a>。

       <li><p>设<var>event</var>的{{Event/eventPhase}}属性值为{{Event/BUBBLING_PHASE}}。
      </ol>

     <li><p>给定参数<var>struct</var>、<var>event</var>、"<code>bubbling</code>"以及
     <var>legacyOutputDidListenersThrowFlag</var><a lt="Invoke">调用事件监听器</a>。
    </ol>
  </ol>

 <li><p>设<var>event</var>的{{Event/eventPhase}}属性值为{{Event/NONE}}。

 <li><p>设<var>event</var>的{{Event/currentTarget}}属性值为null。

 <li><p>设置<var>event</var>的<a for=Event>path</a>属性值为空list。

 <li><p>取消设置<var>event</var>的<a>dispatch flag</a>，<a>stop propagation flag</a>以及<a>stop immediate propagation flag</a>。

 <li> 
  <p>如果<var>clearTargets</var>为true，则：

  <ol>
   <li><p>设<var>event</var>的<a for=Event>target</a>为null。

   <li><p>设<var>event</var>的<a for=Event>relatedTarget</a>为null。

   <li><p>设<var>event</var>的<a for=Event>touch target list</a>为空list。
  </ol>

 <li>
  <p>如果<var>activationTarget</var>不为空，则：

  <ol>
   <li><p>如果<var>event</var>的<a>canceled flag</a>没被设置，则给定<var>event</var>参数运行
   <var>activationTarget</var>的<a for=EventTarget lt="activation behavior">激活行为</a>。

   <li><p>否则，如果<var>activationTarget</var>存在<a for=EventTarget lt="legacy-canceled-activation behavior">遗留取消激活行为</a>，
   则运行<var>activationTarget</var>的<a for=EventTarget lt="legacy-canceled-activation behavior">遗留取消激活行为</a>。
  </ol>

 <li><p>如果<var>event</var>的<a>canceled flag</a>被设置则返回false，否则返回true。
</ol>

<p>给定参数<var>event</var>、<var>invocationTarget</var>、<var>shadowAdjustedTarget</var>、<var>relatedTarget</var>、
<var>touchTargets</var>以及<var>slot-in-closed-tree</var>，<dfn noexport id=concept-event-path-append lt="append to an event path">添加到事件的path</dfn>，
将运行以下步骤：

<ol>
 <li><p>设<var>invocationTargetInShadowTree</var>为false。

 <li><p>如果<var>invocationTarget</var>是<a for=/>node</a>对象且它的<a for=tree>root</a>是<a for=/>shadow root</a>，
 则设<var>invocationTargetInShadowTree</var>为true。

 <li><p>设<var>root-of-closed-tree</var>为false。

 <li><p><var>invocationTarget</var>是属性<a for=ShadowRoot>mode</a>为"<code>closed</code>"的<a for=/>shadow root</a>，
 则设<var>root-of-closed-tree</var>为true。

 <li><p>构造新的结构，将
 <var>invocationTarget</var>赋值给<a for=Event/path>invocation target</a>、
 <var>invocationTargetInShadowTree</var>赋值给<a for=Event/path>invocation-target-in-shadow-tree</a>、
 <var>shadowAdjustedTarget</var>赋值给<a for=Event/path>shadow-adjusted target</a>、
 <var>relatedTarget</var>赋值给<a for=Event/path>relatedTarget</a>、
 <var>touchTargets</var>赋值给<a for=Event/path>touch target list</a>、
 <var>root-of-closed-tree</var>赋值给<a for=Event/path>root-of-closed-tree</a>、
 <var>slot-in-closed-tree</var>赋值给<a for=Event/path>slot-in-closed-tree</a>，
 并将其<a for=list lt="Append">添加</a>到<var>event</var>的<a for=Event>path</a>属性中。
</ol>

<p>给定参数<var>struct</var>、<var>event</var>、<var>phase</var>以及可选定参数<var>legacyOutputDidListenersThrowFlag</var>，
<dfn noexport id=concept-event-listener-invoke lt="invoke">调用事件监听器</dfn>事件监听器，将运行以下步骤：

<ol>
 <li><p>设<var>event</var>的<a for=Event>target</a>为<var>event</var>的<a for=Event>path</a>属性值中最后一个
 <a for=Event/path>shadow-adjusted target</a>值为非空的结构中的<a for=Event/path>shadow-adjusted target</a>。

 <li><p>设<var>event</var>的 <a for=Event>relatedTarget</a>为<var>struct</var>的<a for=Event/path>relatedTarget</a>属性值。

 <li><p>设<var>event</var>的<a for=Event>touch target list</a>为<var>struct</var>的<a for=Event/path>touch target list</a>
 属性值。

 <li><p>如果<var>event</var>的<a>stop propagation flag</a>被设置，则直接return。

 <li><p>初始化<var>event</var>的{{Event/currentTarget}}属性值为<var>struct</var>的<a for=Event/path>invocation target</a>
 属性值。

 <li>
  <p>设<var>listeners</var>为<var>event</var>的{{Event/currentTarget}}属性值中的<a for=EventTarget>event listener list</a>
  的<a for=list lt="clone">克隆</a>。

  <p class=note>这避免了在此之后添加的<a>event listeners</a>被运行。请注意，由于<a for="event listener" lt="removed">删除</a>
  了字段，删除仍然有效。

 <li><p>设<var>invocationTargetInShadowTree</var>为<var>struct</var>的
 <a for=Event/path>invocation-target-in-shadow-tree</a>。

 <li><p>给定<var>event</var>、<var>listeners</var>、<var>phase</var>、<var>invocationTargetInShadowTree</var>以及可选的
 <var>legacyOutputDidListenersThrowFlag</var>参数运行<a lt="inner invoke">内部调用事件监听器</a>步骤。设found为其返回结果。

 <li>
  <p>如果<var>found</var>为false且<var>event</var>的{{Event/isTrusted}}属性值为true，则：

  <ol>
   <li><p>设<var>originalEventType</var>为<var>event</var>的{{Event/type}}属性值。

   <li>
    <p>如果<var>event</var>的{{Event/type}}属性值与下表中第一列中的任何字符串匹配，则将<var>event</var>的{{Event/type}}
    属性值设置为与匹配字符串在同一行的第二列中的字符串，否则return。

    <table>
     <thead>
      <tr><th>事件类型<th>遗留事件类型
     <tbody>
      <tr><td>"<code>animationend</code>"<td>"<code>webkitAnimationEnd</code>"
      <tr><td>"<code>animationiteration</code>"<td>"<code>webkitAnimationIteration</code>"
      <tr><td>"<code>animationstart</code>"<td>"<code>webkitAnimationStart</code>"
      <tr><td>"<code>transitionend</code>"<td>"<code>webkitTransitionEnd</code>"
    </table>

   <li><p>给定<var>event</var>、<var>listeners</var>、<var>phase</var>、<var>invocationTargetInShadowTree</var>
   以及可选的<var>legacyOutputDidListenersThrowFlag</var>参数运行<a lt="inner invoke">内部调用事件监听器</a>步骤。

   <li><p>设<var>event</var>的{{Event/type}}属性为<var>originalEventType</var>。
  </ol>
</ol>

<p>给定<var>event</var>、<var>listeners</var>、 <var>phase</var>、<var>invocationTargetInShadowTree</var>
以及可选的<var>legacyOutputDidListenersThrowFlag</var>参数，
<dfn noexport id=concept-event-listener-inner-invoke lt="inner invoke">内部调用事件监听器</dfn>，将运行以下步骤：

<ol>
 <li><p>设<var>found</var>为false。

 <li>
  <p><a for=list lt="For each">遍历</a><var>listeners</var>中的<a for="event listener">removed</a>属性为false的
  <var>listener</var>：

  <ol>
   <li><p>如果<var>event</var>的{{Event/type}}属性值不等于<var>listener</var>的<a for="event listener">type</a>属性值，
   则<a for=iteration>continue</a>。

   <li><p>设<var>found</var>为true。

   <li><p>如<var>phase</var>属性为"<code>capturing</code>"且<var>listener</var>stener的<a for="event listener">capture</a>
   为false，则<a for=iteration>continue</a>。

   <li><p>如<var>phase</var>属性为"<code>bubbling</code>"且<var>listener</var>的<a for="event listener">capture</a>为true
   ，则<a for=iteration>continue</a>。

   <li><p>如果<var>listener</var>的<a for="event listener">once</a>为true，则在<var>event</var>的{{Event/currentTarget}}
   属性值中的<a for=EventTarget>event listener list</a>，<a for=list lt="remove">删除</a>该<var>listener</var>。
   <!-- Do this before invocation to avoid reentrancy issues. No need to set removed to true since
        each listener in listeners is run once anyway. -->

   <li><p>设<var>global</var>为<var>listener</var>中的<a for="event listener">callback</a>的<a>associated realm</a>
   中的<a for=realm lt="global object">global对象</a>。

   <li><p>设<var>currentEvent</var>为undefined。

   <li>
    <p>如果<var>global</var>为{{Window}}对象，则：

    <ol>
     <li><p>设<var>currentEvent</var>为<var>global</var>的<a for=Window>current event</a>。

     <li><p>如果<var>invocationTargetInShadowTree</var>为false，则设<var>global</var>的
     <a for=Window>current event</a>为<var>event</var>。
    </ol>

   <li><p>如果<var>listener</var>的<a for="event listener">passive</a>为true，则设置
   <var>event</var>的<a>in passive listener flag</a>。

   <li>
    <p>给定参数<var>listener</var>的<a for="event listener">callback</a>、"<code>handleEvent</code>"、« <var>event</var> »
    以及<var>event</var>的{{Event/currentTarget}}属性值，<a lt="Call a user object's operation">调用用户对象的操作</a>。
    如果抛出异常，则：

    <ol>
     <li><p><a lt="Report the exception">报告异常</a>。

     <li>
      <p>如果给定，则设置<var>legacyOutputDidListenersThrowFlag</var>。

      <p class=note><var>legacyOutputDidListenersThrowFlag</var>仅由Database API使用。 [[INDEXEDDB]]
    </ol>

   <li><p>取消设置<var>event</var>的<a>in passive listener flag</a>。

   <li><p>如果<var>global</var>是{{Window}}对象，则设<var>global</var>的<a for=Window>current event</a>为
   <var>currentEvent</var>。

   <li><p>如果<var>event</var>的<a>stop immediate propagation flag</a>被设置，则return
   <var>found</var>。
  </ol>

 <li><p>return <var>found</var>。
</ol>


<h3 id=firing-events>触发事件</h3>

<p><dfn export id=concept-event-fire lt="fire an event">触发</dfn><var>target</var>中名为<var>e</var>的事件，
可以选择使用<var>eventConstructor</var>，并说明如何初始化IDL属性，以及<var>legacy target override flag</var>，
请运行以下步骤：

<ol>
 <li><p>如果<var>eventConstructor</var>没有给出，则设<var>eventConstructor</var>为
 {{Event}}。

 <li><p>使用<var>eventConstructor</var>在<var>target</var>的<a>relevant realm</a>中
 <a lt="creating an event">创建一个事件</a>，设<var>event</var>为其返回结果。

 <li><p>初始化<var>event</var>的{{Event/type}}属性值为<var>e</var>。

 <li>
  <p>初始化<var>event</var>的其他IDL属性，作为调用该算法的说明。

  <p class=note>这还允许将{{Event/isTrusted}}属性设置为false。

 <li><p>如果设置了<var>legacy target override flag</var>，则return<a lt="dispatching">分派</a><var>event</var>
 到<var>target</var>的结果。
</ol>

<p class=note>在DOM上下文中，Fire是<a lt="create an event" lt="creating">创建</a>、初始化和<a lt="dispatching">分派</a>
事件的缩写。<a>Fire an event</a>意思是创建、初始化和调度事件的过程，这个短语使得这个过程更容易编写，可以使我们在编写代码时
不必手动执行这些步骤。

<div class=example id=firing-events-example>
 <p>如果<a>event</a>需要初始化{{Event/bubbles}}或{{Event/cancelable}}这些属性，一种方法是写成"在<var>target</var>
 <a lt="fire an event">触发</a>一个名为<code>submit</code>的事件，其{{Event/cancelable}}属性初始化为true"。

 <p>或者，当需要自定义构造函数时，"使用{{MouseEvent}}将其{{UIEvent/detail}}属性初始化为1，在<var>target</var>
 <a lt="fire an event">触发</a>一个名为<code>click</code>的事件"。

 <p>有时候返回值也是非常重要的：

 <ol>
  <li><p>设<var>doAction</var>为<a lt="fire an event">触发</a> <var>target</var>的<code>like</code>事件的返回结果。

  <li><p>如果<var>doAction</var>为true，则&hellip;
 </ol>
</div>


<h3 id="action-versus-occurrence" oldids="action-versus-occurance">行为与发生</h3>

<p><a>event</a>表示发生，而不是动作。换句话说，它表示来自算法的通知，可用于影响该算法的未来进程(例如，
通过调用{{Event/preventDefault()}})。<a>Events</a>不得用作导致某些算法开始运行的动作或发起者。这不是他们的目的。

<p class=note>之所以在这里特别提到这一点，是因为DOM的先前迭代有一个与事件相关的"默认操作"概念，
这些<a>events</a>给人们带来了所有错误的想法。<a>Events</a>不代表导致行动，它们只能用来影响正在进行的行动。


<h2 id=aborting-ongoing-activities>中止正在进行的活动</h3>

<p>虽然promises没有内置的中止机制，但许多使用它们的APIs都需要中止的机制。 {{AbortController}}提供了支持这些需求的{{AbortController/abort()}}方法，
该方法通过切换相应的{{AbortSignal}}对象的状态，来中止正在进行的活动。这些期望中止机制的API需要传入一个{{AbortSignal}}对象，
并且根据它的状态来决定程序的进程。

<p>当{{AbortController/abort()}}方法被执行 ，鼓励依赖于{{AbortController}}的API以{{AbortSignal}}的[=AbortSignal/abort reason=](中止原因)
rejecting未完成的promise。

<div class=example id=aborting-ongoing-activities-example>
 <p>一个假设的<code>doAmazingness({ ... })</code>方法，它接受一个AbortSignal对象以此来支持中止正进行的活动，例子如下：

 <pre><code class=lang-javascript>
const controller = new AbortController();
const signal = controller.signal;

startSpinner();

doAmazingness({ ..., signal })
  .then(result => ...)
  .catch(err => {
    if (err.name == 'AbortError') return;
    showUserErrorMessage();
  })
  .then(() => stopSpinner());

// &hellip;

controller.abort();</code></pre>

 <p><code>doAmazingness</code>方法实现如下：

 <pre><code class=lang-javascript>
function doAmazingness({signal}) {
  return new Promise((resolve, reject) => {
    // 如果signal已经被中止，则直接抛出中止的reason。
    signal.throwIfAborted();

    // 开始做一些事情，完成后调用 resolve(result)
    // 而且，注意监听中止信号：
    signal.addEventListener('abort', () => {
      // 停止正在做的事件，并且：
      reject(signal.reason);
    });
  });
}
</code></pre>
</div>

<p>没有返回值的API可以以上述例子的方式做出相同反应，或者你可以选择不显示{{AbortSignal}}的[=AbortSignal/abort reason=](中止原因)。
上述例子最后的{{EventTarget/addEventListener()}}方法是有意义的，一旦{{AbortController/abort()}}方法触发，则会中止正在进行的活动，
抛出[=AbortSignal/abort reason=](中止原因)。

<p>需要更精细控制的API可以根据它们的需求扩展{{AbortController}}和{{AbortSignal}}对象。


<h3 id=interface-abortcontroller>{{AbortController}}接口</h3>

<pre class=idl>
[Exposed=*]
interface AbortController {
  constructor();

  [SameObject] readonly attribute AbortSignal signal;

  undefined abort(optional any reason);
};
</pre>

<dl class=domintro>
 <dt><code><var>controller</var> = new <a constructor lt=AbortController()>AbortController</a>()</code>
 <dd>返回一个新的控制器，其{{AbortController/signal}}属性被设置为新创建的{{AbortSignal}}对象。

 <dt><code><var>controller</var> . <a attribute for=AbortController>signal</a></code>
 <dd>返回与此对象关联的{{AbortSignal}}对象。

 <dt><code><var>controller</var> . <a method for=AbortController lt=abort()>abort</a>(<var>reason</var>)</code>
 <dd>调用该方法将会保存其中止原因到该对象的{{AbortController/signal}}属性的[=AbortSignal/abort reason=](中止原因)中，
 并向观察者发出信号，表明相关的活动将被中止。如果<var>reason</var>值为undefined，则抛出"{{AbortError!!exception}}(中止错误)"的{{DOMException}}(DOM异常)。
</dl>

<p>{{AbortController}}对象有一个相关的<dfn for=AbortController>signal</dfn>(一个{{AbortSignal}}对象)属性。

<p><dfn constructor for=AbortController lt="AbortController()"><code>new AbortController()</code></dfn>
构造函数将运行以下步骤：

<ol>
 <li><p>设<var>signal</var>为一个新的{{AbortSignal}}对象。

 <li><p>设<a>this</a>的<a for=AbortController>signal</a>属性值为<var>signal</var>。
</ol>

<p><dfn attribute for=AbortController><code>signal</code></dfn>的getter方法将返回this的<a for=AbortController>signal</a>属性值。

<p><dfn method for=AbortController><code>abort(<var>reason</var>)</code></dfn>方法将在其<a>this</a>的
<a for=AbortController>signal</a>上(如果给出reason则携带)<a for=AbortSignal lt="signal abort">发送中止信号</a>。

<h3 id=interface-AbortSignal>{{AbortSignal}}接口</h3>

<pre class=idl>
[Exposed=*]
interface AbortSignal : EventTarget {
  [NewObject] static AbortSignal abort(optional any reason);
  [Exposed=(Window,Worker), NewObject] static AbortSignal timeout([EnforceRange] unsigned long long milliseconds);

  readonly attribute boolean aborted;
  readonly attribute any reason;
  undefined throwIfAborted();

  attribute EventHandler onabort;
};</pre>

<dl class=domintro>
 <dt><code>AbortSignal . <a method for=AbortSignal>abort</a>(<var>reason</var>)</code>
 <dd>如果<var>reason</var>不为undefined则返回一个{{AbortSignal}}实例，且设其
 <a for=AbortSignal lt="abort reason">abort reason(中止原因)</a>为<var>reason</var>；
 如果<var>reason</var>为undefined则抛出一个"{{AbortError!!exception}}(中止错误)"的{{DOMException}}(DOM异常)。

 <dt><code>AbortSignal . <a method for=AbortSignal lt=timeout(milliseconds)>timeout</a>(<var>milliseconds</var>)</code>
 <dd>返回一个将在milliseconds毫秒后被中止{{AbortSignal}}实例。其<a for=AbortSignal lt="abort reason">abort reason(中止原因)</a>将被设置为
 "{{TimeoutError!!exception}}(超时错误)"的{{DOMException}}(DOM异常)。

 <dt><code><var>signal</var> . <a attribute for=AbortSignal>aborted</a></code>
 <dd>如果<var>signal</var>的{{AbortController}}已经发出中止信号则返回true；否则返回false。

 <dt><code><var>signal</var> . <a attribute for=AbortSignal>reason</a></code>
 <dd>返回<var>signal</var>的<a for=AbortSignal lt="abort reason">abort reason(中止原因)</a>。

 <dt><code><var>signal</var> . <a method for=AbortSignal lt=throwIfAborted()>throwIfAborted</a>()</code>
 <dd>如果<var>signal</var>的{{AbortController}}已经发出中止信号则抛出<var>signal</var>的<a for=AbortSignal lt="abort reason">abort reason(中止原因)</a>;
  否则，则什么都不做。
</dl>

<p>{{AbortSignal}}对象有一个{{AbortSignal/reason}}属性，它存放着关联的<dfn export for=AbortSignal lt="abort reason">abort reason(中止原因)</dfn>，
它是一个JavaScript值，除非另有说明，否则其值为undefined。

<p>当{{AbortSignal}}的[=AbortSignal/abort reason=]不为undefined，则证明它<dfn export for="AbortSignal" lt="aborted">已被中止</dfn>。

<p>{{AbortSignal}}对象具有一些相关的<dfn for=AbortSignal lt="abort algorithms">中止算法</dfn>，这是一<a for=/ lt="set">组</a>在中止时要执行的算法。
除非另有说明，否则其值为空集。

<p><dfn export for=AbortSignal lt="add">添加</dfn>一个算法(<var>algorithm</var>)到{{AbortSignal}}对象的<var>signal</var>，将要运行以下步骤：

<ol>
 <li><p>如果<var>signal</var>已被中止，则直接return。

 <li><p><a for=set lt="Append">添加</a><var>algorithm</var>到<var>signal</var>的
 <a for=AbortSignal>abort algorithms</a>中。
</ol>

<p><dfn export for=AbortSignal lt="remove">删除</dfn>{{AbortSignal}}对象中<var>signal</var>的一个算法(<var>algorithm</var>)，
则从<var>signal</var>的<a for=AbortSignal>abort algorithms</a>中<a for=set lt="remove">删除</a>该<var>algorithm</var>。

<p class=note>中止算法使具有复杂要求的API能够以合理的方式对{{AbortController/abort()}}做出反应。例如，给定API的[=AbortSignal/abort reason=](中止原因)
可能需要传播到跨线程环境，例如 service worker。

<p>静态方法<dfn method for=AbortSignal><code>abort(<var>reason</var>)</code></dfn>运行步骤：

<ol>
 <li><p>设<var>signal</var>为新的{{AbortSignal}}对象。

 <li><p>如果给出参数<var>reason</var>，则设<var>signal</var>的[=AbortSignal/abort reason=]为<var>reason</var>;
 否则抛出 "{{AbortError!!exception}}(中止错误)"的{{DOMException}}(DOM异常)。

 <li>返回<var>signal</var>。
</ol>

<p>静态方法<dfn method for=AbortSignal><code>timeout(<var>milliseconds</var>)</code></dfn>运行步骤：

<ol>
 <li><p>设<var>signal</var>为新的{{AbortSignal}}对象。

 <li><p>设<var>global</var>为<var>signal</var>的<a lt="relevant global object">相关的全局对象</a>。

 <li>
  <p>给定参数<var>global</var>、"<code>AbortSignal-timeout</code>"、
  <var>milliseconds</var><a lt="Run steps after a timeout">超时后将运行以下步骤</a>：</p>

  <ol>
   <li><p>给定参数<var>global</var>，在<a lt="timer task source">计时器任务源</a>上<a lt="Queue a global task">排队一个全局任务</a>
   以终止给定的参数<var>signal</var>的信号，并产生一个新的"{{TimeoutError!!exception}}(超时错误)"的{{DOMException}}(DOM异常)。
  </ol>

  <p>在此超时期间，如果<var>signal</var>有任何为其{{AbortSignal/abort}}事件注册的事件侦听器，则必须存在从<var>global</var>到<var>signal</var>的强引用。

 <li><p>Return <var>signal</var>。
</ol>

<p>如果<a>this</a>已被中止<dfn attribute for=AbortSignal>aborted</dfn>的getter方法返回true；否则返回false。

<p><dfn attribute for=AbortSignal>reason</dfn>的getter方法返回<a>this</a>的<a for=AbortSignal lt="abort reason">中止原因</a>。

<p>如果<a>this</a>被中止，<dfn method for=AbortSignal>throwIfAborted()</dfn>方法将抛出<a>this</a>的<a for=AbortSignal lt="abort reason">中止原因</a>。

<div class=example id=example-throwifaborted>
 <p>当接受{{AbortSignal}}的函数想要在特定检查点抛出(或返回被拒绝的承诺)而不是将{{AbortSignal}}传递给其他方法时，此方法尤其有用。
 例如，下列函数允许在每次尝试轮询条件之间中止。这提供了中止轮询过程的机会，即使实际的异步操作(即 await func())不接受{{AbortSignal}}。

 <pre class=lang-javascript>
 async function waitForCondition(func, targetValue, { signal } = {}) {
   while (true) {
     signal?.throwIfAborted();

     const result = await func();
     if (result === targetValue) {
       return;
     }
   }
 }
 </pre>
</div>

<p><dfn attribute for=AbortSignal><code>onabort</code></dfn>属性是一个<a lt="event handler">事件处理程序</a>的
<a lt="event handler IDL attribute">event handler IDL属性</a>， <a lt="event handler event type">事件处理程序事件类型</a>
为<dfn event for=AbortSignal><code>abort</code></dfn>。

<p class=note>对{{AbortSignal}}对象的更改代表相应{{AbortController}}对象的意愿，但观察{{AbortSignal}}对象的API可以选择忽略它们。
例如，如果操作已经完成。


<p>要<dfn export for=AbortSignal lt="signal abort">发出中止信号</dfn>，给定{{AbortSignal}}类型的<var>signal</var>参数以及可选的<var>reason</var>参数
，请运行以下步骤：

<ol>
 <li><p>如果<var>signal</var>以及被中止，则直接return。

 <li>如果给出了<var>reason</var>参数，则<p>设<var>signal</var>的[=AbortSignal/abort reason=]为<var>reason</var>；
 否则抛出 "{{AbortError!!exception}}(中止错误)"的{{DOMException}}(DOM异常)。

 <li><p><a for=set lt="For each">遍历</a><var>signal</var>的[=AbortSignal/abort algorithms=]中的算法，并运行这些算法。

 <li><p><a for=set lt="Empty">清空</a> <var>signal</var>的<a for=AbortSignal>abort algorithms</a>。

 <li><p><a lt="Fire an event">触发</a><var>signal</var>中名为{{AbortSignal/abort}}的事件。
</ol>

<p>通过运行以下步骤，可以使<var>followingSignal</var>(一个{{AbortSignal}}对象)<dfn export for=AbortSignal lt="follow">跟随</dfn>
一个<var>parentSignal</var>(一个{{AbortSignal}}对象)：

<ol>
 <li><p>如果<var>followingSignal</var>已经被中止，则直接return。

 <li><p>如果<var>parentSignal</var>已经被中止，则使用<var>parentSignal</var>的[=AbortSignal/abort reason=]
 给<var>followingSignal</var><a for=AbortSignal lt="signal abort">发送中止信号</a>。

 <li>
  <p>否则，向<var>parentSignal</var><a for=AbortSignal lt=add>添加以下中止步骤</a>：

  <ol>
   <li><p>使用<var>parentSignal</var>的[=AbortSignal/abort reason=]给
   <var>followingSignal</var><a for=AbortSignal lt="signal abort">发出中止信号</a>。
  </ol>
</ol>


<h3 id=abortcontroller-api-integration>在API中使用{{AbortController}}和{{AbortSignal}}对象</h3>

<p>任何使用promise代表能够被中止的操作的Web平台API，都必须遵守以下规定：

<ul class=brief>
 <li>通过<code>signal</code>字典成员接受{{AbortSignal}}对象。
 <li>携带{{AbortSignal}}对象的<a lt="abort reason">中止原因</a>，通过promise的rejeting传达该操作已被中止。
 <li>如果{{AbortSignal}}已经被<a lt="aborted">中止</a>则立即reject，否则：
 <li>使用<a lt="abort algorithms">中止算法</a>机制来观察对{{AbortSignal}}对象的更改，并以不会导致与其他观察者发生冲突的方式进行。
</ul>

<div class=example id=aborting-ongoing-activities-spec-example>
 <p>promise-returning方法<code>doAmazingness(<var>options</var>)</code>的方法步骤如下：

 <ol>
  <li><p>设|p|为<a lt="a new promise">一个新的promise</a>。

  <li>
   <p>如果|options|的"<code>signal</code>"成员存在，则：

   <ol>
    <li><p>设|signal|为|options|的"<code>signal</code>"。

    <li><p>如果|signal|<a for="AbortSignal" lt="aborted">已经被中止</a>，则使用|signal|的[=AbortSignal/abort reason=][=reject=] |p|并且return |p|。

    <li>
     <p>向|signal|<a for=AbortSignal lt=add>添加以下中止步骤</a>：

     <ol>
      <li><p>停止正在做的事情

      <li><p>使用|signal|的[=AbortSignal/abort reason=](中止原因)[=Reject=] |p|。
     </ol>
   </ol>

  <li>
   <p><a lt="in parallel">并行</a>运行这些步骤：

   <ol>
    <li><p>设|amazingResult|为做一些惊奇的事的返回结果。

    <li><p>用|amazingResult|解析|p|。
   </ol>

  <li><p>返回 |p|。
 </ol>
</div>

<p>不使用promises的API仍应尽可能遵守上述规定。



<h2 id=nodes>Nodes：节点</h2>

<h3 id=introduction-to-the-dom>DOM简介</h3>

在最初的意义中，"DOM"是一种用于访问和操作文档(特别是HTML和XML文档)的API。在本规范中，术语"文档"用于任何基于标记的资源，
范围从简短的静态文档到长篇文章或具有丰富多媒体的报告，以及成熟的交互式应用程序。

<p>每个这样的文档都表示为一个<a lt="node tree">node tree</a>(节点树)。<a lt="tree">树</a>中的某些节点可以有<a for=tree lt="children">子节点</a>，
除此之外的其他节点始终是叶子节点。

为了说明这一点，请考虑以下 HTML 文档：

<pre class=lang-markup>
&lt;!DOCTYPE html>
&lt;html class=e>
 &lt;head>&lt;title>Aliens?&lt;/title>&lt;/head>
 &lt;body>Why yes.&lt;/body>
&lt;/html>
</pre>

DOM表示如下：

<ul class=domTree>
 <li>
  <a>Document</a>
  <ul>
   <li class=t10><a>Doctype</a>: <code>html</code>
   <li class=t1>{{Element}}: <code>html</code> <span class=t2><code class="attribute name">class</code>="<code class="attribute value">e</code>"</span>
    <ul>
     <li class=t1>
      {{Element}}: <code>head</code>
      <ul>
       <li class=t1>
        {{Element}}: <code>title</code>
        <ul>
         <li class=t3>{{Text}}: <span>Aliens?</span>
        </ul>

      </ul>

     <li class=t3>{{Text}}: <span>⏎␣</span>
     <li class=t1>
      {{Element}}: <code>body</code>
      <ul>
       <li class=t3>{{Text}}: <span>Why yes.⏎</span>
      </ul>

    </ul>

  </ul>

</ul>

<!--
https://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0D%0A%3Chtml%20class%3De%3E%0D%0A%20%3Chead%3E%3Ctitle%3EAliens%3F%3C%2Ftitle%3E%3C%2Fhead%3E%0D%0A%20%3Cbody%3EWhy%20yes.%3C%2Fbody%3E%0D%0A%3C%2Fhtml%3E
-->

<p>请注意，由于<a lt="html parser">HTML解析</a>的魔力，并非所有<a lt="ASCII whitespace">ASCII空格</a>都变成{{Text}}<a for=/ lt="nodes">节点</a>，
但一般概念很清楚。标记进去，<a lt="node tree">节点树</a>出来。
<!-- You /can/ explain that! harharhar -->

<p class=note><a href="https://software.hixie.ch/utilities/js/live-dom-viewer/">Live DOM Viewer</a>可以更详细地探讨这个问题。


<h3 id=node-trees>Node tree：节点树</h3>

<p><dfn export id=concept-node>Nodes</dfn>是<a lt="implement">实现</a>{{Node}}接口的对象。
<a for=/>Nodes</a><a lt="participate">参与</a><a>tree</a>，被称为<dfn export id=concept-node-tree>node tree</dfn>。

<div class=note>
 <p>实际上，您处理的是更具体的对象。

 <p><a lt="implement">实现</a>{{Node}}的对象，也实现了其继承的接口：{{Document}}、{{DocumentType}}、{{DocumentFragment}}、
 {{Element}}、{{CharacterData}}或{{Attr}}。

 <p>实现{{DocumentFragment}}接口的对象，有时也会实现{{ShadowRoot}}接口。

 <p>实现{{Element}}接口的对象，通常也会实现继承的接口，例如{{HTMLAnchorElement}}。

 <p>实现{{CharacterData}}接口的对象，也会实现继承的接口，例如{{Text}}、{{ProcessingInstruction}}或{{Comment}}。

 <p>实现{{Text}}接口的对象，有时也会实现{{CDATASection}}接口。
</div>

<p>为简洁起见，本规范将<a lt="implements">实现</a>{{Node}}和继承接口<code><var>NodeInterface</var></code>
的对象称为<code><var>NodeInterface</var></code><a for=/ lt="node">节点</a>。

<p><a>node tree</a>(节点树)的<a for=/ lt="node">节点</a>与<a for=tree lt="children">子节点</a>将受到如下限制：

<dl>
 <dt>{{Document}}
 <dd>
  <p>按<a lt="tree order">树的顺序</a>:
  <ol>
   <li><p>0或多个{{ProcessingInstruction}}或{{Comment}}<a for=/ lt="nodes">节点</a>。
   <li><p>0个或1个{{DocumentType}}<a for=/ lt="nodes">节点</a>。
   <li><p>0或多个{{ProcessingInstruction}}或{{Comment}}<a for=/ lt="nodes">节点</a>。
   <li><p>0个或1个{{Element}}<a for=/ lt="nodes">节点</a>。
   <li><p>0或多个{{ProcessingInstruction}}或{{Comment}}<a for=/ lt="nodes">节点</a>。
  </ol>

 <dt>{{DocumentFragment}}
 <dt>{{Element}}
 <dd><p>0个或多个{{Element}}或{{CharacterData}}<a for=/ lt="nodes">节点</a>。

 <dt>{{DocumentType}}
 <dt>{{CharacterData}}
 <dt>{{Attr}}
 <dd><p>没有<a for=tree lt="children">子节点</a>。
</dl>

<p class=note>由于历史原因，{{Attr}} <a for=/ lt="nodes">节点</a> <a lt="participate">参与</a>到<a>tree</a>中；
它们从来没有(非空的)<a for=tree lt="parent">父节点</a>或任何<a for=tree lt="children">子节点</a>。

<p>要确定<a for=/>node</a>的<dfn export id=concept-node-length for=Node lt="length">长度</dfn>，将运行以下步骤：

<ol>
 <li><p>如果<var>node</var>是{{DocumentType}}或者{{Attr}} <a for=/ lt="node">节点</a>，则直接返回0。

 <li><p>如果<var>node</var>是{{CharacterData}} <a for=/ lt="node">节点</a>，则返回<var>node</var>的
 <a for=CharacterData>data</a>的<a for=string>length</a>属性。

 <li><p>返回<var>node</var>的<a for=tree lt="children">子节点</a>的数量。
</ol>

<p>如果<a for=/ lt="node">节点</a>的<a lt="length">长度</a>为0，则该<a for=/ lt="node">节点</a>被认为是
<dfn export id=concept-node-empty for=Node lt="empty">空</dfn>的。


<h4 id=document-trees>Document tree：文档树</h4>

<p><dfn export id=concept-document-tree lt="document tree">文档树</dfn>为其<a for=tree lt="root">根节点</a>是<a>document</a>
的<a lt="node tree">节点树</a>。

<p><a>document</a>的<dfn export lt="document element">文档元素</dfn>是其<a for=tree lt="parent">父元素</a>是该<a>document</a>(如果存在)的元素；
否则为空。

<p class=note>根据<a lt="node tree">节点树</a>约束，只能有一个这样的<a for=/>element</a>。

<p>如果<a for=/>element</a>的<a for=tree lt="root">根节点</a>是<a>document</a>，则该元素<dfn export lt="in a document tree">位于文档树</dfn>中。

<p>如果<a for=/>element</a><a lt="in a document tree">在文档树中</a> ，则该元素<dfn export lt="in a document">在document中</dfn>。

<p class=note>不应再使用术语"<a lt="in a document">在document中</a>"。它表明使用它的标准尚未更新以说明<a>shadow trees</a>。</p>


<h4 id=shadow-trees>Shadow tree：影子树</h4>

<p><dfn export id=concept-shadow-tree lt="shadow tree">影子树</dfn>为其<a for=tree lt="root">根节点</a>是<a for=/>shadow root</a>
的<a lt="node tree">节点树</a>。

<p><a for=/>shadow root</a>始终通过其<a for=DocumentFragment>host</a>附加到另一个<a lt="node tree">节点树</a>。
因此，<a>shadow tree</a>永远不会孤单。<a for=/>shadow root</a>宿主的<a>node tree</a>有时也被称为
<dfn export id=concept-light-tree>light tree</dfn>。</p>

<p class=note><a>shadow tree</a>相应的<a>light tree</a>可以是<a>shadow tree</a>本身。</p>

<p id=in-a-shadow-including-document>当一个元素不在ShadowDOM中时，它的<a>shadow-including root</a>则是<a>document</a>本身，这意味着这个元素是连接的；
当一个元素在ShadowDOM中时，它的<a>shadow-including root</a>则是ShadowDOM的<a for=/>shadow root</a>，这意味着这个元素是未连接的。


<h5 id=shadow-tree-slots>Slots：插槽</h5>

<p><a>shadow tree</a>包含了0个或多个<dfn export id=concept-slot lt=slot>插槽</dfn><a for=/ lt="elements">元素</a>。</p>

<p class=note><a lt="slot">插槽</a>仅可通过HTML的<{slot}>元素创建。</p>

<p><a lt="slot">插槽</a>具有关联的<dfn export for=slot lt="name">名称</dfn>(string)。除非另有说明，否则它是空字符串。

<p>使用这些<a lt="attribute change steps">属性更改步骤</a>来更新<a lt="slot">插槽</a>的<a for=slot>name</a>属性：

<ol>
 <li>
  <p>如果<var>element</var>是一个<a lt="slot">插槽</a>，<var>localName</var>是<code>name</code>，且
  <var>namespace</var>为null，则：

  <ol>
   <li><p>如果<var>value</var>为<var>oldValue</var>，则直接return。

   <li><p>如果<var>value</var>为null且<var>oldValue</var>为空字符串，则直接return。

   <li><p>如果<var>value</var>为空字符串且<var>oldValue</var>为null，则直接return。

   <li><p>如果<var>value</var>为null或空字符串，则设<var>element</var>的<a for=slot>name</a>为空字符串。 

   <li><p>否则，设<var>element</var>的<a for=slot>name</a>为<var>value</var>。

   <li><p>使用<var>element</var>的<a for=tree>root</a>运行<a lt="assign slottables for a tree">为树分配可插槽元素</a>。
  </ol>
</ol>

<p class=note><a>shadow tree</a>中的第一个<a for=slot>name</a>为空字符串的<a lt="slot">插槽</a>，有时被称为"默认插槽"。</p>

<p><a lt="slot">插槽</a>具有关联的<dfn export for=slot>assigned nodes</dfn>(分配节点，一个<a>slottables</a>列表)。除非另有说明，否则它是空的。

<h5 id=light-tree-slotables>Slottables：可插槽元素</h5>

<p>{{Element}}以及{{Text}}<a for=/ lt="nodes">节点</a>都是<dfn export id=concept-slotable lt=slottable>可插槽元素</dfn>。</p>

<p class=note><a>slot</a>也是<a lt="slottable">可插槽元素</a>。

<p><a lt="slottable">可插槽元素</a>具有相关的<dfn export for=slottable id=slotable-name lt="name">名称</dfn>(string)。
除非另有说明，否则它是空字符串。</p>

<p>使用这些<a lt="attribute change steps">属性更改步骤</a>来更新<a lt="slottable">可插槽元素</a>的<a for=slottable>name</a>属性：

<ol>
 <li>
  <p>如果<var>localName</var>为<code>slot</code>且<var>namespace</var>为null，则：

  <ol>
   <li><p>如果<var>value</var>为<var>oldValue</var>，则直接return。

   <li><p>如果<var>value</var>为null且<var>oldValue</var>为空字符串，则直接return。

   <li><p>如果<var>value</var>为空字符串且<var>oldValue</var>为null，则直接return。

   <li><p>如果<var>value</var>为null或空字符串，则设<var>element</var>的<a for=slottable>name</a>为空字符串。

   <li><p>否则，设<var>element</var>的<a for=slottable>name</a>为<var>value</var>。

   <li><p>如果<var>element</var><a for=slottable lt="assigned">已被分配</a>，则给定<var>element</var>的<a for=slottable>assigned slot</a>
   运行<a lt="assign slottables">分配可插槽元素</a>。

   <li><p>给定<var>element</var>运行<a lt="assign a slot">分配插槽</a>。
  </ol>
</ol>

<p><a lt="slottable">可插槽元素</a>具有关联的<dfn export for=slottable id=slotable-assigned-slot>assigned slot</dfn>(已分配插槽，null或<a>slot</a>)。
除非另有说明，否则为空。如果<a>assigned slot</a>不为null，则证明该元素<dfn export for=slottable id=slotable-assigned lt="assigned">已被分配</dfn>。</p>

<p><a lt="slottable">可插槽元素</a>具有关联的<dfn export for=slottable>manual slot assignment</dfn>(手动分配插槽，null或<a>slot</a>)。
U除非另有说明，否则为空。

<p class=note>可以使用对<a lt="slot">插槽</a>的弱引用来实现<a lt="slottable">可插槽元素</a>的<a lt="manual slot assignment">手动插槽分配</a>，
因为这个变量不能直接从脚本访问。

<h5 id=finding-slots-and-slotables>查找插槽以及可插槽元素</h5>

<p>给定的参数<a>slottable</a>和可选的参数<i>open flag</i>(除非另有说明，否则未设置)，<dfn export lt="find a slot|finding a slot">查找插槽</dfn>，
请运行以下步骤：</p>

<ol>
 <li><p>如果<var>slottable</var>的<a for=tree>parent</a>为null，则直接返回null</p></li>

 <li><p>设<var>shadow</var>为<var>slottable</var>的<a for=tree>parent</a>的
 <a for=Element>shadow root</a>。</p></li>

 <li><p>如果<var>shadow</var>为null，则直接返回null。</p></li>

 <li><p>如果<i>open flag</i>被设置且<var>shadow</var>的<a for=ShadowRoot>mode</a>不为"<code>open</code>"，则直接返回null。</p></li>

 <li><p>如果<var>shadow</var>的<a for=ShadowRoot>slot assignment</a>是"<code>manual</code>"，则返回<var>shadow</var>的<a for=tree lt="descendants">后代</a>
 中<a lt="manually assigned nodes">手动分配的节点</a><a for=set lt="contains">包含</a><var>slottable</var>的<a>slot</a>；如果没有则返回空。

 <li><p>返回<var>shadow</var>的<a for=tree lt="descendants">后代</a>中第一个<a>slot</a> ，其<a for=slot>name</a>为<var>slottable</var>
 的<a for=slottable>name</a>；如果没有则返回空。
</ol>

<p>给定参数<a>slot</a>，<dfn export lt="find slottables|finding slottables" id=find-slotables>查找可插槽元素</dfn>，请运行以下步骤：</p>

<ol>
 <li><p>设<var>result</var>为空list。</p></li>

 <li><p>设<var>root</var>为<var>slot</var>的<a for=tree>root</a>。

 <li><p>如果<var>root</var>不是<a for=/>shadow root</a>，则直接返回<var>result</var>。

 <li><p>设<var>host</var>为<var>root</var>的<a for=DocumentFragment>host</a>。

 <li>
  <p>如果<var>root</var>的<a for=ShadowRoot>slot assignment</a>为"<code>manual</code>"，则：

  <ol>
   <li><p>设<var>result</var>为« »。

   <li><p><a for=set lt="For each">遍历</a><var>slot</var>的<a lt="manually assigned nodes">手动分配的节点</a>中的
   <a>slottable</a>，如果<var>slottable</var>的<a for=tree>parent</a>为<var>host</var>，则向<var>result</var>
   <a for=list lt="append">添加</a>该<var>slottable</var>。
  </ol>

 <li>
  <p>否则，<a for=set lt="For each">遍历</a><var>host</var>的<a>slottable</a> <a for=tree>child</a>：

  <ol>
   <li><p>给定参数<var>slottable</var>运行<a lt="finding a slot">查找插槽</a>步骤，且设<var>foundSlot</var>为其结果。

   <li><p>如果<var>foundSlot</var>为<var>slot</var>，则<a for=list lt="append">添加</a><var>slottable</var>到<var>result</var>。
  </ol>
 </li>

 <li><p>返回<var>result</var>。</p></li>
</ol>

<p>给定参数<a>slot</a>元素，<dfn export lt="find flattened slottables|finding flattened slottables" id=find-flattened-slotables>找到所有slottables</dfn>
(包括其子孙<a>slot</a>元素的slottables)，将运行以下步骤：</p>

<ol>
 <li><p>设<var>result</var>为空list。</p></li>

 <li><p>如果<var>slot</var>的<a for=tree>root</a>不是<a for=/>shadow root</a>，则直接返回<var>result</var>。</p></li>

 <li><p>给定参数<var>slot</var>运行<a lt="finding slottables">查找可插槽元素</a>步骤，并设<var>slottables</var>为其结果。</p></li>

 <li><p>如果<var>slottables</var>为空list，则将<var>slot</var>的每个<a>slottable</a> <a for=tree>child</a>，按树的顺序添加到
 <var>slottables</var>。</p></li>

 <li>
  <p>遍历<var>slottables</var>中的<var>node</var>：

  <ol>
   <li>
    <p>如果<var>node</var>是<a for=tree>root</a>为<a for=/>shadow root</a>的<a>slot</a>，则：

    <ol>
     <li><p>给定参数<var>node</var>运行<a lt="finding flattened slottables">找到所有slottables</a>步骤，
     并设<var>temporaryResult</var>为其结果。</p></li>

     <li><p>按照树的顺序，添加每个<var>temporaryResult</var>中的<a>slottable</a>到<var>result</var>。</p></li>
    </ol>

   <li><p>否则，添加<var>node</var>到<var>result</var>。</p></li>
  </ol>
 </li>

 <li><p>返回<var>result</var>。</p></li>
</ol>

<h5 id=assigning-slotables-and-slots>分配可插槽元素和插槽</h5>

<p>给定参数<a>slot</a>，<dfn noexport id=assign-slotables lt="assign slottables">分配可插槽元素</dfn>，将运行以下步骤：

<ol>
 <li><p>给定参数<var>slot</var>运行<a lt="finding slottables">查找可插槽元素</a>步骤，并设<var>slottables</var>为其结果。

 <li><p>如果<var>slottables</var>与<var>slot</var>的<a for=slot>assigned nodes</a>不同，则给定参数<var>slot</var>运行
 <a lt="signal a slot change">发出插槽更改信号</a>。

 <li><p>设<var>slot</var>的<a for=slot>assigned nodes</a>为<var>slottables</var>。

 <li><p>遍历<var>slottables</var>中的<var>slottable</var>，设<var>slottable</var>的
 <a>assigned slot</a>为<var>slot</var>。
</ol>

<p>要<dfn noexport id=assign-slotables-for-a-tree lt="assign slottables for a tree">为树分配可插槽元素</dfn>，
给定参数<var>root</var>(<a for=/>node</a>类型)，按照<a lt="tree order">树的顺序</a>为每个<var>root</var>
的<a for=tree lt="inclusive descendants">包容性后代</a>的<var>slot</var>运行<a lt="assign slottables">分配可插槽元素</a>。

<p>给定参数<a>slottable</a>，<dfn noexport lt="assign a slot">分配插槽</dfn>，将运行以下步骤：

<ol>
 <li><p>给定参数<var>slottable</var>运行<a lt="finding a slot">查找插槽</a>步骤，设<var>slot</var>为其结果。

 <li><p>如果<var>slot</var>不为null，则为<var>slot</var>运行<a lt="assign slottables">分配可插槽元素</a>。
</ol>

<h5 id=signaling-slot-change>发出插槽改变信号</h5>

<p>每个<a lt="similar-origin window agent">同源的浏览器窗口对象</a>都有一组<dfn noexport id=signal-slot-list lt="signal slots">信号槽(signal slots)</dfn>
，初始为空。 [[!HTML]]

<p>给定参数<a>slot</a>，<dfn noexport lt="signal a slot change">发出插槽改变信号</dfn>，将运行以下步骤：

<ol>
 <li><p>将<var>slot</var><a for=set lt="Append">添加</a>到该<var>slot</var>所在的<a lt="relevant agent">浏览器窗口对象</a>
 的<a lt="signal slots">信号槽</a>集合中。

 <li><p><a lt="Queue a mutation observer microtask">将一个变异观察者微任务加入队列</a>。
</ol>


<h4 id=mutation-algorithms>修改DOM结构的算法</h4>

<p>要确保节点在子节点之前插入父节点的<dfn export for=Node id=concept-node-ensure-pre-insertion-validity lt="ensure pre-insertion validity">预插入有效性</dfn>
，请运行以下步骤：

<ol>
 <li><p>如果<var>parent</var>不是{{Document}}、{{DocumentFragment}}或{{Element}} <a for=/ lt="node">节点</a>，
 则<a lt="throw">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"的{{DOMException}}(DOM异常)。

 <li><p>如果<var>node</var>是<var>parent</var>的<a>host-including inclusive ancestor</a>，
 则<a lt="throw">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"的{{DOMException}}(DOM异常)。

 <li><p>如果<var>child</var>不为null并且它的<a for=tree>parent</a>不等于<var>parent</var>参数，
 则<a lt="throw">抛出</a>一个"{{NotFoundError!!exception}}(未找到错误)"的{{DOMException}}(DOM异常)。

 <li><p>如果<var>node</var>不是{{DocumentFragment}}、{{DocumentType}}、{{Element}}或{{CharacterData}} <a for=/ lt="node">节点</a>，
 则<a lt="throw">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"的{{DOMException}}(DOM异常)。

 <li><p>如果<var>node</var>是{{Text}}<a for=/ lt="node">节点</a>且<var>parent</var><a>document</a>，
 或<var>node</var>是<a>doctype</a>且<var>parent</var>不是<a>document</a>，则<a lt="throw">抛出</a>一个
 "{{HierarchyRequestError!!exception}}(层次结构请求错误)"的{{DOMException}}(DOM异常)。

 <li>
  <p>如果<var>parent</var>为<a>document</a>，且任何下列条件之一被<a lt="implements">实现</a>在接口<var>node</var>上，
  则<a lt="throw">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"的{{DOMException}}(DOM异常)。

  <dl class=switch>
   <dt>{{DocumentFragment}}
   <dd>
    <p>如果<var>node</var>有多个<a for=/>element</a> <a for=tree lt="child">子节点</a>或有一个{{Text}} <a for=tree lt="child">子节点</a>。

    <p>否则，如果<var>node</var>有一个<a for=/>element</a> <a for=tree lt="child">子节点</a>且<var>parent</var>有一个
    <a for=/>element</a> <a for=tree lt="child">子节点</a>， <var>child</var>为<a>doctype</a>，或<var>child</var>不为
    null且<a>doctype</a>在其<a lt="following">之后</a>。
    <!--"inclusively following"-->

   <dt>{{Element}}
   <dd><p><var>parent</var>有一个<a for=/>element</a> <a for=tree lt="child">子节点</a>，<var>子节点</var>为<a>doctype</a>，
   或<var>子节点</var>不为null且<a>doctype</a>在其<a lt="following">之后</a>。
   <!--"inclusively following"-->

   <dt>{{DocumentType}}
   <dd><p>如果父节点有一个<a>doctype</a> <a for=tree lt="child">子节点</a>，<var>子节点</var>不为null，
   并且在子节点<a lt="preceding">之前</a>有一个<a for=/>element</a>，或者子节点为null，并且父节点有一个
   <a for=/>element</a>子节点。
  </dl>
</ol>

<p>在子节点之前将节点<dfn export id=concept-node-pre-insert lt="pre-insert">预插入</dfn>到父节点中，请运行以下步骤：

<ol>
 <li><p>确保节点在子节点之前插入父节点的<a lt="Ensure pre-insertion validity">预插入有效性</a>。

 <li><p>设<var>referenceChild</var>为<var>child</var>。

 <li><p>如果<var>referenceChild</var>为<var>node</var>，则设<var>referenceChild</var>为
 <var>node</var>的<a for=tree>next sibling</a>。

 <li><p>在<var>referenceChild</var>之前将节点<a for=/ lt="Insert">插入</a>父节点。

 <li><p>返回<var>node</var>。
 <!-- Technically this is post-insert. -->
</ol>

<p><a lt="Other applicable specifications">规范</a>定义了所有或部分<a for=/ lt="nodes">节点</a>的
<dfn export id=concept-node-insert-ext lt="insertion steps">插入步骤</dfn>。该算法需要传递一个
<var ignore>insertedNode</var>参数，如下面的<a for=/>insert</a>算法所示。
<!-- See https://github.com/whatwg/dom/issues/34#issuecomment-125571750 for why we might need to
     adjust this further based on the requirements of the script element. There might be other ways
     to define that though as Olli suggests, so leaving that out for now. -->

<p><a lt="Other applicable specifications">规范</a>定义了所有或部分<a for=/ lt="nodes">节点</a>的
<dfn export id=concept-node-children-changed-ext lt="children changed steps">子节点更改步骤</dfn>。
该算法不传递任何参数，并从<a for=/>insert</a>、<a for=/>remove</a>和<a for=/>replace data</a>中调用。

<p>给定可选参数<i>suppress observers flag</i>，在子节点之前<dfn export id=concept-node-insert lt="insert">插入</dfn>
一个节点到父节点，将运行以下步骤：

<ol>
 <li><p>如果<var>node</var>为{{DocumentFragment}} <a for=/ lt="node">节点</a>，则设<var>nodes</var>为<var>node</var>的
 <a for=tree>children</a>属性；否则« <var>node</var> »。

 <li><p>设<var>count</var>为<var>nodes</var>的<a for=set>size</a>。

 <li><p>如果<var>count</var>为0，则直接return。

 <li>
  <p>如果<var>node</var>为{{DocumentFragment}} <a for=/ lt="node">节点</a>，则：

  <ol>
   <li><p><a for=/ lt="Remove">删除</a><a for=tree lt="children">子节点</a>，并设置<i>suppress observers flag</i>标志。

   <li>
    <p>给定参数« »、<var>nodes</var>、null与null，<a lt="Queue a tree mutation record">加入到树的修改队列中</a>。

    <p class=note>这一步故意不注意<i>suppress observers flag</i>。
  </ol>
  
 <li>
  <p>如果<var>child</var>不为null，则：

  <ol>
   <li><p>遍历<a for=range lt="start node">起始节点</a>为<var>parent</var>并且<a for=range lt="start offset">起始偏移量</a>
   是大于<var>child</var>的<a for=tree>index</a>的<a>live range</a>，将<a for=range lt="start offset">起始偏移量</a>增加<var>count</var>。

   <li><p>遍历<a for=range lt="end node">结束节点</a>为<var>parent</var>并且<a for=range lt="end offset">结束偏移量</a>
   是大于<var>child</var>的<a for=tree>index</a>的<a>live range</a>，将<a for=range lt="end offset">结束偏移量</a>增加<var>count</var>。
  </ol>

 <li><p>如果<var>child</var>为null，则设<var>previousSibling</var>为<var>child</var>的<a lt="previous sibling">上一个兄弟节点</a>
 或<var>parent</var>的<a lt="last child">最后一个子节点</a>。

 <li>
  <p>根据<a lt="tree order">树的顺序</a>，遍历<var>nodes</var>中的每个节点：

  <ol>
   <li><p><a lt="Adopt">接受</a><var>node</var>插入到<var>parent</var>的<a for=Node lt="node document">节点文档</a>中。

   <li><p>如果<var>child</var>为null，则<a for=set lt="append">添加</a><var>node</var>到<var>parent</var>的<a for=tree>children</a>中。

   <li><p>否则，在<var>child</var>的<a for=tree>index</a>之前<a for=set lt="insert">插入</a><var>node</var>到<var>parent</var>的
   <a for=tree>children</a>。

   <li><p>如果<var>parent</var>为其<a for=/>shadow root</a>的<a for=ShadowRoot>slot assignment</a>为"<code>named</code>"的
   <a for=Element>shadow host</a>，并且<var>node</var>是一个<a lt="slottable">可插槽元素</a>，则为<var>node</var>
   <a lt="assign a slot">分配一个插槽</a>。

   <li><p>如果<var>parent</var>的<a for=tree>root</a>为<a for=/>shadow root</a>，并且<var>parent</var>是一个
   <a for=slot lt="assigned nodes">分配的节点</a>为空列表的<a lt="slot">插槽</a>，则为<var>parent</var>运行
   <a lt="signal a slot change">发出插槽改变信号</a>。

   <li><p>使用<var>node</var>的<a for=tree>root</a>运行<a lt="assign slottables for a tree">为树分配可插槽元素</a>。

   <li>
    <p>遍历node的所有后代节点(包括shadow tree中的节点，<a lt="shadow-including tree order">访问元素的所有后代节点时，
    优先访问该元素的shadow tree中的节点，而不是先遍历该元素在常规的DOM树中的子节点。</a>(这种遍历顺序确保了在shadow DOM
    和light DOM中的元素都能够在正确的顺序中被遍历)。

    <ol>
     <li><p>使用<var>inclusiveDescendant</var>运行<a lt="insertion steps">插入步骤</a>。

     <li>
      <p>如果<var>inclusiveDescendant</var>是<a lt="connected">已连接的</a>，则：

      <ol>
       <li><p>如果<var>inclusiveDescendant</var>是一个<a for=Element lt="custom">自定义元素</a>，
       则将名为"<code>connectedCallback</code>"的回调函数<a lt="enqueue a custom element callback reaction">添加到队列</a>中，等待执行(当元素被添加到DOM上
       的时候触发)，该回调函数不接受任何参数。

       <li>
        <p>否则，则尝试将<var>inclusiveDescendant</var><a lt="try to upgrade an element" lt="try to upgrade">升级为自定义元素</a>。

        <p class=note>如果<var>inclusiveDescendant</var>成功升级，则其<code>connectedCallback</code>回调函数将在
        <a lt="upgrade an element">升级元素</a>算法期间自动排到队列中。
      </ol>
     </li>
    </ol>
   </li>
  </ol>

 <li><p>如果<i>suppress observers flag</i>没被设置，则给定参数<var>nodes</var>、« »、<var>previousSibling</var>以及<var>child</var>
 为<var>parent</var><a lt="queue a tree mutation record">将树结构变更的记录添加到队列中</a>。

 <li><p>为<var>parent</var>运行<a lt="children changed steps">子节点更改步骤</a>。
</ol>


<p>要将节点<dfn export id=concept-node-append lt="append">添加</dfn>到父节点，请在null之前将节点<a lt="pre-insert">预插入</a>父节点。


<p>要用父节点中的节点<dfn export id=concept-node-replace lt="replace">替换</dfn>子节点，请运行以下步骤：

<!-- Step 1-5 could be shared with concept-node-pre-insert, although step 3
     in pre-insert is a superset (which is fine). Step 6.1.1 could also be
     shared. -->

<ol>
 <li><p>如果<var>parent</var>不为{{Document}}、{{DocumentFragment}}或者{{Element}}<a for=/ lt="node">节点</a>，
 则<a lt="throw">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"的{{DOMException}}(DOM异常)。

 <li><p>如果<var>node</var>为<var>parent</var>的<a lt="host-including inclusive ancestor">包含shadow host的祖先元素</a>，
 则<a lt="throw">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"的{{DOMException}}(DOM异常)。

 <li><p>如果<var>child</var>的<a for=tree lt="parent">父节点</a>不为<var>parent</var>，则
 <a lt="throw">抛出</a>一个"{{NotFoundError!!exception}}(未发现错误)"的{{DOMException}}(DOM异常)。

 <li><p>如果<var>node</var>不为{{DocumentFragment}}、{{DocumentType}}、{{Element}}或者{{CharacterData}}<a for=/ lt="node">节点</a>，
 则<a lt="throw">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"的{{DOMException}}(DOM异常)。

 <li><p>如果<var>node</var>为{{Text}}<a for=/ lt="node">节点</a>并且<var>parent</var>为<a>document</a>，
 或者<var>node</var>为<a>doctype</a>且 <var>parent</var>不为<a>document</a>， 则<a lt="throw">抛出</a>
 一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"的{{DOMException}}(DOM异常)。

 <li>
  <p>如果<var>parent</var>为<a>document</a>，且任何下列条件之一被<a lt="implements">实现</a>在接口<var>node</var>上，
  则<a lt="throw">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"的{{DOMException}}(DOM异常)。

  <dl class=switch>
   <dt>{{DocumentFragment}}
   <dd>
    <p>如果<var>node</var>有多个<a for=/>element</a><a for=tree lt="child">子节点</a>或有一个{{Text}}
    <a for=tree lt="child">子节点</a>。

    <p>否则，如果<var>node</var>有一个<a for=/>element</a><a for=tree lt="child">子节点</a>，并且
    <var>parent</var>中有一个不为<var>child</var>或<a>doctype</a>在<var>child</var>之后的<a for=/>element</a>
    <a for=tree lt="child">子节点</a>。

   <dt>{{Element}}
   <dd><p><var>parent</var>有一个不为<var>child</var>或<a>doctype</a>在<var>child</var>之后的<a for=/>element</a>
   <a for=tree lt="child">子节点</a>。

   <dt>{{DocumentType}}
   <dd><p><var>parent</var>有一个不为<var>child</var>的<a>doctype</a><a for=tree lt="child">子节点</a>，
   或者一个在<var>child</var><a lt="preceding">之前</a>的<a for=/>element</a>。
  </dl>

  <p class=note>上述语句与<a lt="pre-insert">预插入</a>算法不同。

 <li><p>设<var>referenceChild</var>为<var>child</var>的<a for=tree>next sibling</a>(下一个兄弟节点)。

 <li><p>如果<var>referenceChild</var>为<var>node</var>，则设<var>referenceChild</var>为<var>node</var>
 的<a for=tree>next sibling</a>(下一个兄弟节点)。

 <li><p>设<var>previousSibling</var>为<var>child</var>的<a>previous sibling</a>(上一个兄弟节点)。

 <li><p>设<var>removedNodes</var>为空集合。

 <li>
  <p>如果<var>child</var>的<a for=tree lt="parent">父节点</a>不为null，则：

  <ol>
   <li><p>设<var>removedNodes</var>为« <var>child</var> »。

   <li><p><a for=/ lt="Remove">删除</a><var>child</var>，并设置其<i>suppress observers flag</i>标志。
  </ol>

  <p class=note>如果<var>child</var>是<var>node</var>，则以上只能false。

 <li><p>如果<var>node</var>为{{DocumentFragment}}<a for=/ lt="node">节点</a>，则设<var>nodes</var>为<var>node</var>的<a for=tree lt="children">子节点</a>;
 否则« <var>node</var> »。
 <!-- This needs to come before insert as that removes the children of a
      DocumentFragment node. -->

 <li><p><a for=/ lt="Insert">插入</a> <var>node</var>到<var>parent</var>，在设置了<i>suppress observers flag</i>的<var>referenceChild</var>之前。

 <li><p>给定参数<var>nodes</var>、<var>removedNodes</var>、<var>previousSibling</var>以及<var>referenceChild</var>，
 为<var>parent</var><a lt="queue a tree mutation record">将树结构变更的记录添加到队列中</a>。

 <li><p>返回<var>child</var>。
</ol>


<p>要<dfn export for=Node id=concept-node-replace-all lt="replace all">替换所有</dfn><var>parent</var>中的<var>node</var>
，请运行一下步骤：

<ol>
 <li><p>设<var>removedNodes</var>为<var>parent</var>的<a for=tree lt="children">子节点</a>。

 <li><p>设<var>addedNodes</var>为空集合。

 <li><p>如果<var>node</var>为{{DocumentFragment}}<a for=/ lt="node">节点</a>，则设
 <var>addedNodes</var>为<var>node</var>的<a for=tree lt="children">子节点</a>。

 <li><p>否则，如果<var>node</var>不为null，则设<var>addedNodes</var>为« <var>node</var> »。

 <li><p>根据<a lt="tree order">树的顺序</a><a for=/ lt="Remove">删除</a>所有<var>parent</var>的
 <a for=tree lt="children">子节点</a>，且在删除时设置<i>suppress observers flag</i>标志。

 <li><p>如果<var>node</var>不为null，则<a for=/ lt="insert">插入</a><var>node</var>到null之前的
 <var>parent</var>，且在插入时设置<i>suppress observers flag</i>标志。

 <li><p>如果<var>addedNodes</var>或<var>removedNodes</var><a for=set lt="is not empty">不为空</a>，则
 给定参数<var>addedNodes</var>、<var>removedNodes</var>、 null以及null，为<var>parent</var>
 <a lt="queue a tree mutation record">将树结构变更的记录添加到队列中</a>。
</ol>

<p class=note>该算法不对<a lt="node tree">节点树</a>约束进行任何检查。规范作者需要明智地使用它。


<p><dfn export id=concept-node-pre-remove lt="pre-remove">预删除</dfn><var>parent</var>的<var>child</var>，
请运行以下步骤：

<ol>
 <li><p>如果<var>child</var>的<a for=tree lt="parent">父节点</a>不为<var>parent</var>，则<a lt="throw">抛出</a>一个
 "{{NotFoundError!!exception}}(未找到错误)"的{{DOMException}}(DOM异常)。

 <li><p><a for=/ lt="Remove">删除</a><var>child</var>。

 <li><p>返回<var>child</var>。
 <!-- Technically this is post-remove. -->
</ol>


<p><a lt="Other applicable specifications">规范</a>可以定义所有或部分<a for=/ lt="nodes">节点</a>
的<dfn export id=concept-node-remove-ext lt="removing steps">删除步骤</dfn>。该算法需要传入
<var ignore>removedNode</var>以及可选的<var ignore>oldParent</var>参数，如下面的<a for=/ lt="remove">删除</a>算法所示。

<p>给定可选的参数<i>suppress observers flag</i>， <dfn export id=concept-node-remove lt="remove">删除</dfn>一个
<var>node</var>，请运行以下步骤：

<ol>
 <li><p>设<var>parent</var>为<var>node</var>的<a for=tree lt="parent">父节点</a>。

 <li><p>确定: <var>parent</var>不为null。

 <li><p>设<var>index</var>为<var>node</var>的<a for=tree>index</a>。

 <li><p>对于每一个<a>live range</a>，如果它的<a for=range lt="start node">开始节点</a>是<var>node</var>
 的<a lt="inclusive descendant">包容性后代</a>，则将其<a for=range>start</a>设置为(<var>parent</var>，
 <var>index</var>)。这个(parent，index)指的是父节点的位置，也就是在父节点的第几位，意味着更新了对应的
 <a>live range</a>的开始节点。

 <li><p>对于每一个<a>live range</a>，如果它的<a for=range lt="end node">结束节点</a>是<var>node</var>
 的<a lt="inclusive descendant">包容性后代</a>，则将其<a for=range>end</a>设置为(<var>parent</var>，
 <var>index</var>)。这个(parent，index)指的是父节点的位置，也就是在父节点的第几位，意味着更新了对应的
 <a>live range</a>的结束节点。

 <li><p>对于每一个<a>live range</a>，如果它的<a for=range lt="start node">开始节点</a>为<var>parent</var>
 并且<a for=range lt="start offset">开始偏移量</a>大于<var>index</var>，则使它的<a for=range lt="start offset">
 开始偏移量</a>减一。

 <li><p>对于每一个<a>live range</a>，如果它的<a for=range lt="end node">结束节点</a>为<var>parent</var>
 并且<a for=range lt="end offset">结束偏移量</a>大于<var>index</var>，则使它的<a for=range lt="end offset">
 结束偏移量</a>减一。

 <li><p>对于<a for=traversal>root</a>的<a for=Node lt="node document">节点文档</a>是<var>node</var>的
 <a for=Node lt="node document">节点文档</a>的每个{{NodeIterator}}对象(称为iterator)，给定参数<var>node</var>
 以及<var>iterator</var>运行<a lt="NodeIterator pre-removing steps"><code>NodeIterator</code>预删除步骤</a>。

 <li><p>设<var>oldPreviousSibling</var>为<var>node</var>的<a>previous sibling</a>(上一个兄弟节点)。

 <li><p>设<var>oldNextSibling</var>为<var>node</var>的<a for=tree>next sibling</a>(下一个兄弟节点)。

 <li><p>从它的<var>parent</var>的<a for=tree lt="children">子节点</a>中<a for=set lt="Remove">删除</a><var>node</var>。

 <li><p>如果<var>node</var><a for=slottable lt="assigned">已被分配</a>，则为<var>node</var>的<a>assigned slot</a>
 运行<a lt="assign slottables">分配可插槽元素</a>。

 <li><p>如果<var>parent</var>的<a for=tree>root</a>为<a for=/>shadow root</a>，且<var>parent</var>
 为一个<a for=slot>assigned nodes</a>为空列表的<a lt="slot">插槽元素</a>，则为<var>parent</var>运行
 <a lt="signal a slot change">发出插槽改变信号步骤</a>。

 <li>
  <p>如果<var>node</var>有一个<a lt="inclusive descendant">包容性后代</a>为<a lt="slot">插槽</a>，则：

  <ol>
   <li><p>使用<var>parent</var>的<a for=tree>root</a>运行<a lt="assign slottables for a tree">为树分配可插槽元素</a>。

   <li><p>使用<var>node</var>运行<a lt="assign slottables for a tree">为树分配可插槽元素</a>。
  </ol>

 <li><p>使用<var>node</var>以及<var>parent</var>运行<a lt="removing steps">删除步骤</a>。

 <li><p>设<var>isParentConnected</var>为<var>parent</var>的<a>connected</a>。

 <li>
  <p>如果<var>node</var>为<a for=Element lt="custom">自定义元素</a>并且<var>isParentConnected</var>为true，则
  将名为"<code>disconnectedCallback</code>"的回调函数<a lt="enqueue a custom element callback reaction">添加到队列</a>中，
  等待执行(当元素在DOM上被移除的时候触发)，该回调函数不接受任何参数。

  <p class=note>当前<a for=Element lt="custom">自定义</a><a for=/ lt="elements">元素</a>不会传递父元素这是有意为之的。
  但是在未来，如果有需要的话，可能会改变这个行为。

 <li>
  <p>使用<a lt="shadow-including tree order">已连接的shadow tree的顺序</a>，遍历<var>node</var>
  中<a lt="shadow-including descendant">已连接的Shadow DOM的后代元素</a>，则：

  <ol>
   <li><p>使用<var>descendant</var>运行<a lt="removing steps">删除步骤</a>。

   <li><p>如果<var>descendant</var>为<a for=Element lt="custom">自定义元素</a>并且<var>isParentConnected</var>为true，
   则将名为"<code>disconnectedCallback</code>"的回调函数<a lt="enqueue a custom element callback reaction">添加到队列</a>中，
   等待执行(当元素在DOM上被移除的时候触发)，该回调函数不接受任何参数。
  </ol>
 </li>

 <li><p>对于<var>parent</var>的每一个<a for=tree lt="inclusive ancestor">包含它的祖先</a>(<var>inclusiveAncestor</var>)，以及
 对于<var>inclusiveAncestor</var>的<a lt="registered observer list">已注册观察者列表</a>中每一个已注册的观察者(registered)，
 如果<var>registered</var>的<a for="registered observer">options</a>["{{MutationObserverInit/subtree}}"]为true，则
 在<var>node</var>的<a lt="registered observer list">已注册观察者列表</a>中<a for=list lt="append">添加</a>一个新的
 <a lt="transient registered observer">临时观察者</a>，该观察者的<a for="registered observer">observer</a>是<var>registered</var>
 的<a for="registered observer">observer</a>，<a for="registered observer">options</a>是<var>registered</var>的
 <a for="registered observer">options</a>，<a for="transient registered observer">source</a>是<var>registered</var>。

 <li><p>如果<i>suppress observers flag</i>没被设置，则给定参数« »、« <var>node</var> »、 <var>oldPreviousSibling</var>
 以及<var>oldNextSibling</var>，为<var>parent</var><a lt="queue a tree mutation record">将树结构变更的记录添加到队列中</a>。

 <li><p>为<var>parent</var>运行<a lt="children changed steps">子节点更改步骤</a>。
</ol>


<h4 id=interface-nonelementparentnode>混入(Mixin)：{{NonElementParentNode}}</h4>

<p class=note>由于网页兼容性的原因，{{NonElementParentNode/getElementById()}}方法不能在DOM<a for=/ lt="elements">元素</a>上直接被调用。
这也是为什么在{{ParentNode}}上没有暴露{{NonElementParentNode/getElementById()}}方法的原因。

<pre class=idl>
interface mixin NonElementParentNode {
  Element? getElementById(DOMString elementId);
};
Document includes NonElementParentNode;
DocumentFragment includes NonElementParentNode;
</pre>

<dl class=domintro>
 <dt><code><var>node</var> . <a method for=NonElementParentNode lt="getElementById()">getElementById</a>(<var>elementId</var>)</code>
 <dd><p>返回<var>node</var>的<a lt="descendants">后代</a>中第一个<a for=Element>ID</a>为<var>elementId</var>的<a for=/ lt="element">元素</a>。
</dl>

<p><dfn method for=NonElementParentNode><code>getElementById(<var>elementId</var>)</code></dfn>方法
返回<a>this</a>的后代中第一个(按照<a lt="tree order">树的顺序</a>)<a for=Element>ID</a>为<var>elementId</var>
的<a for=/ lt="element">元素</a>;否则，如果没有匹配的<a for=/ lt="element">元素</a>，则返回null。


<h4 id=mixin-documentorshadowroot>混入(Mixin)：{{DocumentOrShadowRoot}}</h4>

<pre class=idl>
interface mixin DocumentOrShadowRoot {
};
Document includes DocumentOrShadowRoot;
ShadowRoot includes DocumentOrShadowRoot;
</pre>

<p class=note>{{DocumentOrShadowRoot}}mixin预计会被其他想要定义<a for=/>documents</a>和<a for=/>shadow roots</a>
之间共享的API的标准使用。


<h4 id=interface-parentnode>混入(Mixin)：{{ParentNode}}</h4>

<p>给定参数<var>nodes</var>以及<var>document</var>，<dfn export lt="converting nodes into a node" lt="convert nodes into a node">转换nodes为node</dfn>，
请运行以下步骤：

<ol>
 <li><p>设<var>node</var>为null。

 <li><p>使用新的{{Text}}<a for=/ lt="node">节点</a>替换每个<a for=CharacterData>data</a>为字符串并且
 <a for=Node lt="node document">节点文档</a>为<var>document</var>的<var>nodes</var>中的字符串。

 <li><p>如果<var>nodes</var>包含一个<a for=/ lt="node">节点</a>，则设<var>node</var>为<var>nodes</var>[0]。

 <li><p>否则，设<var>node</var>为新的<a for=Node lt="node document">节点文档</a>为<var>document</var>的
 {{DocumentFragment}}<a for=/ lt="node">节点</a>，并且<a lt="append">添加</a>每个<a for=/ lt="node">节点</a>
 (如果有)到<var>nodes</var>中。

 <li><p>返回<var>node</var>.
</ol>

<pre class=idl>
interface mixin ParentNode {
  [SameObject] readonly attribute HTMLCollection children;
  readonly attribute Element? firstElementChild;
  readonly attribute Element? lastElementChild;
  readonly attribute unsigned long childElementCount;

  [CEReactions, Unscopable] undefined prepend((Node or DOMString)... nodes);
  [CEReactions, Unscopable] undefined append((Node or DOMString)... nodes);
  [CEReactions, Unscopable] undefined replaceChildren((Node or DOMString)... nodes);

  Element? querySelector(DOMString selectors);
  [NewObject] NodeList querySelectorAll(DOMString selectors);
};
Document includes ParentNode;
DocumentFragment includes ParentNode;
Element includes ParentNode;
</pre>

<dl class=domintro>
 <dt><code><var>collection</var> = <var>node</var> . {{ParentNode/children}}</code>
 <dd>返回<a for=tree lt="child">子</a> <a for=/ lt="elements">元素</a>。

 <dt><code><var>element</var> = <var>node</var> . {{ParentNode/firstElementChild}}</code>
 <dd>返回第一个<a for=tree lt="child">子</a> <a for=/ lt="elements">元素</a>；如果没有则返回null。

 <dt><code><var>element</var> = <var>node</var> . {{ParentNode/lastElementChild}}</code>
 <dd>返回最后一个<a for=tree lt="child">子</a> <a for=/ lt="elements">元素</a>；如果没有则返回null。

 <!-- childElementCount is redundant -->

 <dt><code><var>node</var> . <a method for=ParentNode lt="prepend()">prepend</a>(<var>nodes</var>)</code>
 <dd>
  <p>在<a for=tree lt="first child">第一个子节点</a>之前插入节点，同时用等效的{{Text}}节点替换节点中的字符串。

  <p>如果违反了<a lt="node tree">节点树</a>的限制，则<a lt="Throws">抛出</a>一个"{{HierarchyRequestError!!exception}}
  (层次结构请求错误)"的{{DOMException}}(DOM异常)。
  <!-- "NotFoundError" is impossible -->

 <dt><code><var>node</var> . <a method for=ParentNode lt="append()">append</a>(<var>nodes</var>)</code>
 <dd>
  <p>在<a for=tree lt="last child">最后一个子节点</a>之后插入节点，同时用等效的{{Text}}节点替换节点中的字符串。

  <p>如果违反了<a lt="node tree">节点树</a>的限制，则<a lt="Throws">抛出</a>一个"{{HierarchyRequestError!!exception}}
  (层次结构请求错误)"的{{DOMException}}(DOM异常)。
  <!-- "NotFoundError" is impossible -->

 <dt><code><var>node</var> . <a method for=ParentNode lt="replaceChildren()">replaceChildren</a>(<var>nodes</var>)</code>
 <dd>
  <p>使用<var>nodes</var>替换所有的<a for=tree lt="children">子节点</a>，同时用等效的{{Text}}节点替换节点中的字符串。

  <p>如果违反了<a lt="node tree">节点树</a>的限制，则<a lt="Throws">抛出</a>一个"{{HierarchyRequestError!!exception}}
  (层次结构请求错误)"的{{DOMException}}(DOM异常)。
  <!-- "NotFoundError" is impossible -->

 <dt><code><var>node</var> . <a method for=ParentNode lt="querySelector()">querySelector</a>(<var>selectors</var>)</code>
 <dd>
  返回节点<a lt="descendant">后代</a>中匹配<var>selectors</var>的第一个<a for=/ lt="element">元素</a>。

 <dt><code><var>node</var> . <a method for=ParentNode lt="querySelectorAll()">querySelectorAll</a>(<var>selectors</var>)</code>
 <dd>
  返回节点<a lt="descendant">后代</a>中匹配<var>selectors</var>的所有<a for=/ lt="element">元素</a>。
</dl>

<p><dfn attribute for=ParentNode><code>children</code></dfn> getter将返回一个以<a>this</a>
为根的<a for=tree lt="children">子</a><a for=/ lt="element">元素</a>的{{HTMLCollection}}
<a lt="collection">集合</a>。

<p><dfn attribute for=ParentNode><code>firstElementChild</code></dfn> getter将返回第一个
<a for=tree lt="child">子元素</a>；如果没有子元素则返回null。

<p><dfn attribute for=ParentNode><code>lastElementChild</code></dfn> getter将返回最后一个
<a for=tree lt="child">子元素</a>；如果没有子元素则返回null。

<p><dfn attribute for=ParentNode><code>childElementCount</code></dfn> getter将返回以
<a>this</a>为根的<a for=tree lt="children">子元素</a>的数量。

<p><dfn method for=ParentNode><code>prepend(<var>nodes</var>)</code></dfn>方法执行步骤为： 

<ol>
 <li><p>给定参数<var>nodes</var>以及<a>this</a>的<a for=Node lt="node document">节点文档</a>，
 <a lt="converting nodes into a node">转换nodes为node</a>，设<var>node</var>为其结果。

 <li><p>在<a>this</a>的<a for=tree lt="first child">第一个子元素</a>之前<a lt="Pre-insert">预插入</a>
 <var>node</var>到<a>this</a>。
</ol>

<p><dfn method for=ParentNode><code>append(<var>nodes</var>)</code></dfn>方法执行步骤为：

<ol>
 <li><p>给定参数<var>nodes</var>以及<a>this</a>的<a for=Node lt="node document">节点文档</a>，
 <a lt="converting nodes into a node">转换nodes为node</a>，设<var>node</var>为其结果。

 <li><p><a lt="Append">添加</a><var>node</var>到<a>this</a>。
</ol>

<p><dfn method for=ParentNode><code>replaceChildren(<var>nodes</var>)</code></dfn>方法执行步骤为：

<ol>
 <li><p>给定参数<var>nodes</var>以及<a>this</a>的<a for=Node lt="node document">节点文档</a>，
 <a lt="converting nodes into a node">转换nodes为node</a>，设<var>node</var>为其结果。

 <li><p>将<var>node</var>在null之前插入到<a>this</a>，<a lt="Ensure pre-insertion validity">确认预插入有效性</a>。

 <li><p><a for=Node lt="Replace all">替换所有</a><a>this</a>中的<var>node</var>。
</ol>

<p><dfn method for=ParentNode><code>querySelector(<var>selectors</var>)</code></dfn>方法将 
针对<a>this</a><a lt="scope-match a selectors string">匹配给定的字符串选择器</a>，如果匹配结果
不为空列表则返回的第一个结果，否则则返回null。

<p><dfn method for=ParentNode><code>querySelectorAll(<var>selectors</var>)</code></dfn>方法将返回
针对<a>this</a><a lt="scope-match a selectors string">匹配给定的字符串选择器</a>的结果。


<h4 id=interface-nondocumenttypechildnode>混入(Mixin)：{{NonDocumentTypeChildNode}}</h4>

<p class=note>由于考虑到Web兼容性问题，因此{{previousElementSibling}}和{{nextElementSibling}}属性并没有暴露在
<a for=/>doctypes</a>上，而是暴露在{{ChildNode}}上。

<pre class=idl>
interface mixin NonDocumentTypeChildNode {
  readonly attribute Element? previousElementSibling;
  readonly attribute Element? nextElementSibling;
};
Element includes NonDocumentTypeChildNode;
CharacterData includes NonDocumentTypeChildNode;
</pre>

<dl class=domintro>
 <dt><code><var>element</var> = <var>node</var> . {{previousElementSibling}}</code>
 <dd>返回<a lt="preceding">前一个</a><a for=tree lt="sibling">兄弟</a><a for=/ lt="element">元素</a>；
 没有则返回null。

 <dt><code><var>element</var> = <var>node</var> . {{nextElementSibling}}</code>
 <dd>返回<a lt="following">后一个</a><a for=tree lt="sibling">兄弟</a><a for=/ lt="element">元素</a>；
 没有则返回null。
</dl>

<p><dfn attribute for=NonDocumentTypeChildNode><code>previousElementSibling</code></dfn> getter方法将
返回<a lt="preceding">前一个</a><a for=tree lt="sibling">兄弟</a><a for=/ lt="element">元素</a>；
没有则返回null。

<p>The <dfn attribute for=NonDocumentTypeChildNode><code>nextElementSibling</code></dfn> getter方法将
返回<a lt="following">后一个</a><a for=tree lt="sibling">兄弟</a><a for=/ lt="element">元素</a>；
没有则返回null。


<h4 id=interface-childnode>混入(Mixin)：{{ChildNode}}</h4>

<pre class=idl>
interface mixin ChildNode {
  [CEReactions, Unscopable] undefined before((Node or DOMString)... nodes);
  [CEReactions, Unscopable] undefined after((Node or DOMString)... nodes);
  [CEReactions, Unscopable] undefined replaceWith((Node or DOMString)... nodes);
  [CEReactions, Unscopable] undefined remove();
};
DocumentType includes ChildNode;
Element includes ChildNode;
CharacterData includes ChildNode;
</pre>

<dl class=domintro>
 <dt><code><var>node</var> . {{before(...nodes)}}</code>
 <dd>
  <p>在该节点之前插入<var>nodes</var>，同时用等效的{{Text}}<a for=/ lt="nodes">节点</a>替换<var>nodes</var>中的字符串。

  <p>如果违反了<a lt="node tree">节点树</a>的限制，则<a lt="Throws">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"
  的{{DOMException}}(DOM异常)。

 <dt><code><var>node</var> . {{after(...nodes)}}</code>
 <dd>
  <p>在该节点之后插入<var>nodes</var>，同时用等效的{{Text}}<a for=/ lt="nodes">节点</a>替换<var>nodes</var>中的字符串。

  <p>如果违反了<a lt="node tree">节点树</a>的限制，则<a lt="Throws">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"
  的{{DOMException}}(DOM异常)。

 <dt><code><var>node</var> . {{replaceWith(...nodes)}}</code>
 <dd>
  <p>使用<var>nodes</var>替换该节点，同时用等效的{{Text}}<a for=/ lt="nodes">节点</a>替换<var>nodes</var>中的字符串。

  <p>如果违反了<a lt="node tree">节点树</a>的限制，则<a lt="Throws">抛出</a>一个"{{HierarchyRequestError!!exception}}(层次结构请求错误)"
  的{{DOMException}}(DOM异常)。

 <dt><code><var>node</var> . {{ChildNode/remove()}}</code>
 <dd>删除该节点。
</dl>

<p><dfn method for=ChildNode><code>before(<var>nodes</var>)</code></dfn>方法执行步骤如下：

<ol>
 <li><p>设<var>parent</var>为<a>this</a>的<a for=tree>parent</a>。

 <li><p>如果<var>parent</var>为null，则直接return。

 <li><p>设<var>viablePreviousSibling</var>为<a>this</a>的不为<var>nodes</var>的<a lt="preceding">上一个</a>
 <a for=tree lt="sibling">兄弟节点</a>；没有，则为null。

 <li><p>给定参数<var>nodes</var>以及<a>this</a>的<a for=Node lt="node document">节点文档</a>
 <a lt="converting nodes into a node">转换nodes为node</a>，设<var>node</var>为其结果。

 <li><p>如果<var>viablePreviousSibling</var>为null，则设它为<var>parent</var>的<a for=tree lt="first child">第一个子节点</a>
 ；如果<var>viablePreviousSibling</var>不为null，则设它为它的<a for=tree lt="next sibling">下一个兄弟节点</a>。

 <li><p><var>node</var>在<var>viablePreviousSibling</var>之前<a lt="Pre-insert">预插入</a>到<var>parent</var>。
</ol>

<p><dfn method for=ChildNode><code>after(<var>nodes</var>)</code></dfn>方法执行步骤如下：

<ol>
 <li><p>设<var>parent</var>为<a>this</a>的<a for=tree>parent</a>。

 <li><p>如果<var>parent</var>为null，则直接return。

 <li><p>设<var>viableNextSibling</var>为<a>this</a>的不为<var>nodes</var>的<a lt="following">下一个</a>
 <a for=tree lt="sibling">兄弟节点</a>;没有，则为null。

 <li><p>给定参数<var>nodes</var>以及<a>this</a>的<a for=Node lt="node document">节点文档</a>
 <a lt="converting nodes into a node">转换nodes为node</a>，设<var>node</var>为其结果。

 <li><p><var>node</var>在<var>viablePreviousSibling</var>之前<a lt="Pre-insert">预插入</a>到<var>parent</var>。
</ol>

<p><dfn method for=ChildNode><code>replaceWith(<var>nodes</var>)</code></dfn>方法执行步骤如下：

<ol>
 <li><p>设<var>parent</var>为<a>this</a>的<a for=tree>parent</a>。

 <li><p>如果<var>parent</var>为null，则直接return。

 <li><p>设<var>viableNextSibling</var>为<a>this</a>的不为<var>nodes</var>的<a lt="following">下一个</a>
 <a for=tree lt="sibling">兄弟节点</a>;没有，则为null。

 <li><p>给定参数<var>nodes</var>以及<a>this</a>的<a for=Node lt="node document">节点文档</a>
 <a lt="converting nodes into a node">转换nodes为node</a>，设<var>node</var>为其结果。

 <li>
  <p>如果<a>this</a>的<a for=tree>parent</a>为<var>parent</var>，则将<a>this</a><a lt="replace">替换</a>为
  <var>parent</var>中的节点。

  <p class=note><a>This</a>可能已经被插入到节点中。

 <li><p>否则，<var>node</var>在<var>viableNextSibling</var>之前<a lt="pre-insert">预插入</a>到<var>parent</var>。
</ol>

<p><dfn method for=ChildNode><code>remove()</code></dfn>方法执行步骤如下：

<ol>
 <li><p>如果<a>this</a>的<a for=tree>parent</a>为null，则直接return。

 <li><p><a for=/ lt="Remove">删除</a><a>this</a>。
</ol>


<h4 id=mixin-slotable>混入(Mixin)：{{Slottable}}</h4>

<pre class=idl>
interface mixin Slottable {
  readonly attribute HTMLSlotElement? assignedSlot;
};
Element includes Slottable;
Text includes Slottable;
</pre>

<p><dfn attribute for=Slottable id=dom-slotable-assignedslot><code>assignedSlot</code></dfn>
getter方法将返回给定参数<a>this</a>以及设置的<i>open flag</i><a lt="find a slot">查找插槽</a>的结果。


<h4 id=old-style-collections>早期集合类型：{{NodeList}}以及{{HTMLCollection}}</h4>

<dfn export id=concept-collection lt="collection">集合(collection)</dfn>是一个对象，它表示一组<a for=/ lt="nodes">节点</a>的列表。
<a lt="collection">集合</a>可以是<dfn export for=collection id=concept-collection-live lt="live collection" local-lt="live">动态的</dfn>
或是<dfn export for=collection id=concept-collection-static lt="static collection">静态的</dfn>。若没有特别声明，<a lt="collection">集合</a>
必须是<a for=collection lt="live">动态的</a>。

如果<a lt="collection">集合</a>是<a for=collection lt="live">动态的</a>，则该对象的属性以及方法必须对实际的底层数据进行操作，
而不是数据的快照。

当一个<a lt="collection">集合</a>被创建时，会与之关联一个过滤器和一个根。

<a lt="collection">集合</a>表示以<a lt="collection">集合</a>的根节点为根的子树的视图，它仅包含匹配过滤器的节点。视图是线性的。
相反，在没有特定要求的情况下，<a lt="collection">集合</a>中的节点必须按<a lt="tree order">树的顺序</a>排序。


<h5 id=interface-nodelist>接口：{{NodeList}}</h5>

<p>{{NodeList}}对象表示<a for=/ lt="nodes">节点</a>的<a lt="collection">集合</a>。

<pre class=idl>
[Exposed=Window]
interface NodeList {
  getter Node? item(unsigned long index);
  readonly attribute unsigned long length;
  iterable&lt;Node>;
};
</pre>

<dl class=domintro>
 <dt><var>collection</var> . {{NodeList/length}}
 <dd>返回<a lt="collection">集合</a>中<a for=/ lt="nodes">节点</a>的数量。

 <dt><var>element</var> = <var>collection</var> . {{NodeList/item(index)}}
 <dt><var>element</var> = <var>collection</var>[<var>index</var>]
 <dd>从<a lt="collection">集合</a>中返回索引为index的<a for=/ lt="node">节点</a>，
 <a for=/ lt="nodes">节点</a>按<a lt="tree order">树的顺序</a>排序。
</dl>

<div class=impl>

<p>对象<a lt="supported property indices">支持的属性索引</a>是从零到<a for=collection lt="represented by the collection">集合代表</a>
的节点数量减一的范围内的数字。如果没有这样的元素，则表示没有<a lt="supported property indices">支持的属性索引</a>。

<p><dfn attribute for=NodeList>length</dfn>属性返回<a for=collection lt="represented by the collection">集合代表</a>的节点数量。

<p><dfn method for=NodeList><code>item(<var>index</var>)</code></dfn>方法必须返回<a lt="collection">集合</a>中索引为<var>index</var>的
<a for=/ lt="node">节点</a>，如何没有这样的节点，该方法将返回null。

</div>


<h5 id=interface-htmlcollection>接口：{{HTMLCollection}}</h5>

<pre class=idl>
[Exposed=Window, LegacyUnenumerableNamedProperties]
interface HTMLCollection {
  readonly attribute unsigned long length;
  getter Element? item(unsigned long index);
  getter Element? namedItem(DOMString name);
};
</pre>

<p>{{HTMLCollection}}对象表示<a for=/ lt="elements">元素</a>的<a lt="collection">集合</a>。

<p class=note>{{HTMLCollection}} is a historical artifact we cannot rid the web of.
While developers are of course welcome to keep using it, new API standard designers ought not to use
it (use <code>sequence&lt;T></code> in IDL instead).

<dl class=domintro>
 <dt><var>collection</var> . {{HTMLCollection/length}}
 <dd>
  Returns the number of <a for=/>elements</a> in
  the <a>collection</a>.

 <dt><var>element</var> = <var>collection</var> . {{HTMLCollection/item(index)}}
 <dt><var>element</var> = <var>collection</var>[<var>index</var>]
 <dd>
  Returns the <a for=/>element</a> with index
  <var>index</var> from the <a>collection</a>.
  The <a for=/>elements</a> are sorted in <a>tree order</a>.

 <dt><var>element</var> = <var>collection</var> . {{namedItem(name)}}
 <dt><var>element</var> = <var>collection</var>[<var>name</var>]
 <dd>
  Returns the first <a for=/>element</a> with <a for=Element>ID</a> or name <var>name</var>
  from the collection.
</dl>

<p>The object's <a>supported property indices</a> are the numbers in the range zero to one less than
the number of elements <a for=collection>represented by the collection</a>. If there are no such
elements, then there are no <a>supported property indices</a>.

<p>The <dfn attribute for=HTMLCollection><code>length</code></dfn> getter steps are to return the
number of nodes <a for=collection>represented by the collection</a>.

<p>The <dfn method for=HTMLCollection><code>item(<var>index</var>)</code></dfn> method steps are to
return the <var>index</var><sup>th</sup> <a for=/>element</a> in the <a>collection</a>. If there
is no <var>index</var><sup>th</sup> <a for=/>element</a> in the <a>collection</a>, then the method
must return null.

<p>The <a>supported property names</a> are the values from the list returned by these steps:

<ol>
 <li><p>Let <var>result</var> be an empty list.

 <li>
  <p>For each <var>element</var> <a for=collection>represented by the collection</a>, in
  <a>tree order</a>:

  <ol>
   <li><p>If <var>element</var> has an <a for=Element>ID</a> which is not in <var>result</var>,
   append <var>element</var>'s <a for=Element>ID</a> to <var>result</var>.

   <li><p>If <var>element</var> is in the <a>HTML namespace</a> and <a lt="has an attribute">has</a>
   a <a lt="named attribute"><code>name</code> attribute</a> whose <a for=Attr>value</a> is neither
   the empty string nor is in <var>result</var>, append <var>element</var>'s
   <a lt="named attribute"><code>name</code> attribute</a> <a for=Attr>value</a> to
   <var>result</var>.
  </ol>

 <li><p>Return <var>result</var>.
</ol>

<p>The <dfn method for=HTMLCollection><code>namedItem(<var>key</var>)</code></dfn> method steps are:

<ol>
 <li><p>If <var>key</var> is the empty string, return null.

 <li>
  <p>Return the first <a for=/>element</a> in the <a>collection</a> for which at least one of
  the following is true:

  <ul>
   <li>it has an <a for=Element>ID</a> which is <var>key</var>;

   <li>it is in the <a>HTML namespace</a> and <a lt="has an attribute">has</a> a
   <a lt="named attribute"><code>name</code> attribute</a> whose <a for=Attr>value</a> is
   <var>key</var>;
  </ul>

  <p>or null if there is no such <a for=/>element</a>.
</ol>



<h3 id=mutation-observers>Mutation observers</h3>

<p>Each <a>similar-origin window agent</a> has a
<dfn noexport id=mutation-observer-compound-microtask-queued-flag>mutation observer microtask queued</dfn>
(a boolean), which is initially false. [[!HTML]]

<p>Each <a>similar-origin window agent</a> also has
<dfn noexport id=mutation-observer-list>mutation observers</dfn> (a <a for=/>set</a> of zero or more
{{MutationObserver}} objects), which is initially empty.

<p>To
<dfn noexport id=queue-a-mutation-observer-compound-microtask>queue a mutation observer microtask</dfn>,
run these steps:

<ol>
 <li><p>If the <a>surrounding agent</a>'s <a>mutation observer microtask queued</a> is true, then
 return.

 <li><p>Set the <a>surrounding agent</a>'s <a>mutation observer microtask queued</a> to true.

 <li><p><a lt="queue a microtask">Queue</a> a <a>microtask</a> to <a>notify mutation observers</a>.
</ol>

<p>To <dfn export>notify mutation observers</dfn>, run these steps:

<ol>
 <li><p>Set the <a>surrounding agent</a>'s <a>mutation observer microtask queued</a> to false.

 <li><p>Let <var>notifySet</var> be a <a for=set>clone</a> of the <a>surrounding agent</a>'s
 <a>mutation observers</a>.

 <li><p>Let <var>signalSet</var> be a <a for=set>clone</a> of the <a>surrounding agent</a>'s
 <a>signal slots</a>.

 <li><p><a for=set>Empty</a> the <a>surrounding agent</a>'s <a>signal slots</a>.

 <li>
  <p><a for=set>For each</a> <var>mo</var> of <var>notifySet</var>:

  <ol>
   <li><p>Let <var>records</var> be a <a for=queue>clone</a> of <var>mo</var>'s
   <a for=MutationObserver>record queue</a>.

   <li><p><a for=queue>Empty</a> <var>mo</var>'s <a for=MutationObserver>record queue</a>.

   <li><p><a for=list>For each</a> <var>node</var> of <var>mo</var>'s
   <a for=MutationObserver>node list</a>, <a for=list>remove</a> all
   <a>transient registered observers</a> whose <a for="registered observer">observer</a> is
   <var>mo</var> from <var>node</var>'s <a>registered observer list</a>.

   <li><p>If <var>records</var> <a for=queue>is not empty</a>, then <a spec=webidl>invoke</a>
   <var>mo</var>'s <a for=MutationObserver>callback</a> with « <var>records</var>, <var>mo</var> »,
   and <var>mo</var>. If this throws an exception, catch it, and <a>report the exception</a>.
  </ol>

 <li><p><a for=set>For each</a> <var>slot</var> of <var>signalSet</var>, <a>fire an event</a> named
 <dfn event for=HTMLSlotElement>slotchange</dfn>, with its {{Event/bubbles}} attribute set to true,
 at <var>slot</var>.
</ol>

<hr>

<p>Each <a for=/>node</a> has a <dfn noexport>registered observer list</dfn> (a <a for=/>list</a> of
zero or more <a>registered observers</a>), which is initially empty.

<p>A <dfn noexport id=registered-observer>registered observer</dfn> consists of an
<dfn noexport for="registered observer">observer</dfn> (a {{MutationObserver}} object) and
<dfn noexport for="registered observer">options</dfn> (a {{MutationObserverInit}} dictionary).

<p>A <dfn noexport id=transient-registered-observer>transient registered observer</dfn> is a
<a>registered observer</a> that also consists of a
<dfn for="transient registered observer">source</dfn> (a <a>registered observer</a>).

<p class=note><a>Transient registered observers</a> are used to track mutations within
a given <a for=/>node</a>'s <a for=tree>descendants</a> after <a for=/>node</a> has been removed so
they do not get lost when {{MutationObserverInit/subtree}} is set to true on <a for=/>node</a>'s
<a for=tree>parent</a>.


<h4 id=interface-mutationobserver>Interface {{MutationObserver}}</h4>

<pre class=idl>
[Exposed=Window]
interface MutationObserver {
  constructor(MutationCallback callback);

  undefined observe(Node target, optional MutationObserverInit options = {});
  undefined disconnect();
  sequence&lt;MutationRecord> takeRecords();
};

callback MutationCallback = undefined (sequence&lt;MutationRecord> mutations, MutationObserver observer);

dictionary MutationObserverInit {
  boolean childList = false;
  boolean attributes;
  boolean characterData;
  boolean subtree = false;
  boolean attributeOldValue;
  boolean characterDataOldValue;
  sequence&lt;DOMString> attributeFilter;
};
</pre>

<p>A {{MutationObserver}} object can be used to observe mutations to the <a>tree</a> of
<a for=/>nodes</a>.

<p>Each {{MutationObserver}} object has these associated concepts:

<ul>
 <li>A <dfn noexport for=MutationObserver id=concept-mo-callback>callback</dfn> set on creation.
 <li>A <dfn noexport for=MutationObserver>node list</dfn> (a <a for=/>list</a> of
 <a for=/>nodes</a>), which is initially empty.
 <li>A <dfn export for=MutationObserver id=concept-mo-queue>record queue</dfn> (a <a for=/>queue</a>
 of zero or more {{MutationRecord}} objects), which is initially empty.
</ul>

<dl class=domintro>
 <dt><code><var>observer</var> = new {{MutationObserver(callback)}}</code>
 <dd>Constructs a {{MutationObserver}} object and sets its <a for=MutationObserver>callback</a> to
 <var>callback</var>. The <var>callback</var> is invoked with a list of {{MutationRecord}} objects
 as first argument and the constructed {{MutationObserver}} object as second argument. It is
 invoked after <a for=/>nodes</a> registered with the {{MutationObserver/observe()}} method, are
 mutated.

 <dt><code><var>observer</var> . {{observe(target, options)}}</code>
 <dd>
  Instructs the user agent to observe a given <var>target</var>
  (a <a for=/>node</a>) and report any mutations based on
  the criteria given by <var>options</var> (an object).

  The <var>options</var> argument allows for setting mutation
  observation options via object members. These are the object members that
  can be used:

  <dl>
   <dt>{{MutationObserverInit/childList}}
   <dd>Set to true if mutations to <var>target</var>'s <a for=tree>children</a> are to be observed.

   <dt>{{MutationObserverInit/attributes}}
   <dd>Set to true if mutations to <var>target</var>'s
   <a>attributes</a> are to be observed. Can be omitted if
   {{MutationObserverInit/attributeOldValue}} or
   {{MutationObserverInit/attributeFilter}} is
   specified.

   <dt>{{MutationObserverInit/characterData}}
   <dd>Set to true if mutations to <var>target</var>'s
   <a for=CharacterData>data</a> are to be observed. Can be omitted if
   {{MutationObserverInit/characterDataOldValue}}
   is specified.

   <dt>{{MutationObserverInit/subtree}}
   <dd>Set to true if mutations to not just <var>target</var>, but
   also <var>target</var>'s
   <a>descendants</a> are to be
   observed.

   <dt>{{MutationObserverInit/attributeOldValue}}
   <dd>Set to true if
   {{MutationObserverInit/attributes}} is true or omitted
   and <var>target</var>'s
   <a>attribute</a>
   <a for=Attr>value</a> before the mutation
   needs to be recorded.

   <dt>{{MutationObserverInit/characterDataOldValue}}
   <dd>Set to true if
   {{MutationObserverInit/characterData}}
   is set to true or omitted and <var>target</var>'s
   <a for=CharacterData>data</a> before the mutation
   needs to be recorded.

   <dt>{{MutationObserverInit/attributeFilter}}
   <dd>Set to a list of <a>attribute</a>
   <a for=Attr>local names</a> (without <a for=Attr>namespace</a>) if not all
   <a>attribute</a> mutations need to be
   observed and {{MutationObserverInit/attributes}} is true
   or omitted.
  </dl>

 <dt><code><var>observer</var> . {{disconnect()}}</code>
 <dd>Stops <var>observer</var> from observing any mutations. Until the {{observe()}} method is used
 again, <var>observer</var>'s <a for=MutationObserver>callback</a> will not be invoked.

 <dt><code><var>observer</var> . {{takeRecords()}}</code>
 <dd>Empties the <a>record queue</a> and
 returns what was in there.
</dl>

<p>The
<dfn constructor for=MutationObserver lt=MutationObserver(callback)><code>new MutationObserver(<var>callback</var>)</code></dfn>
constructor steps are:

<ol>
 <li><p>Set <a>this</a>'s <a for=MutationObserver>callback</a> to <var>callback</var>.

 <li><p><a for=set>Append</a> <a>this</a> to <a>this</a>'s <a>relevant agent</a>'s
 <a>mutation observers</a>.
</ol>

<p>The
<dfn method for=MutationObserver><code>observe(<var>target</var>, <var>options</var>)</code></dfn>
method steps are:

<ol>
 <li><p>If either <var>options</var>["{{MutationObserverInit/attributeOldValue}}"] or
 <var>options</var>["{{MutationObserverInit/attributeFilter}}"] <a for=map>exists</a>, and
 <var>options</var>["{{MutationObserverInit/attributes}}"] does not <a for=map>exist</a>, then set
 <var>options</var>["{{MutationObserverInit/attributes}}"] to true.

 <li><p>If <var>options</var>["{{MutationObserverInit/characterDataOldValue}}"]
 <a for=map>exists</a> and <var>options</var>["{{MutationObserverInit/characterData}}"] does not
 <a for=map>exist</a>, then set <var>options</var>["{{MutationObserverInit/characterData}}"] to
 true.

 <li><p>If none of <var>options</var>["{{MutationObserverInit/childList}}"],
 <var>options</var>["{{MutationObserverInit/attributes}}"], and
 <var>options</var>["{{MutationObserverInit/characterData}}"] is true, then <a>throw</a> a
 <code>TypeError</code>.

 <li><p>If <var>options</var>["{{MutationObserverInit/attributeOldValue}}"] is true and
 <var>options</var>["{{MutationObserverInit/attributes}}"] is false, then <a>throw</a> a
 <code>TypeError</code>.

 <li><p>If <var>options</var>["{{MutationObserverInit/attributeFilter}}"] is present and
 <var>options</var>["{{MutationObserverInit/attributes}}"] is false, then <a>throw</a> a
 <code>TypeError</code>.

 <li><p>If <var>options</var>["{{MutationObserverInit/characterDataOldValue}}"] is true and
 <var>options</var>["{{MutationObserverInit/characterData}}"] is false, then <a>throw</a> a
 <code>TypeError</code>.

 <li>
  <p><a for=list>For each</a> <var>registered</var> of <var>target</var>'s
  <a>registered observer list</a>, if <var>registered</var>'s
  <a for="registered observer">observer</a> is <a>this</a>:

  <ol>
   <li><p><a for=list>For each</a> <var>node</var> of <a>this</a>'s
   <a for=MutationObserver>node list</a>, <a for=list>remove</a> all
   <a>transient registered observers</a> whose <a for="transient registered observer">source</a> is
   <var>registered</var> from <var>node</var>'s <a>registered observer list</a>.

   <li><p>Set <var>registered</var>'s <a for="registered observer">options</a> to
   <var>options</var>.
  </ol>

 <li>
  <p>Otherwise:

  <ol>
   <li><p><a for=list>Append</a> a new <a>registered observer</a> whose
   <a for="registered observer">observer</a> is <a>this</a> and
   <a for="registered observer">options</a> is <var>options</var> to <var>target</var>'s
   <a>registered observer list</a>.

   <li><p><a for=list>Append</a> <var>target</var> to <a>this</a>'s
   <a for=MutationObserver>node list</a>.
  </ol>
</ol>

<p>The <dfn method for=MutationObserver><code>disconnect()</code></dfn> method steps are:

<ol>
 <li><p><a for=list>For each</a> <var>node</var> of <a>this</a>'s
 <a for=MutationObserver>node list</a>, <a for=list>remove</a> any <a>registered observer</a> from
 <var>node</var>'s <a>registered observer list</a> for which <a>this</a> is the
 <a for="registered observer">observer</a>.

 <li><p><a for=queue>Empty</a> <a>this</a>'s <a for=MutationObserver>record queue</a>.
</ol>

<p>The <dfn method for=MutationObserver><code>takeRecords()</code></dfn> method steps are:

<ol>
 <li><p>Let <var>records</var> be a <a for=queue>clone</a> of <a>this</a>'s
 <a for=MutationObserver>record queue</a>.

 <li><p><a for=queue>Empty</a> <a>this</a>'s <a for=MutationObserver>record queue</a>.

 <li><p>Return <var>records</var>.
</ol>


<h4 id=queueing-a-mutation-record>Queuing a mutation record</h4>

<p>To <dfn noexport>queue a mutation record</dfn> of <var>type</var> for <var>target</var> with
<var>name</var>, <var>namespace</var>, <var>oldValue</var>, <var>addedNodes</var>,
<var>removedNodes</var>, <var>previousSibling</var>, and <var>nextSibling</var>, run these steps:

<ol>
 <li><p>Let <var>interestedObservers</var> be an empty <a for=/>map</a>.

 <li><p>Let <var>nodes</var> be the <a for=tree>inclusive ancestors</a> of <var>target</var>.

 <li>
  <p>For each <var>node</var> in <var>nodes</var>, and then <a for=list>for each</a>
  <var>registered</var> of <var>node</var>'s <a>registered observer list</a>:

  <ol>
   <li><p>Let <var>options</var> be <var>registered</var>'s
   <a for="registered observer">options</a>.

   <li>
    <p>If none of the following are true

    <ul class=brief>
     <li><var>node</var> is not <var>target</var> and
     <var>options</var>["{{MutationObserverInit/subtree}}"] is false

     <li><var>type</var> is "<code>attributes</code>" and
     <var>options</var>["{{MutationObserverInit/attributes}}"] either does not <a for=map>exist</a>
     or is false

     <li><var>type</var> is "<code>attributes</code>",
     <var>options</var>["{{MutationObserverInit/attributeFilter}}"] <a for=map>exists</a>, and
     <var>options</var>["{{MutationObserverInit/attributeFilter}}"] does not <a for=list>contain</a>
     <var>name</var> or <var>namespace</var> is non-null

     <li><var>type</var> is "<code>characterData</code>" and
     <var>options</var>["{{MutationObserverInit/characterData}}"] either does not
     <a for=map>exist</a> or is false

     <li><var>type</var> is "<code>childList</code>" and
     <var>options</var>["{{MutationObserverInit/childList}}"] is false
    </ul>

    <p>then:

    <ol>
     <li><p>Let <var>mo</var> be <var>registered</var>'s <a for="registered observer">observer</a>.

     <li><p>If <var>interestedObservers</var>[<var>mo</var>] does not <a for=map>exist</a>, then
     <a for=map>set</a> <var>interestedObservers</var>[<var>mo</var>] to null.

     <li><p>If either <var>type</var> is "<code>attributes</code>" and
     <var>options</var>["{{MutationObserverInit/attributeOldValue}}"] is true, or <var>type</var> is
     "<code>characterData</code>" and
     <var>options</var>["{{MutationObserverInit/characterDataOldValue}}"] is true, then
     <a for=map>set</a> <var>interestedObservers</var>[<var>mo</var>] to <var>oldValue</var>.
    </ol>
  </ol>

 <li>
  <p><a for=map>For each</a> <var>observer</var> → <var>mappedOldValue</var> of
  <var>interestedObservers</var>:

  <ol>
   <li><p>Let <var>record</var> be a new {{MutationRecord}} object with its {{MutationRecord/type}}
   set to <var>type</var>, {{MutationRecord/target}} set to <var>target</var>,
   {{MutationRecord/attributeName}} set to <var>name</var>, {{MutationRecord/attributeNamespace}}
   set to <var>namespace</var>, {{MutationRecord/oldValue}} set to <var>mappedOldValue</var>,
   {{MutationRecord/addedNodes}} set to <var>addedNodes</var>,
   {{MutationRecord/removedNodes}} set to <var>removedNodes</var>,
   {{MutationRecord/previousSibling}} set to <var>previousSibling</var>, and
   {{MutationRecord/nextSibling}} set to <var>nextSibling</var>.

   <li><p><a for=queue>Enqueue</a> <var>record</var> to <var>observer</var>'s
   <a for=MutationObserver>record queue</a>.
  </ol>

 <li><p><a>Queue a mutation observer microtask</a>.
</ol>

<p>To <dfn noexport>queue a tree mutation record</dfn> for <var>target</var> with
<var>addedNodes</var>, <var>removedNodes</var>, <var>previousSibling</var>, and
<var>nextSibling</var>, run these steps:

<ol>
 <li><p>Assert: either <var>addedNodes</var> or <var>removedNodes</var> <a for=set>is not empty</a>.

 <li><p><a>Queue a mutation record</a> of "<code>childList</code>" for <var>target</var> with
 null, null, null, <var>addedNodes</var>, <var>removedNodes</var>, <var>previousSibling</var>,
 and <var>nextSibling</var>.
</ol>


<h4 id=interface-mutationrecord>Interface {{MutationRecord}}</h4>

<pre class=idl>
[Exposed=Window]
interface MutationRecord {
  readonly attribute DOMString type;
  [SameObject] readonly attribute Node target;
  [SameObject] readonly attribute NodeList addedNodes;
  [SameObject] readonly attribute NodeList removedNodes;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;
  readonly attribute DOMString? attributeName;
  readonly attribute DOMString? attributeNamespace;
  readonly attribute DOMString? oldValue;
};
</pre>

<dl class=domintro>
 <dt><code><var>record</var> . {{MutationRecord/type}}</code>
 <dd>Returns "<code>attributes</code>" if it was an
 <a>attribute</a> mutation.
 "<code>characterData</code>" if it was a mutation to a
 {{CharacterData}} <a for=/>node</a>. And
 "<code>childList</code>" if it was a mutation to the
 <a>tree</a> of
 <a for=/>nodes</a>.

 <dt><code><var>record</var> . {{MutationRecord/target}}</code>
 <dd>Returns the <a for=/>node</a> the mutation
 affected, depending on the {{MutationRecord/type}}.
 For "<code>attributes</code>", it is the
 <a for=/>element</a> whose
 <a>attribute</a> changed. For
 "<code>characterData</code>", it is the {{CharacterData}}
 <a for=/>node</a>. For "<code>childList</code>",
 it is the <a for=/>node</a> whose
 <a for=tree>children</a> changed.

 <dt><code><var>record</var> . {{MutationRecord/addedNodes}}</code>
 <dt><code><var>record</var> . {{MutationRecord/removedNodes}}</code>
 <dd>Return the <a for=/>nodes</a> added and removed
 respectively.

 <dt><code><var>record</var> . {{MutationRecord/previousSibling}}</code>
 <dt><code><var>record</var> . {{MutationRecord/nextSibling}}</code>
 <dd>Return the <a lt="previous sibling">previous</a> and <a for=tree>next sibling</a> respectively
 of the added or removed <a for=/>nodes</a>; otherwise null.

 <dt><code><var>record</var> . {{MutationRecord/attributeName}}</code>
 <dd>Returns the <a for=Attr>local name</a> of the changed <a>attribute</a>; otherwise null.

 <dt><code><var>record</var> . {{MutationRecord/attributeNamespace}}</code>
 <dd>Returns the <a for=Attr>namespace</a> of the changed <a>attribute</a>; otherwise null.

 <dt><code><var>record</var> . {{MutationRecord/oldValue}}</code>
 <dd>The return value depends on
 {{MutationRecord/type}}. For
 "<code>attributes</code>", it is the
 <a for=Attr>value</a> of the
 changed <a>attribute</a> before the change.
 For "<code>characterData</code>", it is the
 <a for=CharacterData>data</a> of the changed
 <a for=/>node</a> before the change. For
 "<code>childList</code>", it is null.
</dl>

<p>The <dfn attribute for=MutationRecord>type</dfn>, <dfn attribute for=MutationRecord>target</dfn>,
<dfn attribute for="MutationRecord">addedNodes</dfn>,
<dfn attribute for="MutationRecord">removedNodes</dfn>,
<dfn attribute for="MutationRecord">previousSibling</dfn>,
<dfn attribute for="MutationRecord">nextSibling</dfn>,
<dfn attribute for="MutationRecord">attributeName</dfn>,
<dfn attribute for="MutationRecord">attributeNamespace</dfn>, and
<dfn attribute for="MutationRecord">oldValue</dfn> attributes must return the values they were
initialized to.


<h4 id=garbage-collection>Garbage collection</h4>

<p><a for=/>Nodes</a> have a strong reference to <a>registered observers</a> in their
<a>registered observer list</a>.

<p><a>Registered observers</a> in a <a for=/>node</a>'s <a>registered observer list</a> have a weak
reference to the <a for=/>node</a>.


<h3 id=interface-node>Interface {{Node}}</h3>

<pre class=idl>
[Exposed=Window]
interface Node : EventTarget {
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2;
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4;
  const unsigned short ENTITY_REFERENCE_NODE = 5; // legacy
  const unsigned short ENTITY_NODE = 6; // legacy
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12; // legacy
  readonly attribute unsigned short nodeType;
  readonly attribute DOMString nodeName;

  readonly attribute USVString baseURI;

  readonly attribute boolean isConnected;
  readonly attribute Document? ownerDocument;
  Node getRootNode(optional GetRootNodeOptions options = {});
  readonly attribute Node? parentNode;
  readonly attribute Element? parentElement;
  boolean hasChildNodes();
  [SameObject] readonly attribute NodeList childNodes;
  readonly attribute Node? firstChild;
  readonly attribute Node? lastChild;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;

  [CEReactions] attribute DOMString? nodeValue;
  [CEReactions] attribute DOMString? textContent;
  [CEReactions] undefined normalize();

  [CEReactions, NewObject] Node cloneNode(optional boolean deep = false);
  boolean isEqualNode(Node? otherNode);
  boolean isSameNode(Node? otherNode); // legacy alias of ===

  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  unsigned short compareDocumentPosition(Node other);
  boolean contains(Node? other);

  DOMString? lookupPrefix(DOMString? namespace);
  DOMString? lookupNamespaceURI(DOMString? prefix);
  boolean isDefaultNamespace(DOMString? namespace);

  [CEReactions] Node insertBefore(Node node, Node? child);
  [CEReactions] Node appendChild(Node node);
  [CEReactions] Node replaceChild(Node node, Node child);
  [CEReactions] Node removeChild(Node child);
};

dictionary GetRootNodeOptions {
  boolean composed = false;
};
</pre>

<p class=note>{{Node}} is an abstract interface that is used by all <a for=/>nodes</a>. You cannot
get a direct instance of it.

<p>Each <a for=/>node</a> has an associated
<dfn export for=Node id=concept-node-document>node document</dfn>, set upon creation, that is a
<a>document</a>.

<p class=note>A <a for=/>node</a>'s <a for=Node>node document</a> can be changed by the
<a>adopt</a> algorithm.

<p>A <a for=/>node</a>'s <a>get the parent</a> algorithm, given an <var>event</var>, returns the
<a for=/>node</a>'s <a>assigned slot</a>, if <a for=/>node</a> is <a>assigned</a>; otherwise
<a for=/>node</a>'s <a for=tree>parent</a>.

<p class=note>Each <a for=/>node</a> also has a <a>registered observer list</a>.

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . {{Node/nodeType}}</code>
 <dd>
  <p>Returns a number appropriate for the type of <var>node</var>, as follows:

  <dl>
   <dt>{{Element}}
   <dd><code>{{Node}} . {{Node/ELEMENT_NODE}}</code> (1).

   <dt>{{Attr}}
   <dd><code>{{Node}} . {{Node/ATTRIBUTE_NODE}}</code> (2).

   <dt>An <a>exclusive <code>Text</code> node</a>
   <dd><code>{{Node}} . {{Node/TEXT_NODE}}</code> (3).

   <dt>{{CDATASection}}
   <dd><code>{{Node}} . {{Node/CDATA_SECTION_NODE}}</code> (4).

   <dt>{{ProcessingInstruction}}
   <dd><code>{{Node}} . {{Node/PROCESSING_INSTRUCTION_NODE}}</code> (7).

   <dt>{{Comment}}
   <dd><code>{{Node}} . {{Node/COMMENT_NODE}}</code> (8).

   <dt>{{Document}}
   <dd><code>{{Node}} . {{Node/DOCUMENT_NODE}}</code> (9).

   <dt>{{DocumentType}}
   <dd><code>{{Node}} . {{Node/DOCUMENT_TYPE_NODE}}</code> (10).

   <dt>{{DocumentFragment}}
   <dd><code>{{Node}} . {{Node/DOCUMENT_FRAGMENT_NODE}}</code> (11).
  </dl>

 <dt><code><var>node</var> . {{Node/nodeName}}</code>
 <dd>
  <p>Returns a string appropriate for the type of <var>node</var>, as follows:

  <dl>
   <dt>{{Element}}
   <dd>Its <a for=Element>HTML-uppercased qualified name</a>.

   <dt>{{Attr}}
   <dd>Its <a for=Attr>qualified name</a>.

   <dt>An <a>exclusive <code>Text</code> node</a>
   <dd>"<code>#text</code>".

   <dt>{{CDATASection}}
   <dd>"<code>#cdata-section</code>".

   <dt>{{ProcessingInstruction}}
   <dd>Its <a for=ProcessingInstruction>target</a>.

   <dt>{{Comment}}
   <dd>"<code>#comment</code>".

   <dt>{{Document}}
   <dd>"<code>#document</code>".

   <dt>{{DocumentType}}
   <dd>Its <a for=DocumentType>name</a>.

   <dt>{{DocumentFragment}}
   <dd>"<code>#document-fragment</code>".
  </dl>
</dl>

<p>The <dfn attribute for=Node>nodeType</dfn> getter steps are to return the first matching
statement, switching on the interface <a>this</a> <a>implements</a>:

<dl class=switch>
 <dt>{{Element}}
 <dd><dfn const for=Node>ELEMENT_NODE</dfn> (1)

 <dt>{{Attr}}
 <dd><dfn const for=Node>ATTRIBUTE_NODE</dfn> (2);

 <dt>An <a>exclusive <code>Text</code> node</a>
 <dd><dfn const for=Node>TEXT_NODE</dfn> (3);

 <dt>{{CDATASection}}
 <dd><dfn const for=Node>CDATA_SECTION_NODE</dfn> (4);

 <dt>{{ProcessingInstruction}}
 <dd><dfn const for=Node>PROCESSING_INSTRUCTION_NODE</dfn> (7);

 <dt>{{Comment}}
 <dd><dfn const for=Node>COMMENT_NODE</dfn> (8);

 <dt>{{Document}}
 <dd><dfn const for=Node>DOCUMENT_NODE</dfn> (9);

 <dt>{{DocumentType}}
 <dd><dfn const for=Node>DOCUMENT_TYPE_NODE</dfn> (10);

 <dt>{{DocumentFragment}}
 <dd><dfn const for=Node>DOCUMENT_FRAGMENT_NODE</dfn> (11).
</dl>

<p>The <dfn attribute for=Node>nodeName</dfn> getter steps are to return the first matching
statement, switching on the interface <a>this</a> <a>implements</a>:

<dl class=switch>
 <dt>{{Element}}
 <dd>Its <a for=Element>HTML-uppercased qualified name</a>.

 <dt>{{Attr}}
 <dd>Its <a for=Attr>qualified name</a>.

 <dt>An <a>exclusive <code>Text</code> node</a>
 <dd>"<code>#text</code>".

 <dt>{{CDATASection}}
 <dd>"<code>#cdata-section</code>".

 <dt>{{ProcessingInstruction}}
 <dd>Its <a for=ProcessingInstruction>target</a>.

 <dt>{{Comment}}
 <dd>"<code>#comment</code>".

 <dt>{{Document}}
 <dd>"<code>#document</code>".

 <dt>{{DocumentType}}
 <dd>Its <a for=DocumentType>name</a>.

 <dt>{{DocumentFragment}}
 <dd>"<code>#document-fragment</code>".
</dl>

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . {{Node/baseURI}}</code>
 <dd>Returns <var>node</var>'s <a for=Node>node document</a>'s <a>document base URL</a>.
</dl>

<p>The <dfn attribute for=Node><code>baseURI</code></dfn> getter steps are to return <a>this</a>'s
<a for=Node>node document</a>'s <a>document base URL</a>, <a lt="URL serializer" spec=url>serialized</a>.

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . {{Node/isConnected}}</code>
 <dd><p>Returns true if <var>node</var> is <a>connected</a>; otherwise false.

 <dt><code><var>node</var> . {{Node/ownerDocument}}</code>
 <dd>
  Returns the <a for=Node>node document</a>.
  Returns null for <a>documents</a>.

 <dt><code><var>node</var> . {{Node/getRootNode()}}</code>
 <dd>Returns <var>node</var>'s <a for=tree>root</a>.

 <dt><code><var>node</var> . <a idl lt=getRootNode()>getRootNode</a>({ composed:true })</code>
 <dd>Returns <var>node</var>'s <a>shadow-including root</a>.

 <dt><code><var>node</var> . {{Node/parentNode}}</code>
 <dd>Returns the <a for=tree>parent</a>.

 <dt><code><var>node</var> . {{Node/parentElement}}</code>
 <dd>Returns the <a>parent element</a>.

 <dt><code><var>node</var> . {{Node/hasChildNodes()}}</code>
 <dd>Returns whether <var>node</var> has
 <a for=tree>children</a>.

 <dt><code><var>node</var> . {{Node/childNodes}}</code>
 <dd>Returns the <a for=tree>children</a>.

 <dt><code><var>node</var> . {{Node/firstChild}}</code>
 <dd>Returns the <a for=tree>first child</a>.

 <dt><code><var>node</var> . {{Node/lastChild}}</code>
 <dd>Returns the <a>last child</a>.

 <dt><code><var>node</var> . {{Node/previousSibling}}</code>
 <dd>Returns the
 <a>previous sibling</a>.

 <dt><code><var>node</var> . {{Node/nextSibling}}</code>
 <dd>Returns the
 <a for=tree>next sibling</a>.
</dl>

<p>The <dfn attribute for=Node><code>isConnected</code></dfn> getter steps are to return true,
if <a>this</a> is <a>connected</a>; otherwise false.</p>

<p>The <dfn attribute for=Node><code>ownerDocument</code></dfn> getter steps are to return null,
if <a>this</a> is a <a>document</a>; otherwise <a>this</a>'s <a for=Node>node document</a>.

<p class=note>The <a for=Node>node document</a> of a <a>document</a> is that <a>document</a> itself.
All <a for=/>nodes</a> have a <a for=Node>node document</a> at all times.

<p>The <dfn method for=Node><code>getRootNode(<var>options</var>)</code></dfn> method steps are to
return <a>this</a>'s <a>shadow-including root</a> if
<var>options</var>["{{GetRootNodeOptions/composed}}"] is true; otherwise <a>this</a>'s
<a for=tree>root</a>.

<p>The <dfn attribute for=Node><code>parentNode</code></dfn> getter steps are to return
<a>this</a>'s <a for=tree>parent</a>.

<p>The <dfn attribute for=Node><code>parentElement</code></dfn> getter steps are to return
<a>this</a>'s <a>parent element</a>.

<p>The <dfn method for=Node><code>hasChildNodes()</code></dfn> method steps are to return true if
<a>this</a> has <a for=tree>children</a>; otherwise false.

<p>The <dfn attribute for=Node><code>childNodes</code></dfn> getter steps are to return a
{{NodeList}} rooted at <a>this</a> matching only <a for=tree>children</a>.

<p>The <dfn attribute for=Node><code>firstChild</code> </dfn> getter steps are to return
<a>this</a>'s <a for=tree>first child</a>.

<p>The <dfn attribute for=Node><code>lastChild</code></dfn> getter steps are to return <a>this</a>'s
<a>last child</a>.

<p>The <dfn attribute for=Node><code>previousSibling</code></dfn> getter steps are to return
<a>this</a>'s <a>previous sibling</a>.

<p>The <dfn attribute for=Node><code>nextSibling</code></dfn> getter steps are to return
<a>this</a>'s <a for=tree>next sibling</a>.

<hr>

<!-- TODO: domintro -->

<p>The <dfn attribute for=Node>nodeValue</dfn> getter steps are to return the following, switching
on the interface <a>this</a> <a>implements</a>:

<dl class=switch>
 <dt>{{Attr}}
 <dd><a>this</a>'s <a for=Attr>value</a>.

 <dt>{{CharacterData}}
 <dd><a>this</a>'s <a for=CharacterData>data</a>.

 <dt>Otherwise
 <dd>Null.
</dl>

<p>The {{Node/nodeValue}} setter steps are to, if the given value is null, act as if it was the
empty string instead, and then do as described below, switching on the interface <a>this</a>
<a>implements</a>:

<dl class=switch>
 <dt>{{Attr}}
 <dd><p><a>Set an existing attribute value</a> with <a>this</a> and the given value.

 <dt>{{CharacterData}}
 <dd><p><a>Replace data</a> with node <a>this</a>, offset 0, count <a>this</a>'s
 <a for=Node>length</a>, and data the given value.

 <dt>Otherwise
 <dd><p>Do nothing.
</dl>

<p>The <dfn attribute for=Node><code>textContent</code></dfn> getter steps are to return the
following, switching on the interface <a>this</a> <a>implements</a>:

<dl class=switch>
 <dt>{{DocumentFragment}}
 <dt>{{Element}}
 <dd>The <a>descendant text content</a> of <a>this</a>.

 <dt>{{Attr}}
 <dd><a>this</a>'s <a for=Attr>value</a>.

 <dt>{{CharacterData}}
 <dd><a>this</a>'s <a for=CharacterData>data</a>.

 <dt>Otherwise
 <dd>Null.
</dl>

<p>To <dfn export>string replace all</dfn> with a string <var>string</var> within a
<a for=/>node</a> <var>parent</var>, run these steps:

<ol>
 <li><p>Let <var>node</var> be null.

 <li><p>If <var>string</var> is not the empty string, then set <var>node</var> to a new {{Text}}
 <a for=/>node</a> whose <a for=CharacterData>data</a> is <var>string</var> and
 <a for=Node>node document</a> is <var>parent</var>'s <a for=Node>node document</a>.

 <li><p><a for=Node>Replace all</a> with <var>node</var> within <var>parent</var>.
</ol>

<p>The {{Node/textContent}} setter steps are to, if the given value is null, act as if it was the
empty string instead, and then do as described below, switching on the interface <a>this</a>
<a>implements</a>:

<dl class=switch>
 <dt>{{DocumentFragment}}
 <dt>{{Element}}
 <dd><p><a>String replace all</a> with the given value within <a>this</a>.

 <dt>{{Attr}}
 <dd><p><a>Set an existing attribute value</a> with <a>this</a> and the given value.

 <dt>{{CharacterData}}
 <dd><p><a>Replace data</a> with node <a>this</a>, offset 0, count <a>this</a>'s
 <a for=Node>length</a>, and data the given value.

 <dt>Otherwise
 <dd><p>Do nothing.
</dl>

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . {{Node/normalize()}}</code>
 <dd>Removes <a for=Node>empty</a> <a>exclusive <code>Text</code> nodes</a> and concatenates the
 <a for=CharacterData>data</a> of remaining <a>contiguous exclusive <code>Text</code> nodes</a>
 into the first of their <a for=/>nodes</a>.
</dl>

<p>The <dfn method for=Node><code>normalize()</code></dfn> method steps are to run these steps for
each <a>descendant</a> <a>exclusive <code>Text</code> node</a> <var>node</var> of <a>this</a>:

<ol>
 <li>Let <var>length</var> be <var>node</var>'s <a for=Node>length</a>.

 <li>If <var>length</var> is zero, then <a for=/>remove</a> <var>node</var> and continue with the
 next <a>exclusive <code>Text</code> node</a>, if any.

 <li>Let <var>data</var> be the <a for=string>concatenation</a> of the <a for=CharacterData>data</a>
 of <var>node</var>'s <a>contiguous exclusive <code>Text</code> nodes</a> (excluding itself), in
 <a>tree order</a>.

 <li><a>Replace data</a> with node <var>node</var>, offset <var>length</var>, count 0, and data
 <var>data</var>.

 <li>Let <var>currentNode</var> be <var>node</var>'s <a for=tree>next sibling</a>.

 <li>
  <p>While <var>currentNode</var> is an <a>exclusive <code>Text</code> node</a>:

  <ol>
   <li><p>For each <a>live range</a> whose <a for=range>start node</a> is <var>currentNode</var>,
   add <var>length</var> to its <a for=range>start offset</a> and set its
   <a for=range>start node</a> to <var>node</var>.

   <li><p>For each <a>live range</a> whose <a for=range>end node</a> is <var>currentNode</var>, add
   <var>length</var> to its <a for=range>end offset</a> and set its <a for=range>end node</a> to
   <var>node</var>.

   <li><p>For each <a>live range</a> whose <a for=range>start node</a> is <var>currentNode</var>'s
   <a for=tree>parent</a> and <a for=range>start offset</a> is <var>currentNode</var>'s
   <a for=tree>index</a>, set its <a for=range>start node</a> to <var>node</var> and its
   <a for=range>start offset</a> to <var>length</var>.

   <li><p>For each <a>live range</a> whose <a for=range>end node</a> is <var>currentNode</var>'s
   <a for=tree>parent</a> and <a for=range>end offset</a> is <var>currentNode</var>'s
   <a for=tree>index</a>, set its <a for=range>end node</a> to <var>node</var> and its
   <a for=range>end offset</a> to <var>length</var>.

   <li><p>Add <var>currentNode</var>'s <a for=Node>length</a> to <var>length</var>.

   <li><p>Set <var>currentNode</var> to its <a for=tree>next sibling</a>.
  </ol>

 <li><a for=/>Remove</a> <var>node</var>'s <a>contiguous exclusive <code>Text</code> nodes</a>
 (excluding itself), in <a>tree order</a>.
</ol>

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . <a method for=Node lt=cloneNode()>cloneNode([<var>deep</var> = false])</a></code>
 <dd>Returns a copy of <var>node</var>. If
 <var>deep</var> is true, the copy also includes the
 <var>node</var>'s <a>descendants</a>.

 <dt><code><var>node</var> . {{Node/isEqualNode(otherNode)}}</code>
 <dd>Returns whether <var>node</var> and <var>otherNode</var>
 have the same properties.
</dl>

<div class=impl>

<a lt="Other applicable specifications">Specifications</a> may define
<dfn export id=concept-node-clone-ext>cloning steps</dfn> for all or some <a for=/>nodes</a>. The
algorithm is passed <var>copy</var>, <var>node</var>, <var>document</var>, and an optional
<i>clone children flag</i>, as indicated in the <a lt="clone a node">clone</a> algorithm.

<p class=note>HTML defines <a>cloning steps</a> for <{script}> and <{input}>
elements. SVG ought to do the same for its <{script}> elements, but does not call this out
at the moment.

<p>To <dfn export id=concept-node-clone lt="clone a node" local-lt="clone">clone</dfn> a
<var>node</var>, with an optional <var>document</var> and <i>clone children flag</i>, run these
steps:
<!-- This algorithm is used by dom-Node-cloneNode, dom-Document-importNode,
dom-Range-extractContents, dom-Range-cloneContents -->

<ol>
 <li><p>If <var>document</var> is not given, let <var>document</var> be <var>node</var>'s
 <a for=Node>node document</a>.

 <li>
  <p>If <var>node</var> is an <a for=/>element</a>, then:

  <ol>
   <li><p>Let <var>copy</var> be the result of <a>creating an element</a>, given
   <var>document</var>, <var>node</var>'s <a for=Element>local name</a>, <var>node</var>'s
   <a for=Element>namespace</a>, <var>node</var>'s <a for=Element>namespace prefix</a>, and
   <var>node</var>'s <a><code>is</code> value</a>, with the <var>synchronous custom elements
   flag</var> unset.

   <li>
    <p><a for=list>For each</a> <var>attribute</var> in <var>node</var>'s
    <a for=Element>attribute list</a>:

    <ol>
     <li><p>Let <var>copyAttribute</var> be a <a>clone</a> of <var>attribute</var>.

     <li><p><a lt="append an attribute">Append</a> <var>copyAttribute</var> to <var>copy</var>.
    </ol>
   </li>
  </ol>
 </li>

 <li>
  <p>Otherwise, let <var>copy</var> be a <a for=/>node</a> that <a>implements</a> the same
  interfaces as <var>node</var>, and fulfills these additional requirements, switching on the
  interface <var>node</var> <a>implements</a>:

  <dl class=switch>
   <dt>{{Document}}
   <dd><p>Set <var>copy</var>'s <a for=Document>encoding</a>, <a for=Document>content type</a>,
   <a for=Document>URL</a>, <a for=Document>origin</a>, <a for=Document>type</a>, and
   <a for=Document>mode</a> to those of <var>node</var>.

   <dt>{{DocumentType}}
   <dd><p>Set <var>copy</var>'s <a for=DocumentType>name</a>, <a>public ID</a>, and
   <a>system ID</a> to those of <var>node</var>.

   <dt>{{Attr}}
   <dd><p>Set <var>copy</var>'s <a for=Attr>namespace</a>, <a for=Attr>namespace prefix</a>,
   <a for=Attr>local name</a>, and <a for=Attr>value</a> to those of <var>node</var>.

   <dt>{{Text}}
   <dt>{{Comment}}
   <dd><p>Set <var>copy</var>'s <a for=CharacterData>data</a> to that of <var>node</var>.

   <dt>{{ProcessingInstruction}}
   <dd><p>Set <var>copy</var>'s <a for=ProcessingInstruction>target</a> and
   <a for=CharacterData>data</a> to those of <var>node</var>.

   <dt>Otherwise
   <dd><p>Do nothing.
  </dl>

 <li><p>Set <var>copy</var>'s <a for=Node>node document</a> and <var>document</var> to
 <var>copy</var>, if <var>copy</var> is a <a>document</a>, and set <var>copy</var>'s
 <a for=Node>node document</a> to <var>document</var> otherwise.

 <li>Run any <a>cloning steps</a> defined for <var>node</var> in
 <a>other applicable specifications</a> and pass <var>copy</var>, <var>node</var>,
 <var>document</var> and the <i>clone children flag</i> if set, as parameters.

 <li>If the <i>clone children flag</i> is set, <a lt="clone a node">clone</a> all the
 <a for=tree>children</a> of <var>node</var> and append them to <var>copy</var>, with
 <var>document</var> as specified and the <i>clone children flag</i> being set.

 <li>Return <var>copy</var>.
</ol>

<p>The <dfn method for=Node><code>cloneNode(<var>deep</var>)</code></dfn> method steps are:

<ol>
 <li><p>If <a>this</a> is a <a for=/>shadow root</a>, then <a>throw</a> a
 "{{NotSupportedError!!exception}}" {{DOMException}}.

 <li><p>Return a <a lt="clone a node">clone</a> of <a>this</a>, with the
 <i>clone children flag</i> set if <var>deep</var> is true.
</ol>

<p>A <a for=/>node</a> <var>A</var> <dfn export for=Node id=concept-node-equals>equals</dfn> a
<a for=/>node</a> <var>B</var> if all of the following conditions are true:

<ul>
 <li><p><var>A</var> and <var>B</var> <a>implement</a> the same interfaces.

 <li>
  <p>The following are equal, switching on the interface <var>A</var> <a>implements</a>:

  <dl class=switch>
   <dt>{{DocumentType}}
   <dd>Its <a for=DocumentType>name</a>, <a>public ID</a>, and <a>system ID</a>.

   <dt>{{Element}}
   <dd>Its <a for=Element>namespace</a>, <a for=Element>namespace prefix</a>,
   <a for=Element>local name</a>, and its <a for=Element>attribute list</a>'s <a for=list>size</a>.

   <dt>{{Attr}}
   <dd>Its <a for=Attr>namespace</a>, <a for=Attr>local name</a>, and <a for=Attr>value</a>.

   <dt>{{ProcessingInstruction}}
   <dd>Its <a for=ProcessingInstruction>target</a> and <a for=CharacterData>data</a>.

   <dt>{{Text}}
   <dt>{{Comment}}
   <dd>Its <a for=CharacterData>data</a>.

   <dt>Otherwise
   <dd>&mdash;
  </dl>

 <li><p>If <var>A</var> is an <a for=/>element</a>, each <a>attribute</a> in its
 <a for=Element>attribute list</a> has an <a>attribute</a> that <a for=Node>equals</a> an
 <a>attribute</a> in <var>B</var>'s <a for=Element>attribute list</a>.

 <li><p><var>A</var> and <var>B</var> have the same number of <a for=tree>children</a>.

 <li><p>Each <a for=tree>child</a> of <var>A</var> <a for=Node>equals</a> the <a for=tree>child</a>
 of <var>B</var> at the identical <a for=tree>index</a>.
</ul>

<p>The <dfn method for=Node><code>isEqualNode(<var>otherNode</var>)</code></dfn> method steps are to
return true if <var>otherNode</var> is non-null and <a>this</a> <a for=Node>equals</a>
<var>otherNode</var>; otherwise false.

<p>The <dfn method for=Node><code>isSameNode(<var>otherNode</var>)</code></dfn> method steps are to
return true if <var>otherNode</var> is <a>this</a>; otherwise false.

</div>

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . {{compareDocumentPosition(other)}}</code>
 <dd>
  Returns a bitmask indicating the position of <var>other</var>
  relative to <var>node</var>. These are the bits that can be set:

  <dl>
   <dt><code>{{Node}} . {{Node/DOCUMENT_POSITION_DISCONNECTED}}</code> (1)
   <dd>Set when <var>node</var> and <var>other</var> are not in the
   same <a>tree</a>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_POSITION_PRECEDING}}</code> (2)
   <dd>Set when <var>other</var> is
   <a>preceding</a>
   <var>node</var>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_POSITION_FOLLOWING}}</code> (4)
   <dd>Set when <var>other</var> is
   <a>following</a>
   <var>node</var>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_POSITION_CONTAINS}}</code> (8)
   <dd>Set when <var>other</var> is an
   <a>ancestor</a> of
   <var>node</var>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_POSITION_CONTAINED_BY}}</code> (16, 10 in hexadecimal)
   <dd>Set when <var>other</var> is a
   <a>descendant</a> of
   <var>node</var>.
  </dl>

 <dt><code><var>node</var> . {{Node/contains(other)}}</code>
 <dd>Returns true if <var>other</var> is an <a>inclusive descendant</a> of <var>node</var>;
 otherwise false.
</dl>

<p>These are the constants {{compareDocumentPosition()}} returns as mask:

<ul class=brief>
 <li><dfn const for=Node>DOCUMENT_POSITION_DISCONNECTED</dfn> (1);
 <li><dfn const for=Node>DOCUMENT_POSITION_PRECEDING</dfn> (2);
 <li><dfn const for=Node>DOCUMENT_POSITION_FOLLOWING</dfn> (4);
 <li><dfn const for=Node>DOCUMENT_POSITION_CONTAINS</dfn> (8);
 <li><dfn const for=Node>DOCUMENT_POSITION_CONTAINED_BY</dfn> (16, 10 in hexadecimal);
 <li><dfn const for=Node>DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</dfn> (32, 20 in hexadecimal).
</ul>

<p>The <dfn method for=Node><code>compareDocumentPosition(<var>other</var>)</code></dfn> method
steps are:

<ol>
 <li><p>If <a>this</a> is <var>other</var>, then return zero.

 <li><p>Let <var>node1</var> be <var>other</var> and <var>node2</var> be <a>this</a>.

 <li><p>Let <var>attr1</var> and <var>attr2</var> be null.

 <li><p>If <var>node1</var> is an <a>attribute</a>, then set <var>attr1</var> to <var>node1</var>
 and <var>node1</var> to <var>attr1</var>'s <a for=Attr>element</a>.

 <li>
  <p>If <var>node2</var> is an <a>attribute</a>, then:

  <ol>
   <li><p>Set <var>attr2</var> to <var>node2</var> and <var>node2</var> to <var>attr2</var>'s
   <a for=Attr>element</a>.

   <li>
    <p>If <var>attr1</var> and <var>node1</var> are non-null, and <var>node2</var> is
    <var>node1</var>, then:

    <ol>
     <li>
      <p><a for=list>For each</a> <var>attr</var> in <var>node2</var>'s
      <a for=Element>attribute list</a>:

      <ol>
       <li><p>If <var>attr</var> <a for=Node>equals</a> <var>attr1</var>, then return the result of
       adding {{Node/DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}} and
       {{Node/DOCUMENT_POSITION_PRECEDING}}.

       <li><p>If <var>attr</var> <a for=Node>equals</a> <var>attr2</var>, then return the result of
       adding {{Node/DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}} and
       {{Node/DOCUMENT_POSITION_FOLLOWING}}.
      </ol>
    </ol>
  </ol>

 <li>
  <p>If <var>node1</var> or <var>node2</var> is null, or <var>node1</var>'s <a for=tree>root</a> is
  not <var>node2</var>'s <a for=tree>root</a>, then return the result of adding
  {{Node/DOCUMENT_POSITION_DISCONNECTED}}, {{Node/DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}}, and
  either {{Node/DOCUMENT_POSITION_PRECEDING}} or {{Node/DOCUMENT_POSITION_FOLLOWING}}, with the
  constraint that this is to be consistent, together.

  <p class=note>Whether to return {{Node/DOCUMENT_POSITION_PRECEDING}} or
  {{Node/DOCUMENT_POSITION_FOLLOWING}} is typically implemented via pointer comparison. In
  JavaScript implementations a cached <code class=lang-javascript>Math.random()</code> value can
  be used.

 <li><p>If <var>node1</var> is an <a>ancestor</a> of <var>node2</var> and <var>attr1</var> is null,
 or <var>node1</var> is <var>node2</var> and <var>attr2</var> is non-null, then return the result of
 adding {{Node/DOCUMENT_POSITION_CONTAINS}} to {{Node/DOCUMENT_POSITION_PRECEDING}}.

 <li><p>If <var>node1</var> is a <a>descendant</a> of <var>node2</var> and <var>attr2</var> is null,
 or <var>node1</var> is <var>node2</var> and <var>attr1</var> is non-null, then return the result of
 adding {{Node/DOCUMENT_POSITION_CONTAINED_BY}} to {{Node/DOCUMENT_POSITION_FOLLOWING}}.

 <li>
  <p>If <var>node1</var> is <a>preceding</a> <var>node2</var>, then return
  {{Node/DOCUMENT_POSITION_PRECEDING}}.

  <p class=note>Due to the way <a>attributes</a> are handled in this algorithm this results in a
  <a for=/>node</a>'s <a>attributes</a> counting as <a>preceding</a> that <a for=/>node</a>'s
  <a for=tree>children</a>, despite <a>attributes</a> not <a>participating</a> in the same
  <a>tree</a>.

 <li><p>Return {{Node/DOCUMENT_POSITION_FOLLOWING}}.
</ol>

<p>The <dfn method for=Node><code>contains(<var>other</var>)</code></dfn> method steps are to return
true if <var>other</var> is an <a>inclusive descendant</a> of <a>this</a>; otherwise false
(including when <var>other</var> is null).

<hr>

<!-- TODO: domintro -->

<!--
 XXX apparently these algorithms might not be quite correct
 https://bugzilla.mozilla.org/show_bug.cgi?id=312019
 https://bugzilla.mozilla.org/show_bug.cgi?id=505178
-->

<p>To
<dfn export lt="locate a namespace prefix|locating a namespace prefix">locate a namespace prefix</dfn>
for an <var>element</var> using <var>namespace</var>, run these steps:

<ol>
 <li><p>If <var>element</var>'s <a for=Element>namespace</a> is <var>namespace</var> and its
 <a for=Element>namespace prefix</a> is non-null, then return its
 <a for=Element>namespace prefix</a>.

 <li><p>If <var>element</var> <a lt="has an attribute">has</a> an <a>attribute</a> whose
 <a for=Attr>namespace prefix</a> is "<code>xmlns</code>" and <a for=Attr>value</a> is
 <var>namespace</var>, then return <var>element</var>'s first such <a>attribute</a>'s
 <a for=Attr>local name</a>.

 <li><p>If <var>element</var>'s <a>parent element</a> is not null, then return the result of running
 <a>locate a namespace prefix</a> on that <a for=/>element</a> using <var>namespace</var>.

 <li><p>Return null.
</ol>

<p>To <dfn export>locate a namespace</dfn> for a <var>node</var> using <var>prefix</var>, switch on
the interface <var>node</var> <a>implements</a>:

<dl class=switch>
 <dt>{{Element}}
 <dd>
  <ol>
   <li><p>If its <a for=Element>namespace</a> is non-null and its
   <a for=Element>namespace prefix</a> is <var>prefix</var>, then return
   <a for=Element>namespace</a>.

   <li><p>If it <a lt="has an attribute">has</a> an <a>attribute</a> whose <a for=Attr>namespace</a>
   is the <a>XMLNS namespace</a>, <a for=Attr>namespace prefix</a> is "<code>xmlns</code>", and
   <a for=Attr>local name</a> is <var>prefix</var>, or if <var>prefix</var> is null and it
   <a lt="has an attribute">has</a> an <a>attribute</a> whose <a for=Attr>namespace</a> is the
   <a>XMLNS namespace</a>, <a for=Attr>namespace prefix</a> is null, and <a for=Attr>local name</a>
   is "<code>xmlns</code>", then return its <a for=Attr>value</a> if it is not the empty string, and
   null otherwise.

   <li><p>If its <a>parent element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a>parent element</a> using
   <var>prefix</var>.
  </ol>

 <dt>{{Document}}
 <dd>
  <ol>
   <li><p>If its <a>document element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a>document element</a>
   using <var>prefix</var>.
  </ol>

 <dt>{{DocumentType}}
 <dt>{{DocumentFragment}}
 <dd><p>Return null.

 <dt>{{Attr}}
 <dd>
  <ol>
   <li><p>If its <a for=Attr>element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a for=Attr>element</a>
   using <var>prefix</var>.
  </ol>

 <dt>Otherwise
 <dd>
  <ol>
   <li><p>If its <a>parent element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a>parent element</a> using
   <var>prefix</var>.
  </ol>
</dl>

<p>The <dfn method for=Node><code>lookupPrefix(<var>namespace</var>)</code></dfn> method steps are:

<ol>
 <li><p>If <var>namespace</var> is null or the empty string, then return null.

 <li>
  <p>Switch on the interface <a>this</a> <a>implements</a>:

  <dl class=switch>
   <dt>{{Element}}
   <dd><p>Return the result of <a>locating a namespace prefix</a> for it using <var>namespace</var>.

   <dt>{{Document}}
   <dd><p>Return the result of <a>locating a namespace prefix</a> for its <a>document element</a>,
   if its <a>document element</a> is non-null; otherwise null.

   <dt>{{DocumentType}}
   <dt>{{DocumentFragment}}
   <dd><p>Return null.

   <dt>{{Attr}}
   <dd><p>Return the result of <a>locating a namespace prefix</a> for its <a for=Attr>element</a>,
   if its <a for=Attr>element</a> is non-null; otherwise null.

   <dt>Otherwise
   <dd><p>Return the result of <a>locating a namespace prefix</a> for its <a>parent element</a>, if
   its <a>parent element</a> is non-null; otherwise null.
  </dl>
</ol>

<p>The <dfn method for=Node><code>lookupNamespaceURI(<var>prefix</var>)</code></dfn> method steps
are:

<ol>
 <li><p>If <var>prefix</var> is the empty string, then set it to null.

 <li><p>Return the result of running <a>locate a namespace</a> for <a>this</a> using
 <var>prefix</var>.
</ol>

<p>The <dfn method for=Node><code>isDefaultNamespace(<var>namespace</var>)</code></dfn> method steps
are:

<ol>
 <li><p>If <var>namespace</var> is the empty string, then set it to null.

 <li><p>Let <var>defaultNamespace</var> be the result of running <a>locate a namespace</a> for
 <a>this</a> using null.

 <li><p>Return true if <var>defaultNamespace</var> is the same as <var>namespace</var>; otherwise
 false.
</ol>

<hr>

<p>The <dfn method for=Node><code>insertBefore(<var>node</var>, <var>child</var>)</code></dfn>
method steps are to return the result of <a>pre-inserting</a> <var>node</var> into <a>this</a>
before <var>child</var>.

<p>The <dfn method for=Node><code>appendChild(<var>node</var>)</code></dfn> method steps are to
return the result of <a>appending</a> <var>node</var> to <a>this</a>.

<p>The <dfn method for=Node><code>replaceChild(<var>node</var>, <var>child</var>)</code></dfn>
method steps are to return the result of <a>replacing</a> <var>child</var> with <var>node</var>
within <a>this</a>.

<p>The <dfn method for=Node><code>removeChild(<var>child</var>)</code></dfn> method steps are to
return the result of <a>pre-removing</a> <var>child</var> from <a>this</a>.

<hr><!-- Collections -->

<p>The
<dfn export id=concept-getelementsbytagname>list of elements with qualified name <var>qualifiedName</var></dfn>
for a <a for=/>node</a> <var>root</var> is the {{HTMLCollection}} returned by the following
algorithm:

<ol>
 <li><p>If <var>qualifiedName</var> is U+002A (*), then return a {{HTMLCollection}} rooted at
 <var>root</var>, whose filter matches only <a>descendant</a> <a for=/>elements</a>.

 <li>
  <p>Otherwise, if <var>root</var>'s <a for=Node>node document</a> is an <a>HTML document</a>,
  return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches the following
  <a>descendant</a> <a for=/>elements</a>:

  <ul>
   <li><p>Whose <a for=Element>namespace</a> is the <a>HTML namespace</a> and whose
   <a for=Element>qualified name</a> is <var>qualifiedName</var>, in <a>ASCII lowercase</a>.

   <li><p>Whose <a for=Element>namespace</a> is <em>not</em> the <a>HTML namespace</a> and whose
   <a for=Element>qualified name</a> is <var>qualifiedName</var>.
  </ul>

 <li><p>Otherwise, return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches
 <a>descendant</a> <a for=/>elements</a> whose <a for=Element>qualified name</a> is
 <var>qualifiedName</var>.
</ol>

<p>When invoked with the same argument, and as long as <var>root</var>'s
<a for=Node>node document</a>'s <a for=Document>type</a> has not changed, the same
{{HTMLCollection}} object may be returned as returned by an earlier call.

<p>The
<dfn export id=concept-getelementsbytagnamens>list of elements with namespace <var>namespace</var> and local name <var>localName</var></dfn>
for a <a for=/>node</a> <var>root</var> is the {{HTMLCollection}} returned by the following
algorithm:

<ol>
 <li><p>If <var>namespace</var> is the empty string, then set it to null.

 <li><p>If both <var>namespace</var> and <var>localName</var> are U+002A (*), then return a
 {{HTMLCollection}} rooted at <var>root</var>, whose filter matches <a>descendant</a>
 <a for=/>elements</a>.

 <li><p>If <var>namespace</var> is U+002A (*), then return a {{HTMLCollection}} rooted at
 <var>root</var>, whose filter matches <a>descendant</a> <a for=/>elements</a> whose
 <a for=Element>local name</a> is <var>localName</var>.

 <li><p>If <var>localName</var> is U+002A (*), then return a {{HTMLCollection}} rooted at
 <var>root</var>, whose filter matches <a>descendant</a> <a for=/>elements</a> whose
 <a for=Element>namespace</a> is <var>namespace</var>.

 <li><p>Return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches
 <a>descendant</a> <a for=/>elements</a> whose <a for=Element>namespace</a> is <var>namespace</var>
 and <a for=Element>local name</a> is <var>localName</var>.
</ol>

<p>When invoked with the same arguments, the same {{HTMLCollection}} object may be returned as
returned by an earlier call.

<p>The
<dfn export id=concept-getelementsbyclassname>list of elements with class names <var>classNames</var></dfn>
for a <a for=/>node</a> <var>root</var> is the {{HTMLCollection}} returned by the following
algorithm:

<ol>
 <li>
  Let <var>classes</var> be the result of running the
  <a>ordered set parser</a> on
  <var>classNames</var>.

 <li>
  If <var>classes</var> is the empty set, return an empty
  {{HTMLCollection}}.

 <li>
  <p>Return a {{HTMLCollection}} rooted at <var>root</var>,
  whose filter matches <a>descendant</a>
  <a for=/>elements</a> that have all their
  <a for=Element>classes</a> in <var>classes</var>.

  <p>The comparisons for the <a for=Element>classes</a> must be done in an
  <a>ASCII case-insensitive</a> manner if <var>root</var>'s <a for=Node>node document</a>'s
  <a for=Document>mode</a> is "<code>quirks</code>"; otherwise in an <a for=string>identical to</a>
  manner.
</ol>

<p>When invoked with the same argument, the same {{HTMLCollection}} object may be returned as
returned by an earlier call.


<h3 id=interface-document>Interface {{Document}}</h3>

<pre class=idl force="Document">
[Exposed=Window]
interface Document : Node {
  constructor();

  [SameObject] readonly attribute DOMImplementation implementation;
  readonly attribute USVString URL;
  readonly attribute USVString documentURI;
  readonly attribute DOMString compatMode;
  readonly attribute DOMString characterSet;
  readonly attribute DOMString charset; // legacy alias of .characterSet
  readonly attribute DOMString inputEncoding; // legacy alias of .characterSet
  readonly attribute DOMString contentType;

  readonly attribute DocumentType? doctype;
  readonly attribute Element? documentElement;
  HTMLCollection getElementsByTagName(DOMString qualifiedName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);

  [CEReactions, NewObject] Element createElement(DOMString localName, optional (DOMString or ElementCreationOptions) options = {});
  [CEReactions, NewObject] Element createElementNS(DOMString? namespace, DOMString qualifiedName, optional (DOMString or ElementCreationOptions) options = {});
  [NewObject] DocumentFragment createDocumentFragment();
  [NewObject] Text createTextNode(DOMString data);
  [NewObject] CDATASection createCDATASection(DOMString data);
  [NewObject] Comment createComment(DOMString data);
  [NewObject] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);

  [CEReactions, NewObject] Node importNode(Node node, optional boolean deep = false);
  [CEReactions] Node adoptNode(Node node);

  [NewObject] Attr createAttribute(DOMString localName);
  [NewObject] Attr createAttributeNS(DOMString? namespace, DOMString qualifiedName);

  [NewObject] Event createEvent(DOMString interface); // legacy

  [NewObject] Range createRange();

  // NodeFilter.SHOW_ALL = 0xFFFFFFFF
  [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
  [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
};

[Exposed=Window]
interface XMLDocument : Document {};

dictionary ElementCreationOptions {
  DOMString is;
};
</pre>

<p>{{Document}} <a for=/>nodes</a> are simply
known as <dfn export id=concept-document lt="document">documents</dfn>.

<p>Each <a>document</a> has an associated
<dfn export for=Document id=concept-document-encoding>encoding</dfn> (an <a for=/>encoding</a>),
<dfn export for=Document id=concept-document-content-type>content type</dfn> (a string),
<dfn export for=Document id=concept-document-url>URL</dfn> (a <a for=/>URL</a>),
<dfn export for=Document id=concept-document-origin>origin</dfn> (an <a for=/>origin</a>),
<dfn export for=Document id=concept-document-type>type</dfn> ("<code>xml</code>" or "<code>html</code>"), and
<dfn export for=Document id=concept-document-mode>mode</dfn> ("<code>no-quirks</code>", "<code>quirks</code>", or "<code>limited-quirks</code>").
[[!ENCODING]]
[[!URL]]
[[!HTML]]

<p>Unless stated otherwise, a <a>document</a>'s <a for=Document>encoding</a> is the <a>utf-8</a>
<a for=/>encoding</a>, <a for=Document>content type</a> is
"<code>application/xml</code>", <a for=Document>URL</a> is "<code>about:blank</code>",
<a for=Document>origin</a> is an <a>opaque origin</a>,
<a for=Document>type</a> is "<code>xml</code>", and its
<a for=Document>mode</a> is "<code>no-quirks</code>".

<p>A <a>document</a> is said to be an <dfn export>XML document</dfn> if its <a for=Document>type</a>
is "<code>xml</code>"; otherwise an <dfn export>HTML document</dfn>. Whether a <a>document</a> is an
<a>HTML document</a> or an <a>XML document</a> affects the behavior of certain APIs.

<p>A <a>document</a> is said to be in
<dfn export id=concept-document-no-quirks>no-quirks mode</dfn> if its
<a for=Document>mode</a> is "<code>no-quirks</code>",
<dfn export id=concept-document-quirks>quirks mode</dfn> if its <a for=Document>mode</a>
is "<code>quirks</code>", and
<dfn export id=concept-document-limited-quirks>limited-quirks mode</dfn> if its
<a for=Document>mode</a> is "<code>limited-quirks</code>".

<div class=note>
 <p>The <a for=Document>mode</a> is only ever changed from the default for <a>documents</a> created
 by the <a>HTML parser</a> based on the presence, absence, or value of the DOCTYPE string, and by a
 new <a for=/>browsing context</a> (initial "<code>about:blank</code>"). [[!HTML]]

 <p><a>No-quirks mode</a> was originally known as "standards mode" and <a>limited-quirks mode</a>
 was once known as "almost standards mode". They have been renamed because their details are now
 defined by standards. (And because Ian Hickson vetoed their original names on the basis that they
 are nonsensical.)
</div>

<p>A <a>document</a>'s <a>get the parent</a> algorithm, given an <var>event</var>, returns
null if <var>event</var>'s {{Event/type}} attribute value is "<code>load</code>" or
<a>document</a> does not have a <a for=Document>browsing context</a>; otherwise the
<a>document</a>'s <a>relevant global object</a>.

<hr>

<dl class=domintro>
 <dt><code><var>document</var> = new {{Document()}}</code>
 <dd>Returns a new <a>document</a>.

 <dt><code><var>document</var> . {{Document/implementation}}</code>
 <dd>Returns <var>document</var>'s {{DOMImplementation}} object.

 <dt><code><var>document</var> . {{Document/URL}}</code>
 <dt><code><var>document</var> . {{Document/documentURI}}</code>
 <dd>Returns <var>document</var>'s <a for=Document>URL</a>.

 <dt><code><var>document</var> . {{Document/compatMode}}</code>
 <dd>
  Returns the string "<code>BackCompat</code>" if <var>document</var>'s <a for=Document>mode</a> is
  "<code>quirks</code>"; otherwise "<code>CSS1Compat</code>".

 <dt><code><var>document</var> . {{Document/characterSet}}</code>
 <dd>Returns <var>document</var>'s
 <a for=Document>encoding</a>.

 <dt><code><var>document</var> . {{Document/contentType}}</code>
 <dd>Returns <var>document</var>'s
 <a for=Document>content type</a>.
</dl>

<p>The <dfn constructor for=Document lt=Document()><code>new Document()</code></dfn> constructor
steps are to set <a>this</a>'s <a for=Document>origin</a> to the <a for=Document>origin</a> of
<a>current global object</a>'s <a>associated <code>Document</code></a>. [[!HTML]]

<p class=note>Unlike {{DOMImplementation/createDocument()}}, this constructor does not
return an {{XMLDocument}} object, but a <a>document</a> ({{Document}} object).

<p>The
<dfn attribute for=Document><code>implementation</code></dfn> getter steps are to return the
{{DOMImplementation}} object that is associated with <a>this</a>.

<p>The <dfn attribute for=Document><code>URL</code></dfn> and
<dfn attribute for=Document><code>documentURI</code></dfn> getter steps are to return <a>this</a>'s
<a for=Document>URL</a>, <a lt="URL serializer" spec=url>serialized</a>.

<p>The <dfn attribute for=Document><code>compatMode</code></dfn> getter steps are to return
"<code>BackCompat</code>" if <a>this</a>'s <a for=Document>mode</a> is "<code>quirks</code>";
otherwise "<code>CSS1Compat</code>".

<p>The <dfn attribute for=Document><code>characterSet</code></dfn>,
<dfn attribute for=Document><code>charset</code></dfn>, and
<dfn attribute for=Document><code>inputEncoding</code></dfn> getter steps are to return
<a>this</a>'s <a for=Document>encoding</a>'s <a for=encoding>name</a>.

<p>The <dfn attribute for=Document><code>contentType</code></dfn> getter steps are to return
<a>this</a>'s <a for=Document>content type</a>.

<hr>

<dl class=domintro>
 <dt><var>document</var> . {{Document/doctype}}
 <dd>Returns the <a>doctype</a> or null if
 there is none.

 <dt><var>document</var> . {{Document/documentElement}}
 <dd>Returns the <a>document element</a>.

 <dt><var>collection</var> = <var>document</var> . {{Document/getElementsByTagName(qualifiedName)}}</code>

 <dd>
  <p>If <var>qualifiedName</var> is "<code>*</code>" returns a {{HTMLCollection}} of all
  <a>descendant</a> <a for=/>elements</a>.

  <p>Otherwise, returns a {{HTMLCollection}} of all <a>descendant</a> <a for=/>elements</a> whose
  <a for=Element>qualified name</a> is <var>qualifiedName</var>. (Matches case-insensitively against
  <a for=/>elements</a> in the <a>HTML namespace</a> within an <a>HTML document</a>.)

 <dt><var>collection</var> = <var>document</var> . {{Document/getElementsByTagNameNS(namespace, localName)}}</code>

 <dd>
  If <var>namespace</var> and <var>localName</var> are
  "<code>*</code>" returns a {{HTMLCollection}} of all
  <a>descendant</a>
  <a for=/>elements</a>.

  If only <var>namespace</var> is "<code>*</code>" returns a
  {{HTMLCollection}} of all
  <a>descendant</a>
  <a for=/>elements</a> whose
  <a for=Element>local name</a> is
  <var>localName</var>.

  If only <var>localName</var> is "<code>*</code>" returns a
  {{HTMLCollection}} of all
  <a>descendant</a>
  <a for=/>elements</a> whose
  <a for=Element>namespace</a> is
  <var>namespace</var>.

  Otherwise, returns a {{HTMLCollection}} of all
  <a>descendant</a>
  <a for=/>elements</a> whose
  <a for=Element>namespace</a> is
  <var>namespace</var> and
  <a for=Element>local name</a> is
  <var>localName</var>.

 <dt><var>collection</var> = <var>document</var> . {{Document/getElementsByClassName(classNames)}}</code>
 <dt><var>collection</var> = <var>element</var> . {{Element/getElementsByClassName(classNames)}}</code>
 <dd>
  Returns a {{HTMLCollection}} of the
  <a for=/>elements</a> in the object on which
  the method was invoked (a <a>document</a> or
  an <a for=/>element</a>) that have all the classes
  given by <var>classNames</var>.
  The <var>classNames</var> argument is interpreted as a
  space-separated list of classes.
</dl>

<p>The <dfn attribute for=Document><code>doctype</code></dfn> getter steps are to return the
<a for=tree>child</a> of <a>this</a> that is a <a>doctype</a>; otherwise null.

<p>The <dfn attribute for=Document><code>documentElement</code></dfn> getter steps are to return
<a>this</a>'s <a>document element</a>.

<p>The <dfn method for=Document><code>getElementsByTagName(<var>qualifiedName</var>)</code></dfn>
method steps are to return the <a>list of elements with qualified name <var>qualifiedName</var></a>
for <a>this</a>.

<p class=note>Thus, in an <a>HTML document</a>,
<code class=lang-javascript>document.getElementsByTagName("FOO")</code> will match
<code>&lt;FOO></code> elements that are not in the
<a>HTML namespace</a>, and <code>&lt;foo></code> elements that are in
the <a>HTML namespace</a>, but not <code>&lt;FOO></code> elements
that are in the <a>HTML namespace</a>.

<p>The
<dfn method for=Document><code>getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
method steps are to return the <a>list of elements with namespace <var>namespace</var> and local
name <var>localName</var></a> for <a>this</a>.

<p>The <dfn method for=Document><code>getElementsByClassName(<var>classNames</var>)</code></dfn>
method steps are to return the <a>list of elements with class names <var>classNames</var></a> for
<a>this</a>.

<div class=example id=example-5ffcda00>
 Given the following XHTML fragment:

 <pre><code class=lang-html>
  &lt;div id="example"&gt;
    &lt;p id="p1" class="aaa bbb"/&gt;
    &lt;p id="p2" class="aaa ccc"/&gt;
    &lt;p id="p3" class="bbb ccc"/&gt;
  &lt;/div&gt;
 </code></pre>

 A call to
 <code class=lang-javascript>document.getElementById("example").getElementsByClassName("aaa")</code>
 would return a {{HTMLCollection}} with the two paragraphs
 <code>p1</code> and <code>p2</code> in it.

 A call to
 <code class=lang-javascript>getElementsByClassName("ccc&nbsp;bbb")</code>
 would only return one node, however, namely <code>p3</code>. A call to
 <code class=lang-javascript>document.getElementById("example").getElementsByClassName("bbb&nbsp;&nbsp;ccc&nbsp;")</code>
 would return the same thing.

 A call to
 <code class=lang-javascript>getElementsByClassName("aaa,bbb")</code>
 would return no nodes; none of the elements above are in the
 <code>aaa,bbb</code> class.
</div>

<hr>

<dl class=domintro>
 <dt><code><var>element</var> = <var>document</var> . <a method for=Document lt=createElement()>createElement(localName [, options])</a></code>
 <dd>
  <p>Returns an <a for=/>element</a> with <var>localName</var> as <a for=Element>local name</a>
  (if <var>document</var> is an <a>HTML document</a>, <var>localName</var> gets lowercased). The
  <a for=/>element</a>'s <a for=Element>namespace</a> is the <a>HTML namespace</a> when
  <var>document</var> is an <a>HTML document</a> or <var>document</var>'s
  <a for=Document>content type</a> is "<code>application/xhtml+xml</code>"; otherwise null.

  <p>If <var>localName</var> does not match the <code><a type>Name</a></code> production an
  "{{InvalidCharacterError!!exception}}" {{DOMException}} will be thrown.

  <p>When supplied, <var>options</var>'s {{ElementCreationOptions/is}} can be used to create a
  <a>customized built-in element</a>.

 <dt><code><var>element</var> = <var>document</var> . <a method for=Document lt=createElementNS()>createElementNS(namespace, qualifiedName [, options])</a></code>

 <dd>
  <p>Returns an <a for=/>element</a> with <a for=Element>namespace</a> <var>namespace</var>. Its
  <a for=Element>namespace prefix</a> will be everything before U+003A (:) in
  <var>qualifiedName</var> or null. Its <a for=Element>local name</a> will be everything after
  U+003A (:) in <var>qualifiedName</var> or <var>qualifiedName</var>.

  <p>If <var>qualifiedName</var> does not match the <code><a type>QName</a></code> production an
  "{{InvalidCharacterError!!exception}}" {{DOMException}} will be thrown.

  <p>If one of the following conditions is true a "{{NamespaceError!!exception}}" {{DOMException}}
  will be thrown:

  <ul>
   <li><a for=Element>Namespace prefix</a>
   is not null and <var>namespace</var> is the empty string.
   <li><a for=Element>Namespace prefix</a>
   is "<code>xml</code>" and <var>namespace</var> is not the
   <a>XML namespace</a>.
   <li><var>qualifiedName</var> or
   <a for=Element>namespace prefix</a>
   is "<code>xmlns</code>" and <var>namespace</var> is not the
   <a>XMLNS namespace</a>.
   <li><var>namespace</var> is the <a>XMLNS namespace</a> and
   neither <var>qualifiedName</var> nor
   <a for=Element>namespace prefix</a>
   is "<code>xmlns</code>".
  </ul>

  <p>When supplied, <var>options</var>'s {{ElementCreationOptions/is}} can be used to create a
  <a>customized built-in element</a>.

 <dt><code><var ignore>documentFragment</var> = <var>document</var> . {{createDocumentFragment()}}</code>
 <dd>Returns a {{DocumentFragment}} <a for=/>node</a>.

 <dt><code><var ignore>text</var> = <var>document</var> . {{createTextNode(data)}}</code>
 <dd>Returns a {{Text}} <a for=/>node</a>
 whose <a for=CharacterData>data</a> is <var>data</var>.

 <dt><code><var ignore>text</var> = <var>document</var> . {{createCDATASection(data)}}</code>
 <dd>Returns a {{CDATASection}} <a for=/>node</a> whose <a for=CharacterData>data</a> is
 <var>data</var>.

 <dt><code><var ignore>comment</var> = <var>document</var> . {{createComment(data)}}</code>
 <dd>Returns a {{Comment}} <a for=/>node</a> whose <a for=CharacterData>data</a> is <var>data</var>.

 <dt><code><var ignore>processingInstruction</var> = <var>document</var> . {{createProcessingInstruction(target, data)}}</code>
 <dd>
  Returns a {{ProcessingInstruction}}
  <a for=/>node</a> whose
  <a for=ProcessingInstruction>target</a> is <var>target</var> and
  <a for=CharacterData>data</a> is <var>data</var>.
  If <var>target</var> does not match the
  <code><a type>Name</a></code> production an
  "{{InvalidCharacterError!!exception}}" {{DOMException}} will be thrown.
  If <var>data</var> contains "<code>?></code>" an
  "{{InvalidCharacterError!!exception}}" {{DOMException}} will be thrown.
</dl>

<p>The <dfn export id=concept-element-interface>element interface</dfn> for any <var>name</var> and
<var>namespace</var> is {{Element}}, unless stated otherwise.

<p class=note>The HTML Standard will, e.g., define that for <code>html</code> and the
<a>HTML namespace</a>, the {{HTMLHtmlElement}} interface is used. [[!HTML]]

<p>The
<dfn method for=Document><code>createElement(<var>localName</var>, <var>options</var>)</code></dfn>
method steps are:

<ol>
 <li><p>If <var>localName</var> does not match the <code><a type>Name</a></code> production, then
 <a>throw</a> an "{{InvalidCharacterError!!exception}}" {{DOMException}}.

 <li><p>If <a>this</a> is an <a>HTML document</a>, then set <var>localName</var> to
 <var>localName</var> in <a>ASCII lowercase</a>.

 <li><p>Let <var>is</var> be null.

 <li><p>If <var>options</var> is a <a for=/>dictionary</a> and
 <var>options</var>["{{ElementCreationOptions/is}}"] <a for=map>exists</a>, then set <var>is</var>
 to it.

 <li><p>Let <var>namespace</var> be the <a>HTML namespace</a>, if <a>this</a> is an
 <a>HTML document</a> or <a>this</a>'s <a for=Document>content type</a> is
 "<code>application/xhtml+xml</code>"; otherwise null.

 <li><p>Return the result of <a>creating an element</a> given <a>this</a>, <var>localName</var>,
 <var>namespace</var>, null, <var>is</var>, and with the <var>synchronous custom elements</var> flag
 set.
</ol>

<p>The <dfn noexport>internal <code>createElementNS</code> steps</dfn>, given <var>document</var>,
<var>namespace</var>, <var>qualifiedName</var>, and <var>options</var>, are as follows:

<ol>
 <li><p>Let <var>namespace</var>, <var>prefix</var>, and <var>localName</var> be the result of
 passing <var>namespace</var> and <var>qualifiedName</var> to <a>validate and extract</a>.

 <li><p>Let <var>is</var> be null.

 <li><p>If <var>options</var> is a <a for=/>dictionary</a> and
 <var>options</var>["{{ElementCreationOptions/is}}"] <a for=map>exists</a>, then set <var>is</var>
 to it.

 <li><p>Return the result of <a>creating an element</a> given <var>document</var>,
 <var>localName</var>, <var>namespace</var>, <var>prefix</var>, <var>is</var>, and with the
 <var>synchronous custom elements</var> flag set.
</ol>

<p>The
<dfn method for=Document><code>createElementNS(<var>namespace</var>, <var>qualifiedName</var>, <var>options</var>)</code></dfn>
method steps are to return the result of running the
<a>internal <code>createElementNS</code> steps</a>, given <a>this</a>, <var>namespace</var>,
<var>qualifiedName</var>, and <var>options</var>.

<p class=note>{{Document/createElement()}} and {{Document/createElementNS()}}'s <var>options</var>
parameter is allowed to be a string for web compatibility.

<p>The <dfn method for=Document><code>createDocumentFragment()</code></dfn> method steps are to
return a new {{DocumentFragment}} <a for=/>node</a> whose <a for=Node>node document</a> is
<a>this</a>.

<p>The <dfn method for=Document><code>createTextNode(<var>data</var>)</code></dfn> method steps are
to return a new {{Text}} <a for=/>node</a> whose <a for=CharacterData>data</a> is <var>data</var>
and <a for=Node>node document</a> is <a>this</a>.

<p class=note>No check is performed that <var>data</var> consists of
characters that match the <code><a type>Char</a></code> production.

<p>The <dfn method for=Document><code>createCDATASection(<var>data</var>)</code></dfn> method steps
are:

<ol>
 <li><p>If <a>this</a> is an <a>HTML document</a>, then <a>throw</a> a
 "{{NotSupportedError!!exception}}" {{DOMException}}.

 <li><p>If <var>data</var> contains the string "<code>]]></code>", then <a>throw</a> an
 "{{InvalidCharacterError!!exception}}" {{DOMException}}.

 <li><p>Return a new {{CDATASection}} <a for=/>node</a> with its <a for=CharacterData>data</a> set
 to <var>data</var> and <a for=Node>node document</a> set to <a>this</a>.
</ol>

<p>The <dfn method for=Document><code>createComment(<var>data</var>)</code></dfn> method steps are
to return a new {{Comment}} <a for=/>node</a> whose <a for=CharacterData>data</a> is <var>data</var>
and <a for=Node>node document</a> is <a>this</a>.

<p class=note>No check is performed that <var>data</var> consists of
characters that match the <code><a type>Char</a></code> production
or that it contains two adjacent hyphens or ends with a hyphen.

<p>The
<dfn method for=Document><code>createProcessingInstruction(<var>target</var>, <var>data</var>)</code></dfn>
method steps are:

<ol>
 <li>If <var>target</var> does not match the
 <!--<code data-anolis-type>PITarget</code>-->
 <code><a type>Name</a></code> production,
 then <a>throw</a> an "{{InvalidCharacterError!!exception}}" {{DOMException}}. <!-- DOM3 does not check for "xml" -->

 <li>If <var>data</var> contains the string
 "<code>?></code>", then <a>throw</a> an
 "{{InvalidCharacterError!!exception}}" {{DOMException}}. <!-- Gecko does this. -->

 <li>Return a new {{ProcessingInstruction}}
 <a for=/>node</a>, with
 <a for=ProcessingInstruction>target</a> set to <var>target</var>,
 <a for=CharacterData>data</a> set to <var>data</var>, and
 <a for=Node>node document</a> set to <a>this</a>.
</ol>

<p class=note>No check is performed that <var>target</var> contains
"<code>xml</code>" or "<code>:</code>", or that
<var>data</var> contains characters that match the
<code><a type>Char</a></code> production.

<hr>

<dl class=domintro>
 <dt><var>clone</var> = <var>document</var> . <a method for=Document lt=importNode()>importNode(<var>node</var> [, <var>deep</var> = false])</a>
 <dd>
  Returns a copy of <var>node</var>. If
  <var>deep</var> is true, the copy also includes the
  <var>node</var>'s <a>descendants</a>.

  If <var>node</var> is a <a>document</a> or a <a for=/>shadow root</a>, throws a
  "{{NotSupportedError!!exception}}" {{DOMException}}.

 <dt><var>node</var> = <var>document</var> . {{adoptNode(node)}}

 <dd>
  Moves <var>node</var> from another
  <a>document</a> and returns it.

  If <var>node</var> is a <a>document</a>, throws a "{{NotSupportedError!!exception}}"
  {{DOMException}} or, if <var>node</var> is a <a for=/>shadow root</a>, throws a
  "{{HierarchyRequestError!!exception}}" {{DOMException}}.
</dl>

<p>The <dfn method for=Document><code>importNode(<var>node</var>, <var>deep</var>)</code></dfn>
method steps are:

<ol>
 <li><p>If <var>node</var> is a <a>document</a> or <a for=/>shadow root</a>, then <a>throw</a> a
 "{{NotSupportedError!!exception}}" {{DOMException}}.

 <li><p>Return a <a lt="clone a node">clone</a> of <var>node</var>, with <a>this</a> and the
 <i>clone children flag</i> set if <var>deep</var> is true.
</ol>

<p><a lt="Other applicable specifications">Specifications</a> may define
<dfn export id=concept-node-adopt-ext>adopting steps</dfn> for all or some <a for=/>nodes</a>. The
algorithm is passed <var>node</var> and <var>oldDocument</var>, as indicated in the <a>adopt</a>
algorithm.

<p>To <dfn export id=concept-node-adopt>adopt</dfn> a <var>node</var> into a <var>document</var>, run
these steps:

<ol>
 <li><p>Let <var>oldDocument</var> be <var>node</var>'s <a for=Node>node document</a>.

 <li><p>If <var>node</var>'s <a for=tree>parent</a> is non-null, then <a for=/>remove</a>
 <var>node</var>.

 <li>
  <p>If <var>document</var> is not <var>oldDocument</var>, then:

  <ol>
   <li>
    <p>For each <var>inclusiveDescendant</var> in <var>node</var>'s
    <a>shadow-including inclusive descendants</a>:

    <ol>
     <li><p>Set <var>inclusiveDescendant</var>'s <a for=Node>node document</a> to <var>document</var>.

     <li><p>If <var>inclusiveDescendant</var> is an <a for=/>element</a>, then set the
     <a for=Node>node document</a> of each <a>attribute</a> in <var>inclusiveDescendant</var>'s
     <a for=Element>attribute list</a> to <var>document</var>.
    </ol>

   <li><p>For each <var>inclusiveDescendant</var> in <var>node</var>'s
   <a>shadow-including inclusive descendants</a> that is <a for=Element>custom</a>,
   <a>enqueue a custom element callback reaction</a> with <var>inclusiveDescendant</var>, callback
   name "<code>adoptedCallback</code>", and an argument list containing <var>oldDocument</var> and
   <var>document</var>. <!-- attributeChangedCallback is also old, then new -->

   <li><p>For each <var>inclusiveDescendant</var> in <var>node</var>'s
   <a>shadow-including inclusive descendants</a>, in <a>shadow-including tree order</a>, run the
   <a>adopting steps</a> with <var>inclusiveDescendant</var> and <var>oldDocument</var>.
  </ol>
</ol>

<p>The <dfn method for=Document><code>adoptNode(<var>node</var>)</code></dfn> method steps are:

<ol>
 <li><p>If <var>node</var> is a <a>document</a>, then <a>throw</a> a
 "{{NotSupportedError!!exception}}" {{DOMException}}.

 <li><p>If <var>node</var> is a <a for=/>shadow root</a>, then <a>throw</a> a
 "{{HierarchyRequestError!!exception}}" {{DOMException}}.

 <li><p>If <var>node</var> is a {{DocumentFragment}} <a for=/>node</a> whose
 <a for=DocumentFragment>host</a> is non-null, then return.

 <li><p><a>Adopt</a> <var>node</var> into <a>this</a>.

 <li><p>Return <var>node</var>.
</ol>

<hr>

<p>The <dfn method for=Document><code>createAttribute(<var>localName</var>)</code></dfn> method
steps are:

<ol>
 <li><p>If <var>localName</var> does not match the <code><a type>Name</a></code> production in XML,
 then <a>throw</a> an "{{InvalidCharacterError!!exception}}" {{DOMException}}.

 <li>If <a>this</a> is an <a>HTML document</a>, then set <var>localName</var> to
 <var>localName</var> in <a>ASCII lowercase</a>.

 <li>Return a new <a>attribute</a> whose <a for=Attr>local name</a> is <var>localName</var> and
 <a for=Node>node document</a> is <a>this</a>.
</ol>

<p>The
<dfn method for=Document><code>createAttributeNS(<var>namespace</var>, <var>qualifiedName</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>namespace</var>, <var>prefix</var>, and <var>localName</var> be the result of
 passing <var>namespace</var> and <var>qualifiedName</var> to <a>validate and extract</a>.

 <li><p>Return a new <a>attribute</a> whose <a for=Attr>namespace</a> is <var>namespace</var>,
 <a for=Attr>namespace prefix</a> is <var>prefix</var>, <a for=Attr>local name</a> is
 <var>localName</var>, and <a for=Node>node document</a> is <a>this</a>.
</ol>

<hr>

<p>The <dfn method for=Document><code>createEvent(<var>interface</var>)</code></dfn> method steps
are:

<ol>
 <li><p>Let <var>constructor</var> be null.

 <li>
  <p>If <var>interface</var> is an <a>ASCII case-insensitive</a> match for any of the strings in the
  first column in the following table, then set <var>constructor</var> to the interface in the
  second column on the same row as the matching string:

  <table>
   <thead>
    <tr><th>String<th>Interface<td>Notes
   <tbody>
    <tr><td>"<code>beforeunloadevent</code>"<td>{{BeforeUnloadEvent}}<td>[[!HTML]]
    <tr><td>"<code>compositionevent</code>"<td>{{CompositionEvent}}<td>[[!UIEVENTS]]
    <!-- textevent also maps to CompositionEvent -->
    <tr><td>"<code>customevent</code>"<td>{{CustomEvent}}<td>
    <tr><td>"<code>devicemotionevent</code>"<td>{{DeviceMotionEvent}}<td rowspan=2>[[!DEVICE-ORIENTATION]]
    <tr><td>"<code>deviceorientationevent</code>"<td>{{DeviceOrientationEvent}}
    <tr><td>"<code>dragevent</code>"<td>{{DragEvent}}<td>[[!HTML]]
    <tr><td>"<code>event</code>"<td rowspan=2>{{Event}}<td rowspan=2>
    <tr><td>"<code>events</code>"
    <!-- htmlevents and svgevents also map to Event -->
    <tr><td>"<code>focusevent</code>"<td>{{FocusEvent}}<td>[[!UIEVENTS]]
    <tr><td>"<code>hashchangeevent</code>"<td>{{HashChangeEvent}}<td>[[!HTML]]
    <tr><td>"<code>htmlevents</code>"<td>{{Event}}<td>
    <tr><td>"<code>keyboardevent</code>"<td>{{KeyboardEvent}}<td>[[!UIEVENTS]]
    <tr><td>"<code>messageevent</code>"<td>{{MessageEvent}}<td>[[!HTML]]
    <tr><td>"<code>mouseevent</code>"<td rowspan=2>{{MouseEvent}}<td rowspan=2>[[!UIEVENTS]]
    <tr><td>"<code>mouseevents</code>"
    <tr><td>"<code>storageevent</code>"<td>{{StorageEvent}}<td>[[!HTML]]
    <tr><td>"<code>svgevents</code>"<td>{{Event}}<td>
    <tr><td>"<code>textevent</code>"<td>{{CompositionEvent}}<td>[[!UIEVENTS]]
    <tr><td>"<code>touchevent</code>"<td>{{TouchEvent}}<td>[[!TOUCH-EVENTS]]
    <tr><td>"<code>uievent</code>"<td rowspan=2>{{UIEvent}}<td rowspan=2>[[!UIEVENTS]]
    <tr><td>"<code>uievents</code>"
  </table>

 <li><p>If <var>constructor</var> is null, then <a>throw</a> a "{{NotSupportedError!!exception}}"
  {{DOMException}}.

 <li>
  <p>If the interface indicated by <var>constructor</var> is not exposed on the
  <a>relevant global object</a> of <a>this</a>, then <a>throw</a> a
  "{{NotSupportedError!!exception}}" {{DOMException}}.

  <p class=note>Typically user agents disable support for touch events in some configurations, in
  which case this clause would be triggered for the interface {{TouchEvent}}.

 <li><p>Let <var>event</var> be the result of <a>creating an event</a> given <var>constructor</var>.

 <li><p>Initialize <var>event</var>'s {{Event/type}} attribute to the empty string.

 <li><p>Initialize <var>event</var>'s {{Event/timeStamp}} attribute to the result of calling
 <a>current high resolution time</a> with <a>this</a>'s <a>relevant global object</a>.

 <li><p>Initialize <var>event</var>'s {{Event/isTrusted}} attribute to false.

 <li><p>Unset <var>event</var>'s <a>initialized flag</a>.

 <li><p>Return <var>event</var>.
</ol>

<p class=note><a>Event</a> constructors ought to be used instead.

<hr>

<p>The <dfn method for=Document><code>createRange()</code></dfn> method steps are to return a new
<a>live range</a> with (<a>this</a>, 0) as its <a for=range>start</a> an <a for=range>end</a>.

<p class=note>The {{Range/Range()}} constructor can be used instead.

<hr>

<p>The
<dfn method for=Document><code>createNodeIterator(<var>root</var>, <var>whatToShow</var>, <var>filter</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>iterator</var> be a new {{NodeIterator}} object.

 <li><p>Set <var>iterator</var>'s <a for=traversal>root</a> and <var>iterator</var>'s
 <a for=NodeIterator>reference</a> to <var>root</var>.

 <li><p>Set <var>iterator</var>'s <a for=NodeIterator>pointer before reference</a> to true.

 <li><p>Set <var>iterator</var>'s <a for=traversal>whatToShow</a> to <var>whatToShow</var>.

 <li><p>Set <var>iterator</var>'s <a for=traversal>filter</a> to <var>filter</var>.

 <li><p>Return <var>iterator</var>.
</ol>

<p>The
<dfn method for=Document><code>createTreeWalker(<var>root</var>, <var>whatToShow</var>, <var>filter</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>walker</var> be a new {{TreeWalker}} object.

 <li><p>Set <var>walker</var>'s <a for=traversal>root</a> and <var>walker</var>'s
 <a for=TreeWalker>current</a> to <var>root</var>.

 <li><p>Set <var>walker</var>'s <a for=traversal>whatToShow</a> to <var>whatToShow</var>.

 <li><p>Set <var>walker</var>'s <a for=traversal>filter</a> to <var>filter</var>.

 <li>Return <var>walker</var>.
</ol>


<h4 id=interface-domimplementation>Interface {{DOMImplementation}}</h4>

User agents must create a {{DOMImplementation}} object whenever
a <a>document</a> is created and associate it
with that <a>document</a>.

<pre class=idl>
[Exposed=Window]
interface DOMImplementation {
  [NewObject] DocumentType createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  [NewObject] XMLDocument createDocument(DOMString? namespace, [LegacyNullToEmptyString] DOMString qualifiedName, optional DocumentType? doctype = null);
  [NewObject] Document createHTMLDocument(optional DOMString title);

  boolean hasFeature(); // useless; always returns true
};
</pre>

<dl class=domintro>
 <dt><code><var>doctype</var> = <var>document</var> . {{Document/implementation}} . {{createDocumentType(qualifiedName, publicId, systemId)}}</code>

 <dd>
  Returns a <a>doctype</a>, with the given
  <var>qualifiedName</var>, <var>publicId</var>, and
  <var>systemId</var>. If <var>qualifiedName</var> does not
  match the <code><a type>Name</a></code> production, an
  "{{InvalidCharacterError!!exception}}" {{DOMException}} is thrown, and if it does not match the
  <code><a type>QName</a></code> production, a
  "{{NamespaceError!!exception}}" {{DOMException}} is thrown.

 <dt><code><var>doc</var> = <var>document</var> . {{Document/implementation}} . <a method for=DOMImplementation lt=createDocument()>createDocument(<var>namespace</var>, <var>qualifiedName</var> [, <var>doctype</var> = null])</a></code>

 <dd>
  Returns an {{XMLDocument}}, with a
  <a>document element</a> whose
  <a for=Element>local name</a> is
  <var>qualifiedName</var> and whose
  <a for=Element>namespace</a> is
  <var>namespace</var> (unless <var>qualifiedName</var> is the
  empty string), and with <var>doctype</var>, if it is given, as its
  <a>doctype</a>.

  This method throws the same exceptions as the {{Document/createElementNS()}} method, when
  invoked with <var>namespace</var> and <var>qualifiedName</var>.

 <dt><code><var>doc</var> = <var>document</var> . {{Document/implementation}} . <a method for=DOMImplementation lt=createHTMLDocument()>createHTMLDocument([<var>title</var>])</a></code>

 <dd>
  Returns a <a>document</a>, with a basic
  <a>tree</a> already constructed including a
  <{title}> element, unless the <var>title</var>
  argument is omitted.
</dl>

<div class=impl>

<p>The
<dfn method for=DOMImplementation><code>createDocumentType(<var>qualifiedName</var>, <var>publicId</var>, <var>systemId</var>)</code></dfn>
method steps are:

<ol>
 <li><p><a>Validate</a> <var>qualifiedName</var>.

 <li><p>Return a new <a>doctype</a>, with <var>qualifiedName</var> as its
 <a for=DocumentType>name</a>, <var>publicId</var> as its <a>public ID</a>, and <var>systemId</var>
 as its <a>system ID</a>, and with its <a for=Node>node document</a> set to the associated
 <a>document</a> of <a>this</a>.
</ol>

<p class=note>No check is performed that <var>publicId</var> code points match the
<code><a type>PubidChar</a></code> production or that <var>systemId</var> does not contain both a
'<code>"</code>' and a "<code>'</code>".

<p>The
<dfn method for=DOMImplementation><code>createDocument(<var>namespace</var>, <var>qualifiedName</var>, <var>doctype</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>document</var> be a new {{XMLDocument}}.

 <li><p>Let <var>element</var> be null.

 <li><p>If <var>qualifiedName</var> is not the empty string, then set <var>element</var> to the
 result of running the <a>internal <code>createElementNS</code> steps</a>, given
 <var>document</var>, <var>namespace</var>, <var>qualifiedName</var>, and an empty dictionary.

 <li><p>If <var>doctype</var> is non-null, <a>append</a> <var>doctype</var> to <var>document</var>.

 <li><p>If <var>element</var> is non-null, <a>append</a> <var>element</var> to <var>document</var>.

 <li><p><var>document</var>'s <a for=Document>origin</a> is <a>this</a>'s associated
 <a>document</a>'s <a for=Document>origin</a>.

 <li>
  <p><var>document</var>'s <a for=Document>content type</a> is determined by <var>namespace</var>:

  <dl class=switch>
   <dt><a>HTML namespace</a>
   <dd><code>application/xhtml+xml</code>

   <dt><a>SVG namespace</a>
   <dd><code>image/svg+xml</code>

   <dt>Any other namespace
   <dd><code>application/xml</code>
  </dl>

 <li><p>Return <var>document</var>.
</ol>

<p>The
<dfn method for=DOMImplementation><code>createHTMLDocument(<var>title</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>doc</var> be a new <a>document</a> that is an <a>HTML document</a>.

 <li><p>Set <var>doc</var>'s <a for=Document>content type</a> to "<code>text/html</code>".

 <li><p><a>Append</a> a new <a>doctype</a>, with "<code>html</code>" as its
 <a for=DocumentType>name</a> and with its <a for=Node>node document</a> set to <var>doc</var>, to
 <var>doc</var>.

 <li><p><a>Append</a> the result of <a>creating an element</a> given <var>doc</var>, <{html}>, and
 the <a>HTML namespace</a>, to <var>doc</var>.

 <li><p><a>Append</a> the result of <a>creating an element</a> given <var>doc</var>, <{head}>, and
 the <a>HTML namespace</a>, to the <{html}> element created earlier.

 <li>
  <p>If <var>title</var> is given:

  <ol>
   <li><p><a>Append</a> the result of <a>creating an element</a> given <var>doc</var>, <{title}>,
   and the <a>HTML namespace</a>, to the <{head}> element created earlier.

   <li><p><a>Append</a> a new {{Text}} <a for=/>node</a>, with its <a for=CharacterData>data</a> set
   to <var>title</var> (which could be the empty string) and its <a for=Node>node document</a> set
   to <var>doc</var>, to the <{title}> element created earlier.
  </ol>

 <li><p><a>Append</a> the result of <a>creating an element</a> given <var>doc</var>, <{body}>, and
 the <a>HTML namespace</a>, to the <{html}> element created earlier.</li>

 <li><p><var>doc</var>'s <a for=Document>origin</a> is <a>this</a>'s associated <a>document</a>'s
 <a for=Document>origin</a>.

 <li><p>Return <var>doc</var>.
</ol>

<p>The <dfn method for=DOMImplementation><code>hasFeature()</code></dfn> method steps are to
return true.

<p class=note>{{hasFeature()}} originally would report whether the user agent
claimed to support a given DOM feature, but experience proved it was not nearly as
reliable or granular as simply checking whether the desired objects, attributes, or
methods existed. As such, it is no longer to be used, but continues to exist (and simply
returns true) so that old pages don't stop working.

</div>


<h3 id=interface-documenttype>Interface {{DocumentType}}</h3>

<pre class=idl>
[Exposed=Window]
interface DocumentType : Node {
  readonly attribute DOMString name;
  readonly attribute DOMString publicId;
  readonly attribute DOMString systemId;
};
</pre>

<p>{{DocumentType}} <a for=/>nodes</a> are simply known as
<dfn export id=concept-doctype lt="doctype">doctypes</dfn>.

<p><a>Doctypes</a> have an associated
<dfn export id=concept-doctype-name for=DocumentType>name</dfn>,
<dfn export id=concept-doctype-publicid for=DocumentType>public ID</dfn>, and
<dfn export id=concept-doctype-systemid for=DocumentType>system ID</dfn>.

<p>When a <a>doctype</a> is created, its <a for=DocumentType>name</a> is always given. Unless
explicitly given when a <a>doctype</a> is created, its <a>public ID</a> and <a>system ID</a> are the
empty string.

<p>The <dfn attribute for=DocumentType><code>name</code></dfn> getter steps are to return
<a>this</a>'s <a for=DocumentType>name</a>.

<p>The <dfn attribute for=DocumentType><code>publicId</code></dfn> getter steps are to return
<a>this</a>'s <a>public ID</a>.

<p>The <dfn attribute for=DocumentType><code>systemId</code></dfn> getter steps are to return
<a>this</a>'s <a>system ID</a>.


<h3 id=interface-documentfragment>Interface {{DocumentFragment}}</h3>

<pre class=idl>
[Exposed=Window]
interface DocumentFragment : Node {
  constructor();
};
</pre>

<p>A {{DocumentFragment}} <a for=/>node</a> has an associated
<dfn export id=concept-documentfragment-host for=DocumentFragment>host</dfn> (null or an
<a for=/>element</a> in a different <a>node tree</a>). It is null unless otherwise stated.

<p>An object <var>A</var> is a
<dfn export id=concept-tree-host-including-inclusive-ancestor>host-including inclusive ancestor</dfn>
of an object <var>B</var>, if either <var>A</var> is an <a for=tree>inclusive ancestor</a> of <var>B</var>,
or if <var>B</var>'s <a for=tree>root</a> has a non-null <a for=DocumentFragment>host</a> and
<var>A</var> is a <a>host-including inclusive ancestor</a> of <var>B</var>'s <a for=tree>root</a>'s
<a for=DocumentFragment>host</a>.

<p class=note>The {{DocumentFragment}} <a for=/>node</a>'s <a for=DocumentFragment>host</a>
concept is useful for HTML's <{template}> element and for <a for=/>shadow roots</a>, and impacts the
<a>pre-insert</a> and <a>replace</a> algorithms.

<dl class=domintro>
 <dt><code><var ignore>tree</var> = new {{DocumentFragment()}}</code>
 <dd>Returns a new {{DocumentFragment}} <a for=/>node</a>.
</dl>

<p>The
<dfn constructor for=DocumentFragment lt=DocumentFragment()><code>new DocumentFragment()</code></dfn>
constructor steps are to set <a>this</a>'s <a for=Node>node document</a> to
<a>current global object</a>'s <a>associated <code>Document</code></a>.


<h3 id=interface-shadowroot>Interface {{ShadowRoot}}</h3>

<pre class=idl>
[Exposed=Window]
interface ShadowRoot : DocumentFragment {
  readonly attribute ShadowRootMode mode;
  readonly attribute boolean delegatesFocus;
  readonly attribute SlotAssignmentMode slotAssignment;
  readonly attribute Element host;
  attribute EventHandler onslotchange;
};

enum ShadowRootMode { "open", "closed" };
enum SlotAssignmentMode { "manual", "named" };
</pre>

<p>{{ShadowRoot}} <a for=/>nodes</a> are simply known as
<dfn export id=concept-shadow-root lt="shadow root">shadow roots</dfn>.

<p><a for=/>Shadow roots</a> have an associated <dfn for=ShadowRoot>mode</dfn> ("<code>open</code>"
or "<code>closed</code>").</p>

<p><a for=/>Shadow roots</a> have an associated <dfn export for=ShadowRoot>delegates focus</dfn>.
It is initially set to false.</p>

<p><a for=/>Shadow roots</a> have an associated
<dfn export for=ShadowRoot>available to element internals</dfn>. It is initially set to false.</p>

<p><a for=/>Shadow roots</a>'s associated <a for=DocumentFragment>host</a> is never null.</p>
<!-- If we ever change this, e.g., add a ShadowRoot object constructor, that would have serious
     consequences for innerHTML. -->

<p><a for=/>Shadow roots</a> have an associated <dfn for=ShadowRoot>slot assignment</dfn>
("<code>manual</code>" or "<code>named</code>").

<p>A <a for=/>shadow root</a>'s <a>get the parent</a> algorithm, given an <var>event</var>, returns
null if <var>event</var>'s <a>composed flag</a> is unset and <a for=/>shadow root</a> is the
<a for=tree>root</a> of <var>event</var>'s <a for=Event>path</a>'s first struct's
<a for=Event/path>invocation target</a>; otherwise <a for=/>shadow root</a>'s
<a for=DocumentFragment>host</a>.

<p>The <dfn attribute for=ShadowRoot><code>mode</code></dfn> getter steps are to return
<a>this</a>'s <a for=ShadowRoot>mode</a>.</p>

<p>The <dfn attribute for=ShadowRoot><code>delegatesFocus</code></dfn> getter steps are to return
<a>this</a>'s <a for=ShadowRoot>delegates focus</a>.</p>

<p>The <dfn attribute for=ShadowRoot><code>slotAssignment</code></dfn> getter steps are to return
<a>this</a>'s <a for=ShadowRoot>slot assignment</a>.

<p>The <dfn attribute for=ShadowRoot><code>host</code></dfn> getter steps are to return
<a>this</a>'s <a for=DocumentFragment>host</a>.

<p>The <dfn attribute for=ShadowRoot><code>onslotchange</code></dfn> attribute is an
<a>event handler IDL attribute</a> for the
<dfn for=ShadowRoot export><code>onslotchange</code></dfn> <a>event handler</a>, whose
<a>event handler event type</a> is {{HTMLSlotElement/slotchange}}.

<hr>

<p>In <dfn export id=concept-shadow-including-tree-order>shadow-including tree order</dfn> is
<a>shadow-including preorder, depth-first traversal</a> of a <a>node tree</a>.
<dfn noexport>Shadow-including preorder, depth-first traversal</dfn> of a <a>node tree</a>
<var>tree</var> is preorder, depth-first traversal of <var>tree</var>, with for each
<a for=Element>shadow host</a> encountered in <var>tree</var>,
<a>shadow-including preorder, depth-first traversal</a> of that <a for=/>element</a>'s
<a for=Element>shadow root</a>'s <a>node tree</a> just after it is encountered.

<p>The <dfn export id=concept-shadow-including-root>shadow-including root</dfn> of an object is its
<a for=tree>root</a>'s <a for=DocumentFragment>host</a>'s <a>shadow-including root</a>, if the
object's <a for=tree>root</a> is a <a for=/>shadow root</a>; otherwise its <a for=tree>root</a>.

<p>An object <var>A</var> is a
<dfn export id=concept-shadow-including-descendant>shadow-including descendant</dfn> of an object
<var>B</var>, if <var>A</var> is a <a>descendant</a> of <var>B</var>, or <var>A</var>'s
<a for=tree>root</a> is a <a for=/>shadow root</a> and <var>A</var>'s <a for=tree>root</a>'s
<a for=DocumentFragment>host</a> is a <a>shadow-including inclusive descendant</a> of <var>B</var>.

<p>A
<dfn export id=concept-shadow-including-inclusive-descendant lt="shadow including inclusive descendant">所有后代节点(包括shadow tree中的节点)</dfn>
is an object or one of its <a>shadow-including descendants</a>.

<p>An object <var>A</var> is a
<dfn export id=concept-shadow-including-ancestor>shadow-including ancestor</dfn> of an object
<var>B</var>, if and only if <var>B</var> is a <a>shadow-including descendant</a> of <var>A</var>.

<p>A
<dfn export id=concept-shadow-including-inclusive-ancestor>shadow-including inclusive ancestor</dfn>
is an object or one of its <a>shadow-including ancestors</a>.

<p>A <a for=/>node</a> <var>A</var> is
<dfn export id=concept-closed-shadow-hidden>closed-shadow-hidden</dfn> from a <a for=/>node</a>
<var>B</var> if all of the following conditions are true:

<ul>
 <li><p><var>A</var>'s <a for=tree>root</a> is a <a for=/>shadow root</a>.

 <li><p><var>A</var>'s <a for=tree>root</a> is not a <a>shadow-including inclusive ancestor</a> of
 <var>B</var>.

 <li><p><var>A</var>'s <a for=tree>root</a> is a <a for=/>shadow root</a> whose
 <a for=ShadowRoot>mode</a> is "<code>closed</code>" or <var>A</var>'s <a for=tree>root</a>'s
 <a for=DocumentFragment>host</a> is <a>closed-shadow-hidden</a> from <var>B</var>.
</ul>

<p>To <dfn export lt="retarget|retargeting">retarget</dfn> an object <var>A</var> against an object
<var>B</var>, repeat these steps until they return an object:</p>

<ol>
 <li>
  <p>If one of the following is true

  <ul class=brief>
   <li><var>A</var> is not a <a for=/>node</a>
   <li><var>A</var>'s <a for=tree>root</a> is not a <a for=/>shadow root</a>
   <li><var>B</var> is a <a for=/>node</a> and <var>A</var>'s <a for=tree>root</a> is a
   <a>shadow-including inclusive ancestor</a> of <var>B</var>
  </ul>

  <p>then return <var>A</var>.

 <li><p>Set <var>A</var> to <var>A</var>'s <a for=tree>root</a>'s <a for=DocumentFragment>host</a>.
</ol>

<p class=note>The <a>retargeting</a> algorithm is used by <a lt=dispatch>event dispatch</a> as well
as other specifications, such as <cite>Fullscreen</cite>. [[FULLSCREEN]]


<h3 id=interface-element>Interface {{Element}}</h3>

<pre class=idl>
[Exposed=Window]
interface Element : Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString tagName;

  [CEReactions] attribute DOMString id;
  [CEReactions] attribute DOMString className;
  [SameObject, PutForwards=value] readonly attribute DOMTokenList classList;
  [CEReactions, Unscopable] attribute DOMString slot;

  boolean hasAttributes();
  [SameObject] readonly attribute NamedNodeMap attributes;
  sequence&lt;DOMString> getAttributeNames();
  DOMString? getAttribute(DOMString qualifiedName);
  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
  [CEReactions] undefined setAttribute(DOMString qualifiedName, DOMString value);
  [CEReactions] undefined setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);
  [CEReactions] undefined removeAttribute(DOMString qualifiedName);
  [CEReactions] undefined removeAttributeNS(DOMString? namespace, DOMString localName);
  [CEReactions] boolean toggleAttribute(DOMString qualifiedName, optional boolean force);
  boolean hasAttribute(DOMString qualifiedName);
  boolean hasAttributeNS(DOMString? namespace, DOMString localName);

  Attr? getAttributeNode(DOMString qualifiedName);
  Attr? getAttributeNodeNS(DOMString? namespace, DOMString localName);
  [CEReactions] Attr? setAttributeNode(Attr attr);
  [CEReactions] Attr? setAttributeNodeNS(Attr attr);
  [CEReactions] Attr removeAttributeNode(Attr attr);

  ShadowRoot attachShadow(ShadowRootInit init);
  readonly attribute ShadowRoot? shadowRoot;

  Element? closest(DOMString selectors);
  boolean matches(DOMString selectors);
  boolean webkitMatchesSelector(DOMString selectors); // legacy alias of .matches

  HTMLCollection getElementsByTagName(DOMString qualifiedName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);

  [CEReactions] Element? insertAdjacentElement(DOMString where, Element element); // legacy
  undefined insertAdjacentText(DOMString where, DOMString data); // legacy
};

dictionary ShadowRootInit {
  required ShadowRootMode mode;
  boolean delegatesFocus = false;
  SlotAssignmentMode slotAssignment = "named";
};
</pre>

<p>{{Element}} <a for=/>nodes</a> are simply known as
<dfn export id=concept-element lt=element>elements</dfn>.

<p><a for=/>Elements</a> have an associated
<dfn export id=concept-element-namespace for=Element>namespace</dfn>,
<dfn export id=concept-element-namespace-prefix for=Element>namespace prefix</dfn>,
<dfn export id=concept-element-local-name for=Element>local name</dfn>,
<dfn export id=concept-element-custom-element-state for=Element>custom element state</dfn>,
<dfn export id=concept-element-custom-element-definition for=Element>custom element definition</dfn>,
<dfn export id=concept-element-is-value for=Element><code>is</code> value</dfn>. When an
<a for=/>element</a> is <a lt="create an element">created</a>, all of these values are
initialized.

<p>An <a for=/>element</a>'s <a for=Element>custom element state</a> is one of
"<code>undefined</code>", "<code>failed</code>", "<code>uncustomized</code>",
"<code>precustomized</code>", or "<code>custom</code>". An <a for=/>element</a> whose
<a for=Element>custom element state</a> is "<code>uncustomized</code>" or "<code>custom</code>" is
said to be <dfn export id=concept-element-defined for=Element>defined</dfn>. An <a for=/>element</a>
whose <a for=Element>custom element state</a> is "<code>custom</code>" is said to be
<dfn export id=concept-element-custom for=Element>custom</dfn>.

<p class=note>Whether or not an element is <a for=Element>defined</a> is used to determine the
behavior of the '':defined'' pseudo-class. Whether or not an element is <a for=Element>custom</a> is
used to determine the behavior of the <a href=#mutation-algorithms>mutation algorithms</a>. The
"<code>failed</code>" and "<code>precustomized</code>" states are used to ensure that if a
<a>custom element constructor</a> fails to execute correctly the first time, it is not executed
again by an <a lt="upgrade an element">upgrade</a>.</p>

<div class=example id=example-c5b21302>
 <p>The following code illustrates elements in each of these four states:</p>

 <pre><code class=lang-html>
  &lt;!DOCTYPE html>
  &lt;script>
    window.customElements.define("sw-rey", class extends HTMLElement {})
    window.customElements.define("sw-finn", class extends HTMLElement {}, { extends: "p" })
    window.customElements.define("sw-kylo", class extends HTMLElement {
      constructor() {
        // super() intentionally omitted for this example
      }
    })
  &lt;/script>

  &lt;!-- "undefined" (not defined, not custom) -->
  &lt;sw-han>&lt;/sw-han>
  &lt;p is="sw-luke">&lt;/p>
  &lt;p is="asdf">&lt;/p>

  &lt;!-- "failed" (not defined, not custom) -->
  &lt;sw-kylo>&lt;/sw-kylo>

  &lt;!-- "uncustomized" (defined, not custom) -->
  &lt;p>&lt;/p>
  &lt;asdf>&lt;/asdf>

  &lt;!-- "custom" (defined, custom) -->
  &lt;sw-rey>&lt;/sw-rey>
  &lt;p is="sw-finn">&lt;/p>
 </code></pre>
</div>

<p><a for=/>Elements</a> also have an associated
<dfn export id=concept-element-shadow-root for=Element>shadow root</dfn> (null or a
<a for=/>shadow root</a>). It is null unless otherwise stated. An <a for=/>element</a> is a
<dfn export for=Element>shadow host</dfn> if its <a for=Element>shadow root</a> is non-null.

<p>An <a for=/>element</a>'s
<dfn export id=concept-element-qualified-name for=Element>qualified name</dfn> is its
<a for=Element>local name</a> if its <a for=Element>namespace prefix</a> is null; otherwise its
<a for=Element>namespace prefix</a>, followed by "<code>:</code>", followed by its
<a for=Element>local name</a>.

<p>An <a for=/>element</a>'s <dfn for=Element>HTML-uppercased qualified name</dfn> is the return
value of these steps:

<ol>
 <li><p>Let <var>qualifiedName</var> be <a>this</a>'s <a for=Element>qualified name</a>.

 <li><p>If <a>this</a> is in the <a>HTML namespace</a> and its <a for=Node>node document</a> is an
 <a>HTML document</a>, then set <var>qualifiedName</var> to <var>qualifiedName</var> in
 <a>ASCII uppercase</a>.

 <li>Return <var>qualifiedName</var>.
</ol>

<p class=note>User agents could optimize <a for=Element>qualified name</a> and
<a for=Element>HTML-uppercased qualified name</a> by storing them in internal slots.

<p>To
<dfn export id=concept-create-element lt="create an element|creating an element">create an element</dfn>,
given a <var>document</var>, <var>localName</var>, <var>namespace</var>, and optional
<var>prefix</var>, <var>is</var>, and <var>synchronous custom elements flag</var>, run these steps:

<ol>
 <li><p>If <var>prefix</var> was not given, let <var>prefix</var> be null.

 <li><p>If <var>is</var> was not given, let <var>is</var> be null.

 <li><p>Let <var>result</var> be null.

 <li><p>Let <var>definition</var> be the result of
 <a lt="look up a custom element definition">looking up a custom element definition</a> given
 <var>document</var>, <var>namespace</var>, <var>localName</var>, and <var>is</var>.

 <li>
  <p>If <var>definition</var> is non-null, and <var>definition</var>'s
  <a for="custom element definition">name</a> is not equal to its
  <a for="custom element definition">local name</a> (i.e., <var>definition</var> represents a
  <a>customized built-in element</a>), then:

  <ol>
   <li><p>Let <var>interface</var> be the <a>element interface</a> for <var>localName</var> and the
   <a>HTML namespace</a>.

   <li><p>Set <var>result</var> to a new <a for=/>element</a> that implements <var>interface</var>,
   with no attributes, <a for=Element>namespace</a> set to the <a>HTML namespace</a>,
   <a for=Element>namespace prefix</a> set to <var>prefix</var>, <a for=Element>local name</a> set
   to <var>localName</var>, <a for=Element>custom element state</a> set to "<code>undefined</code>",
   <a for=Element>custom element definition</a> set to null,
   <a for=Element><code>is</code> value</a> set to <var>is</var>, and <a for=Node>node document</a> set to
   <var>document</var>.

   <li>
    <p>If the <var>synchronous custom elements flag</var> is set, then run this step while
    catching any exceptions:

    <ol>
     <li><p><a lt="upgrade an element">Upgrade</a> <var>element</var> using <var>definition</var>.
    </ol>

    <p>If this step threw an exception, then:</p>

    <ol>
     <li><p><a>Report the exception</a>.

     <li><p>Set <var>result</var>'s <a for=Element>custom element state</a> to
     "<code>failed</code>".
    </ol>
   </li>

   <li><p>Otherwise, <a>enqueue a custom element upgrade reaction</a> given <var>result</var> and
   <var>definition</var>.
  </ol>
 </li>

 <li>
  <p>Otherwise, if <var>definition</var> is non-null, then:

  <ol>
   <li>
    <p>If the <var>synchronous custom elements flag</var> is set, then run these steps while
    catching any exceptions:

    <ol>
     <li><p>Let <var>C</var> be <var>definition</var>'s
     <a for="custom element definition">constructor</a>.

     <li><p>Set <var>result</var> to the result of <a>constructing</a> <var>C</var>, with no
     arguments.

     <li><p>Assert: <var>result</var>'s <a for=Element>custom element state</a> and
     <a for=Element>custom element definition</a> are initialized.

     <li>
      <p>Assert: <var>result</var>'s <a for=Element>namespace</a> is the <a>HTML namespace</a>.

      <p class=note>IDL enforces that <var>result</var> is an {{HTMLElement}} object, which all use
      the <a>HTML namespace</a>.

     <li><p>If <var>result</var>'s <a for=Element>attribute list</a> <a for=list>is not empty</a>,
     then <a>throw</a> a "{{NotSupportedError!!exception}}" {{DOMException}}.

     <li><p>If <var>result</var> has <a for=tree>children</a>, then <a>throw</a> a
     "{{NotSupportedError!!exception}}" {{DOMException}}.

     <li><p>If <var>result</var>'s <a for=tree>parent</a> is not null, then <a>throw</a> a
     "{{NotSupportedError!!exception}}" {{DOMException}}.

     <li><p>If <var>result</var>'s <a for=Node>node document</a> is not <var>document</var>, then
     <a>throw</a> a "{{NotSupportedError!!exception}}" {{DOMException}}.

     <li><p>If <var>result</var>'s <a for=Element>local name</a> is not equal to
     <var>localName</var>, then <a>throw</a> a "{{NotSupportedError!!exception}}" {{DOMException}}.

     <li><p>Set <var>result</var>'s <a for=Element>namespace prefix</a> to <var>prefix</var>.

     <li><p>Set <var>result</var>'s <a for=Element><code>is</code> value</a> to null.
    </ol>

    <p>If any of these steps threw an exception, then:</p>

    <ol>
     <li><p><a>Report the exception</a>.

     <li><p>Set <var>result</var> to a new <a for=/>element</a> that implements the
     {{HTMLUnknownElement}} interface, with no attributes, <a for=Element>namespace</a> set to the
     <a>HTML namespace</a>, <a for=Element>namespace prefix</a> set to <var>prefix</var>,
     <a for=Element>local name</a> set to <var>localName</var>,
     <a for=Element>custom element state</a> set to "<code>failed</code>",
     <a for=Element>custom element definition</a> set to null,
     <a for=Element><code>is</code> value</a> set to null, and <a for=Node>node document</a> set to
     <var>document</var>.
    </ol>
   </li>

   <li>
    <p>Otherwise:

    <ol>
     <li><p>Set <var>result</var> to a new <a for=/>element</a> that implements the {{HTMLElement}}
     interface, with no attributes, <a for=Element>namespace</a> set to the <a>HTML namespace</a>,
     <a for=Element>namespace prefix</a> set to <var>prefix</var>, <a for=Element>local name</a> set
     to <var>localName</var>, <a for=Element>custom element state</a> set to
     "<code>undefined</code>", <a for=Element>custom element definition</a> set to null,
     <a for=Element><code>is</code> value</a> set to null, and <a for=Node>node document</a> set to
     <var>document</var>.

     <li><p><a>Enqueue a custom element upgrade reaction</a> given <var>result</var> and
     <var>definition</var>.
    </ol>
   </li>
  </ol>
 </li>

 <li>
  <p>Otherwise:

  <ol>
   <li><p>Let <var>interface</var> be the <a>element interface</a> for <var>localName</var> and
   <var>namespace</var>.

   <li><p>Set <var>result</var> to a new <a for=/>element</a> that implements <var>interface</var>,
   with no attributes, <a for=Element>namespace</a> set to <var>namespace</var>,
   <a for=Element>namespace prefix</a> set to <var>prefix</var>, <a for=Element>local name</a> set
   to <var>localName</var>, <a for=Element>custom element state</a> set to
   "<code>uncustomized</code>", <a for=Element>custom element definition</a> set to null,
   <a for=Element><code>is</code> value</a> set to <var>is</var>, and <a for=Node>node document</a> set to
   <var>document</var>.

   <li><p>If <var>namespace</var> is the <a>HTML namespace</a>, and either <var>localName</var> is a
   <a>valid custom element name</a> or <var>is</var> is non-null, then set <var>result</var>'s
   <a for=Element>custom element state</a> to "<code>undefined</code>".
  </ol>
 </li>

 <li><p>Return <var>result</var>.
</ol>

<p><a for=/>Elements</a> also have an
<dfn export id=concept-element-attribute for=Element>attribute list</dfn>, which is a
<a for=/>list</a> exposed through a {{NamedNodeMap}}. Unless explicitly given when an
<a for=/>element</a> is created, its <a for=Element>attribute list</a> <a for=list>is empty</a>.

<p>An <a for=/>element</a>
<dfn export id=concept-element-attribute-has lt="has an attribute">has</dfn> an <a>attribute</a>
<var>A</var> if its <a for=Element>attribute list</a> <a for=list>contains</a> <var>A</var>.

<p>This and <a lt="other applicable specifications">other specifications</a> may define
<dfn export id=concept-element-attributes-change-ext>attribute change steps</dfn> for
<a for=/>elements</a>. The algorithm is passed <var>element</var>, <var>localName</var>,
<var>oldValue</var>, <var>value</var>, and <var>namespace</var>.

<p>To <dfn noexport>handle attribute changes</dfn> for an <a>attribute</a> <var>attribute</var> with
<var>element</var>, <var>oldValue</var>, and <var>newValue</var>, run these steps:

<ol>
 <li><p><a>Queue a mutation record</a> of "<code>attributes</code>" for <var>element</var> with
 <var>attribute</var>'s <a for=Attr>local name</a>, <var>attribute</var>'s
 <a for=Attr>namespace</a>, <var>oldValue</var>, « », « », null, and null.

 <li><p>If <var>element</var> is <a for=Element>custom</a>, then
 <a>enqueue a custom element callback reaction</a> with <var>element</var>, callback name
 "<code>attributeChangedCallback</code>", and an argument list containing <var>attribute</var>'s
 <a for=Attr>local name</a>, <var>oldValue</var>, <var>newValue</var>, and <var>attribute</var>'s
 <a for=Attr>namespace</a>.

 <li><p>Run the <a>attribute change steps</a> with <var>element</var>, <var>attribute</var>'s
 <a for=Attr>local name</a>, <var>oldValue</var>, <var>newValue</var>, and <var>attribute</var>'s
 <a for=Attr>namespace</a>.
</ol>

<p>To <dfn export id=concept-element-attributes-change lt="change an attribute">change</dfn> an
<a>attribute</a> <var>attribute</var> to <var>value</var>, run these steps:

<ol>
 <li><p><a>Handle attribute changes</a> for <var>attribute</var> with <var>attribute</var>'s
 <a for=Attr>element</a>, <var>attribute</var>'s <a for=Attr>value</a>, and <var>value</var>.

 <li><p>Set <var>attribute</var>'s <a for=Attr>value</a> to <var>value</var>.
</ol>

<p>To <dfn export id=concept-element-attributes-append lt="append an attribute">append</dfn> an
<a>attribute</a> <var>attribute</var> to an <a for=/>element</a> <var>element</var>, run these
steps:

<ol>
 <li><p><a>Handle attribute changes</a> for <var>attribute</var> with <var>element</var>, null, and
 <var>attribute</var>'s <a for=Attr>value</a>.

 <li><p><a for=list>Append</a> <var>attribute</var> to <var>element</var>'s
 <a for=Element>attribute list</a>.

 <li><p>Set <var>attribute</var>'s <a for=Attr>element</a> to <var>element</var>.
</ol>

<p>To <dfn export id=concept-element-attributes-remove lt="remove an attribute">remove</dfn> an
<a>attribute</a> <var>attribute</var>, run these steps:

<ol>
 <li><p><a>Handle attribute changes</a> for <var>attribute</var> with <var>attribute</var>'s
 <a for=Attr>element</a>, <var>attribute</var>'s <a for=Attr>value</a>, and null.

 <li><a for=list>Remove</a> <var>attribute</var> from <var>attribute</var>'s
 <a for=Attr>element</a>'s <a for=Element>attribute list</a>.

 <li><p>Set <var>attribute</var>'s <a for=Attr>element</a> to null.
</ol>

<p>To <dfn export id=concept-element-attributes-replace lt="replace an attribute">replace</dfn> an
<a>attribute</a> <var>oldAttr</var> with an <a>attribute</a> <var>newAttr</var>, run these steps:

<ol>
 <li><p><a>Handle attribute changes</a> for <var>oldAttr</var> with <var>oldAttr</var>'s
 <a for=Attr>element</a>, <var>oldAttr</var>'s <a for=Attr>value</a>, and <var>newAttr</var>'s
 <a for=Attr>value</a>.

 <li><p><a for=list>Replace</a> <var>oldAttr</var> by <var>newAttr</var> in <var>oldAttr</var>'s
 <a for=Attr>element</a>'s <a for=Element>attribute list</a>.

 <li><p>Set <var>newAttr</var>'s <a for=Attr>element</a> to <var>oldAttr</var>'s
 <a for=Attr>element</a>.

 <li><p>Set <var>oldAttr</var>'s <a for=Attr>element</a> to null.
</ol>

<hr>

<div algorithm>
<p>To <dfn export id=concept-element-attributes-get-by-name>get an attribute by name</dfn> given a
string <var>qualifiedName</var> and an <a for=/>element</a> <var>element</var>:

<ol>
 <li><p>If <var>element</var> is in the <a>HTML namespace</a> and its <a for=Node>node document</a>
 is an <a>HTML document</a>, then set <var>qualifiedName</var> to <var>qualifiedName</var> in
 <a>ASCII lowercase</a>.

 <li><p>Return the first <a>attribute</a> in <var>element</var>'s <a for=Element>attribute list</a>
 whose <a for=Attr>qualified name</a> is <var>qualifiedName</var>; otherwise null.
</ol>
</div>

<div algorithm>
<p>To
<dfn export id=concept-element-attributes-get-by-namespace>get an attribute by namespace and local name</dfn>
given null or a string <var>namespace</var>, a string <var>localName</var>, and an
<a for=/>element</a> <var>element</var>:

<ol>
 <li><p>If <var>namespace</var> is the empty string, then set it to null.

 <li><p>Return the <a>attribute</a> in <var>element</var>'s <a for=Element>attribute list</a> whose
 <a for=Attr>namespace</a> is <var>namespace</var> and <a for=Attr>local name</a> is
 <var>localName</var>, if any; otherwise null.
</ol>
</div>

<div algorithm>
<p>To <dfn export id=concept-element-attributes-get-value>get an attribute value</dfn> given an
<a for=/>element</a> <var>element</var>, a string <var>localName</var>, and an optional null or
string <var>namespace</var> (default null):</p>

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.</p></li>

 <li><p>If <var>attr</var> is null, then return the empty string.</p></li>

 <li><p>Return <var>attr</var>'s <a for=Attr>value</a>.</p></li>
</ol>
</div>

<div algorithm>
<p>To <dfn export id=concept-element-attributes-set>set an attribute</dfn> given an
<a for=/>attribute</a> <var>attr</var> and an <a for=/>element</a> <var>element</var>:

<ol>
 <li><p>If <var>attr</var>'s <a for=Attr>element</a> is neither null nor <var>element</var>,
 <a>throw</a> an "{{InUseAttributeError!!exception}}" {{DOMException}}.

 <li><p>Let <var>oldAttr</var> be the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a> given
 <var>attr</var>'s <a for=Attr>namespace</a>, <var>attr</var>'s <a for=Attr>local name</a>, and
 <var>element</var>.

 <li><p>If <var>oldAttr</var> is <var>attr</var>, return <var>attr</var>.

 <li><p>If <var>oldAttr</var> is non-null, then <a lt="replace an attribute">replace</a>
 <var>oldAttr</var> with <var>attr</var>.

 <li><p>Otherwise, <a lt="append an attribute">append</a> <var>attr</var> to <var>element</var>.

 <li><p>Return <var>oldAttr</var>.
</ol>
</div>

<div algorithm>
<p>To <dfn export id=concept-element-attributes-set-value>set an attribute value</dfn> given an
<a for=/>element</a> <var>element</var>, a string <var>localName</var>, a string <var>value</var>,
an optional null or string <var>prefix</var> (default null), and an optional null or string
<var>namespace</var> (default null):

<ol>
 <li>Let <var>attribute</var> be the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.

 <li>If <var>attribute</var> is null, create an <a>attribute</a> whose <a for=Attr>namespace</a> is
 <var>namespace</var>, <a for=Attr>namespace prefix</a> is <var>prefix</var>,
 <a for=Attr>local name</a> is <var>localName</var>, <a for=Attr>value</a> is <var>value</var>, and
 <a for=Node>node document</a> is <var>element</var>'s <a for=Node>node document</a>, then
 <a lt="append an attribute">append</a> this <a>attribute</a> to <var>element</var>, and then
 return.

 <li><p><a lt="change an attribute">Change</a> <var>attribute</var> to <var>value</var>.
</ol>
</div>

<div algorithm>
<p>To <dfn export id=concept-element-attributes-remove-by-name>remove an attribute by name</dfn>
given a string <var>qualifiedName</var> and an <a for=/>element</a> <var>element</var>:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a lt="get an attribute by name">getting an attribute</a> given <var>qualifiedName</var> and
 <var>element</var>.

 <li><p>If <var>attr</var> is non-null, then <a lt="remove an attribute">remove</a> <var>attr</var>.

 <li><p>Return <var>attr</var>.
</ol>
</div>

<div algorithm>
<p>To
<dfn export id=concept-element-attributes-remove-by-namespace>remove an attribute by namespace and local name</dfn>
given null or a string <var>namespace</var>, a string <var>localName</var>, and an
<a for=/>element</a> <var>element</var>:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.

 <li><p>If <var>attr</var> is non-null, then <a lt="remove an attribute">remove</a> <var>attr</var>.

 <li><p>Return <var>attr</var>.
</ol>
</div>

<hr>

<p>An <a for=/>element</a> can have an associated
<dfn export for=Element id=concept-id lt="ID">unique identifier (ID)</dfn>

<p class=note>Historically <a for=/>elements</a> could have multiple identifiers e.g., by using
the HTML <code>id</code> <a>attribute</a> and a DTD. This specification makes <a for=Element>ID</a>
a concept of the DOM and allows for only one per <a for=/>element</a>, given by an
<a lt="named attribute"><code>id</code> attribute</a>.

<p>Use these <a>attribute change steps</a> to update an <a for=/>element</a>'s
<a for=Element>ID</a>:

<ol>
 <li><p>If <var>localName</var> is <code>id</code>, <var>namespace</var> is null, and
 <var>value</var> is null or the empty string, then unset <var>element</var>'s
 <a for=Element>ID</a>.

 <li><p>Otherwise, if <var>localName</var> is <code>id</code>, <var>namespace</var> is null, then
 set <var>element</var>'s <a for=Element>ID</a> to <var>value</var>.
</ol>

<p class=note>While this specification defines requirements for <code>class</code>,
<code>id</code>, and <code>slot</code> <a>attributes</a> on any <a for=/>element</a>, it makes no
claims as to whether using them is conforming or not.

<hr>

<p>A <a for=/>node</a>'s <a for=tree>parent</a> of type {{Element}} is known as its
<dfn export>parent element</dfn>. If the <a for=/>node</a> has a
<a for=tree>parent</a> of a different type, its
<a>parent element</a> is null.

<hr>

<dl class=domintro>
 <dt><var>namespace</var> = <var>element</var> . {{Element/namespaceURI}}
 <dd>Returns the <a for=Element>namespace</a>.

 <dt><var>prefix</var> = <var>element</var> . {{Element/prefix}}
 <dd>Returns the
 <a for=Element>namespace prefix</a>.

 <dt><var>localName</var> = <var>element</var> . {{Element/localName}}
 <dd>Returns the
 <a for=Element>local name</a>.

 <dt><var>qualifiedName</var> = <var>element</var> . {{Element/tagName}}
 <dd>Returns the <a for=Element>HTML-uppercased qualified name</a>.
</dl>

<p>The <dfn attribute for=Element><code>namespaceURI</code></dfn> getter steps are to return
<a>this</a>'s <a for=Element>namespace</a>.

<p>The <dfn attribute for=Element><code>prefix</code></dfn> getter steps are to return
<a>this</a>'s <a for=Element>namespace prefix</a>.

<p>The <dfn attribute for=Element><code>localName</code></dfn> getter steps are to return
<a>this</a>'s <a for=Element>local name</a>.

<p>The <dfn attribute for=Element><code>tagName</code></dfn> getter steps are to return
<a>this</a>'s <a for=Element>HTML-uppercased qualified name</a>.

<hr>

<dl class=domintro>
 <dt><code><var>element</var> . <a attribute for=Element>id</a> [ = <var>value</var> ]</code>
 <dd><p>Returns the value of <var>element</var>'s <code>id</code> content attribute. Can be set to
 change it.

 <dt><code><var>element</var> . <a attribute for=Element>className</a> [ = <var>value</var> ]</code>
 <dd><p>Returns the value of <var>element</var>'s <code>class</code> content attribute. Can be set
 to change it.

 <dt><code><var>element</var> . <a attribute for=Element>classList</a></code>
 <dd><p>Allows for manipulation of <var>element</var>'s <code>class</code> content attribute as a
 set of whitespace-separated tokens through a {{DOMTokenList}} object.

 <dt><code><var>element</var> . <a attribute for=Element>slot</a> [ = <var>value</var> ]</code>
 <dd><p>Returns the value of <var>element</var>'s <code>slot</code> content attribute. Can be set to
 change it.
</dl>

<p>IDL attributes that are defined to <dfn export for=Attr id=concept-reflect>reflect</dfn> a
content <a>attribute</a> of a given <var>name</var>, must have a getter and setter that follow these
steps:</p>

<dl>
 <dt>getter
 <dd><p>Return the result of running <a>get an attribute value</a> given <a>this</a> and
 <var>name</var>.</p></dd>

 <dt>setter
 <dd><p><a>Set an attribute value</a> for <a>this</a> using <var>name</var> and the given value.
 </p></dd>
</dl>

<p>The <dfn attribute for=Element><code>id</code></dfn> attribute must <a for=Attr>reflect</a> the
"<code>id</code>" content attribute.

<p>The <dfn attribute for=Element><code>className</code></dfn> attribute must
<a for=Attr>reflect</a> the "<code>class</code>" content attribute.

<p>The <dfn attribute for=Element><code>classList</code></dfn> getter steps are to return a
{{DOMTokenList}} object whose associated <a for=/>element</a> is <a>this</a> and whose associated
<a>attribute</a>'s <a for=Attr>local name</a> is <code>class</code>. The <a>token set</a> of this
particular {{DOMTokenList}} object are also known as the <a for=/>element</a>'s
<dfn export for=Element id=concept-class lt="class">classes</dfn>.

<p>The <dfn attribute for=Element><code>slot</code></dfn> attribute must <a for=Attr>reflect</a> the
"<code>slot</code>" content attribute.

<p class=note><code>id</code>, <code>class</code>, and <code>slot</code> are effectively
superglobal attributes as they can appear on any element, regardless of that element's
namespace.</p>

<hr>

<dl class=domintro>
 <dt><code><var>element</var> . <a method for=Element lt=hasAttributes()>hasAttributes</a>()</code>
 <dd><p>Returns true if <var>element</var> has attributes; otherwise false.

 <dt><code><var>element</var> . <a method for=Element lt=getAttributeNames()>getAttributeNames</a>()</code>
 <dd><p>Returns the <a for=Attr>qualified names</a> of all <var>element</var>'s <a>attributes</a>.
 Can contain duplicates.

 <dt><code><var>element</var> . <a method for=Element lt=getAttribute()>getAttribute</a>(<var>qualifiedName</var>)</code>
 <dd><p>Returns <var>element</var>'s first <a>attribute</a> whose <a for=Attr>qualified name</a> is
 <var>qualifiedName</var>, and null if there is no such <a>attribute</a> otherwise.

 <dt><code><var>element</var> . <a method for=Element lt=getAttributeNS()>getAttributeNS</a>(<var>namespace</var>, <var>localName</var>)</code>
 <dd><p>Returns <var>element</var>'s <a>attribute</a> whose <a for=Attr>namespace</a> is
 <var>namespace</var> and <a for=Attr>local name</a> is <var>localName</var>, and null if there is
 no such <a>attribute</a> otherwise.

 <dt><code><var>element</var> . <a method for=Element lt=setAttribute()>setAttribute</a>(<var>qualifiedName</var>, <var>value</var>)</code>
 <dd><p>Sets the <a for=Attr>value</a> of <var>element</var>'s first <a>attribute</a> whose
 <a for=Attr>qualified name</a> is <var>qualifiedName</var> to <var>value</var>.

 <dt><code><var>element</var> . <a method for=Element lt=setAttributeNS()>setAttributeNS</a>(<var>namespace</var>, <var>localName</var>, <var>value</var>)</code>
 <dd><p>Sets the <a for=Attr>value</a> of <var>element</var>'s <a>attribute</a> whose
 <a for=Attr>namespace</a> is <var>namespace</var> and <a for=Attr>local name</a> is
 <var>localName</var> to <var>value</var>.

 <dt><code><var>element</var> . <a method for=Element lt=removeAttribute()>removeAttribute</a>(<var>qualifiedName</var>)</code>
 <dd><p>Removes <var>element</var>'s first <a>attribute</a> whose <a for=Attr>qualified name</a> is
 <var>qualifiedName</var>.

 <dt><code><var>element</var> . <a method for=Element lt=removeAttributeNS()>removeAttributeNS</a>(<var>namespace</var>, <var>localName</var>)</code>
 <dd><p>Removes <var>element</var>'s <a>attribute</a> whose <a for=Attr>namespace</a> is
 <var>namespace</var> and <a for=Attr>local name</a> is <var>localName</var>.

 <dt><code><var>element</var> . <a method for=Element lt=toggleAttribute()>toggleAttribute</a>(<var>qualifiedName</var> [, <var>force</var>])</code>
 <dd>
  <p>If <var>force</var> is not given, "toggles" <var>qualifiedName</var>, removing it if it is
  present and adding it if it is not present. If <var>force</var> is true, adds
  <var>qualifiedName</var>. If <var>force</var> is false, removes <var>qualifiedName</var>.

  <p>Returns true if <var>qualifiedName</var> is now present; otherwise false.

 <dt><code><var>element</var> . <a method for=Element lt=hasAttribute()>hasAttribute</a>(<var>qualifiedName</var>)</code>
 <dd><p>Returns true if <var>element</var> has an <a>attribute</a> whose
 <a for=Attr>qualified name</a> is <var>qualifiedName</var>; otherwise false.

 <dt><code><var>element</var> . <a method for=Element lt=hasAttributeNS()>hasAttributeNS</a>(<var>namespace</var>, <var>localName</var>)</code>
 <dd><p>Returns true if <var>element</var> has an <a>attribute</a> whose <a for=Attr>namespace</a>
 is <var>namespace</var> and <a for=Attr>local name</a> is <var>localName</var>.
</dl>

<p>The <dfn method for=Element><code>hasAttributes()</code></dfn> method steps are to return false
if <a>this</a>'s <a for=Element>attribute list</a> <a for=list>is empty</a>; otherwise true.

<p>The <dfn attribute for=Element><code>attributes</code></dfn> getter steps are to return the
associated {{NamedNodeMap}}.

<p>The <dfn method for=Element><code>getAttributeNames()</code></dfn> method steps are to return the
<a for=Attr>qualified names</a> of the <a>attributes</a> in <a>this</a>'s
<a for=Element>attribute list</a>, in order; otherwise a new <a for=/>list</a>.

<p class=note>These are not guaranteed to be unique.<!-- A theoretical getAttributeNamesNS() could
return an array of unique two-value-arrays. -->

<p>The <dfn method for=Element><code>getAttribute(<var>qualifiedName</var>)</code></dfn> method
steps are:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a lt="get an attribute by name">getting an attribute</a> given <var>qualifiedName</var> and
 <a>this</a>.

 <li><p>If <var>attr</var> is null, return null.

 <li><p>Return <var>attr</var>'s <a for=Attr>value</a>.
</ol>

<p>The
<dfn method for=Element><code>getAttributeNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <a>this</a>.

 <li><p>If <var>attr</var> is null, return null.

 <li><p>Return <var>attr</var>'s <a for=Attr>value</a>.
</ol>

<p>The
<dfn method for=Element><code>setAttribute(<var>qualifiedName</var>, <var>value</var>)</code></dfn>
method steps are:

<ol>
 <li><p>If <var>qualifiedName</var> does not match the <code><a type>Name</a></code> production in
 XML, then <a>throw</a> an "{{InvalidCharacterError!!exception}}" {{DOMException}}.

 <li><p>If <a>this</a> is in the <a>HTML namespace</a> and its <a for=Node>node document</a> is an
 <a>HTML document</a>, then set <var>qualifiedName</var> to <var>qualifiedName</var> in
 <a>ASCII lowercase</a>.

 <li><p>Let <var>attribute</var> be the first <a>attribute</a> in <a>this</a>'s
 <a for=Element>attribute list</a> whose <a for=Attr>qualified name</a> is <var>qualifiedName</var>,
 and null otherwise.
 <!-- This is step 2 of "get an attribute by name", modified as appropriate -->

 <li><p>If <var>attribute</var> is null, create an <a>attribute</a> whose
 <a for=Attr>local name</a> is <var>qualifiedName</var>, <a for=Attr>value</a> is
 <var>value</var>, and <a for=Node>node document</a> is <a>this</a>'s <a for=Node>node document</a>,
 then <a lt="append an attribute">append</a> this <a>attribute</a> to <a>this</a>, and then return.

 <li><p><a lt="change an attribute">Change</a> <var>attribute</var> to <var>value</var>.
</ol>

<p>The
<dfn method for=Element><code>setAttributeNS(<var>namespace</var>, <var>qualifiedName</var>, <var>value</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>namespace</var>, <var>prefix</var>, and <var>localName</var> be the result of
 passing <var>namespace</var> and <var>qualifiedName</var> to <a>validate and extract</a>.

 <li><p><a>Set an attribute value</a> for <a>this</a> using <var>localName</var>, <var>value</var>,
 and also <var>prefix</var> and <var>namespace</var>.
</ol>

<p>The
<dfn method for=Element><code>removeAttribute(<var>qualifiedName</var>)</code></dfn>
method steps are to <a lt="remove an attribute by name">remove an attribute</a> given
<var>qualifiedName</var> and <a>this</a>, and then return undefined.

<p>The
<dfn method for=Element><code>removeAttributeNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
method steps are to <a lt="remove an attribute by namespace and local name">remove an attribute</a>
given <var>namespace</var>, <var>localName</var>, and <a>this</a>, and then return undefined.

<p>The <dfn method for=Element><code>hasAttribute(<var>qualifiedName</var>)</code></dfn> method
steps are:

<ol>
 <li><p>If <a>this</a> is in the <a>HTML namespace</a> and its <a for=Node>node document</a> is an
 <a>HTML document</a>, then set <var>qualifiedName</var> to <var>qualifiedName</var> in
 <a>ASCII lowercase</a>.

 <li><p>Return true if <a>this</a> <a lt="has an attribute">has</a> an <a>attribute</a> whose
 <a for=Attr>qualified name</a> is <var>qualifiedName</var>; otherwise false.
</ol>

<p>The
<dfn method for=Element><code>toggleAttribute(<var>qualifiedName</var>, <var>force</var>)</code></dfn>
method steps are:

<ol>
 <li><p>If <var>qualifiedName</var> does not match the <code><a type>Name</a></code> production in
 XML, then <a>throw</a> an "{{InvalidCharacterError!!exception}}" {{DOMException}}.

 <li><p>If <a>this</a> is in the <a>HTML namespace</a> and its <a for=Node>node document</a> is an
 <a>HTML document</a>, then set <var>qualifiedName</var> to <var>qualifiedName</var> in
 <a>ASCII lowercase</a>.

 <li><p>Let <var>attribute</var> be the first <a>attribute</a> in <a>this</a>'s
 <a for=Element>attribute list</a> whose <a for=Attr>qualified name</a> is <var>qualifiedName</var>,
 and null otherwise.
 <!-- This is step 2 of "get an attribute by name", modified as appropriate -->

 <li>
  <p>If <var>attribute</var> is null, then:

  <ol>
   <li><p>If <var>force</var> is not given or is true, create an <a>attribute</a> whose
   <a for=Attr>local name</a> is <var>qualifiedName</var>, <a for=Attr>value</a> is the empty
   string, and <a for=Node>node document</a> is <a>this</a>'s <a for=Node>node document</a>, then
   <a lt="append an attribute">append</a> this <a>attribute</a> to <a>this</a>, and then return
   true.

   <li><p>Return false.
  </ol>

 <li><p>Otherwise, if <var>force</var> is not given or is false,
 <a lt="remove an attribute by name">remove an attribute</a> given <var>qualifiedName</var> and
 <a>this</a>, and then return false.

 <li><p>Return true.
</ol>

<p>The
<dfn method for=Element><code>hasAttributeNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
method steps are:

<ol>
 <li><p>If <var>namespace</var> is the empty string, then set it to null.

 <li>Return true if <a>this</a> <a lt="has an attribute">has</a> an <a>attribute</a> whose
 <a for=Attr>namespace</a> is <var>namespace</var> and <a for=Attr>local name</a> is
 <var>localName</var>; otherwise false.
</ol>

<hr>

<p>The <dfn method for=Element><code>getAttributeNode(<var>qualifiedName</var>)</code></dfn> method
steps are to return the result of <a lt="get an attribute by name">getting an attribute</a> given
<var>qualifiedName</var> and <a>this</a>.

<p>The
<dfn method for=Element><code>getAttributeNodeNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
method steps are to return the result of
<a lt="get an attribute by namespace and local name">getting an attribute</a> given
<var>namespace</var>, <var>localName</var>, and <a>this</a>.

<p>The <dfn method for=Element><code>setAttributeNode(<var>attr</var>)</code></dfn> and
<dfn method for=Element><code>setAttributeNodeNS(<var>attr</var>)</code></dfn> methods steps are to
return the result of <a lt="set an attribute">setting an attribute</a> given <var>attr</var> and
<a>this</a>.

<p>The <dfn method for=Element><code>removeAttributeNode(<var>attr</var>)</code></dfn> method steps
are:

<ol>
 <li><p>If <a>this</a>'s <a for=Element>attribute list</a> does not <a for=list>contain</a>
 <var>attr</var>, then <a>throw</a> a "{{NotFoundError!!exception}}" {{DOMException}}.

 <li><p><a lt="remove an attribute">Remove</a> <var>attr</var>.

 <li><p>Return <var>attr</var>.
</ol>

<hr>

<dl class=domintro>
 <dt><code>var shadow = <var>element</var> . {{attachShadow(init)}}</code>
 <dd><p>Creates a <a for=/>shadow root</a> for <var>element</var> and returns it.

 <dt><code>var shadow = <var>element</var> . {{shadowRoot}}</code>
 <dd><p>Returns <var>element</var>'s <a for=Element>shadow root</a>, if any, and if
 <a for=/>shadow root</a>'s <a for=ShadowRoot>mode</a> is "<code>open</code>", and null otherwise.
</dl>

<p>The <dfn method for=Element><code>attachShadow(<var>init</var>)</code></dfn> method steps are:

<ol>
 <li><p>If <a>this</a>'s <a for=Element>namespace</a> is not the <a>HTML namespace</a>,
 then <a>throw</a> a "{{NotSupportedError!!exception}}" {{DOMException}}.

 <li>
  <p>If <a>this</a>'s <a for=Element>local name</a> is not one of the following:

  <ul class=brief>
   <li>a <a>valid custom element name</a>
   <li>"<code>article</code>",
   "<code>aside</code>",
   "<code>blockquote</code>",
   "<code>body</code>",
   "<code>div</code>",
   "<code>footer</code>",
   "<code>h1</code>",
   "<code>h2</code>",
   "<code>h3</code>",
   "<code>h4</code>",
   "<code>h5</code>",
   "<code>h6</code>",
   "<code>header</code>",
   "<code>main</code>",
   "<code>nav</code>",
   "<code>p</code>",
   "<code>section</code>", or
   "<code>span</code>"
  </ul>

  <p>then <a>throw</a> a "{{NotSupportedError!!exception}}" {{DOMException}}.
 </li>

 <li>
  <p>If <a>this</a>'s <a for=Element>local name</a> is a <a>valid custom element name</a>, or
  <a>this</a>'s <a for=Element><code>is</code> value</a> is not null, then:

  <ol>
   <li><p>Let <var>definition</var> be the result of
   <a lt="look up a custom element definition">looking up a custom element definition</a> given
   <a>this</a>'s <a for=Node>node document</a>, its <a for=Element>namespace</a>, its
   <a for=Element>local name</a>, and its <a for=Element><code>is</code> value</a>.

   <li><p>If <var>definition</var> is not null and <var>definition</var>'s
   <a for="custom element definition">disable shadow</a> is true, then <a>throw</a> a
   "{{NotSupportedError!!exception}}" {{DOMException}}.
  </ol>
 </li>

 <li><p>If <a>this</a> is a <a for=Element>shadow host</a>, then <a>throw</a> an
 "{{NotSupportedError!!exception}}" {{DOMException}}.

 <li><p>Let <var>shadow</var> be a new <a for=/>shadow root</a> whose <a for=Node>node document</a>
 is <a>this</a>'s <a for=Node>node document</a>, <a for=DocumentFragment>host</a> is <a>this</a>,
 and <a for=ShadowRoot>mode</a> is <var>init</var>["{{ShadowRootInit/mode}}"].

 <li><p>Set <var>shadow</var>'s <a for=ShadowRoot>delegates focus</a> to
 <var>init</var>["{{ShadowRootInit/delegatesFocus}}"].

 <li><p>If <a>this</a>'s <a for=Element>custom element state</a> is "<code>precustomized</code>" or
 "<code>custom</code>", then set <var>shadow</var>'s
 <a for=ShadowRoot>available to element internals</a> to true.

 <li><p>Set <var>shadow</var>'s <a for=ShadowRoot>slot assignment</a> to
 <var>init</var>["{{ShadowRootInit/slotAssignment}}"].

 <li><p>Set <a>this</a>'s <a for=Element>shadow root</a> to <var>shadow</var>.

 <li><p>Return <var>shadow</var>.
</ol>

<p>The <dfn attribute for=Element><code>shadowRoot</code></dfn> getter steps are:

<ol>
 <li><p>Let <var>shadow</var> be <a>this</a>'s <a for=Element>shadow root</a>.

 <li><p>If <var>shadow</var> is null or its <a for=ShadowRoot>mode</a> is "<code>closed</code>",
 then return null.</p></li>

 <li><p>Return <var>shadow</var>.
</ol>

<hr>

<dl class=domintro>
 <dt><code><var>element</var> . {{closest(selectors)}}</code>
 <dd>Returns the first (starting at <var>element</var>)
 <a for=tree>inclusive ancestor</a> that matches
 <var>selectors</var>, and null otherwise.

 <dt><code><var>element</var> . {{matches(selectors)}}</code>
 <dd>Returns true if matching <var>selectors</var> against <var>element</var>'s <a for=tree>root</a>
 yields <var>element</var>; otherwise false.
</dl>

<p>The <dfn method for=Element><code>closest(<var>selectors</var>)</code></dfn> method steps are:

<ol>
 <li><p>Let <var>s</var> be the result of <a>parse a selector</a> from <var>selectors</var>.
 [[!SELECTORS4]]

 <li><p>If <var>s</var> is failure, then <a>throw</a> a "{{SyntaxError!!exception}}"
 {{DOMException}}.

 <li><p>Let <var>elements</var> be <a>this</a>'s <a for=tree>inclusive ancestors</a> that are
 <a for=/>elements</a>, in reverse <a>tree order</a>.

 <li><p>For each <var>element</var> in <var>elements</var>, if
 <a>match a selector against an element</a>, using <var>s</var>, <var>element</var>, and
 <a>scoping root</a> <a>this</a>, returns success, return <var>element</var>. [[!SELECTORS4]]

 <li><p>Return null.
</ol>

<p>The <dfn method for=Element><code>matches(<var>selectors</var>)</code></dfn> and
<dfn method for=Element><code>webkitMatchesSelector(<var>selectors</var>)</code></dfn> method steps
are:

<ol>
 <li><p>Let <var>s</var> be the result of <a>parse a selector</a> from <var>selectors</var>.
 [[!SELECTORS4]]

 <li><p>If <var>s</var> is failure, then <a>throw</a> a "{{SyntaxError!!exception}}"
 {{DOMException}}.

 <li><p>If the result of <a>match a selector against an element</a>, using <var>s</var>,
 <a>this</a>, and <a>scoping root</a> <a>this</a>, returns success, then return true; otherwise,
 return false. [[!SELECTORS4]]
</ol>

<hr>

<p>The <dfn method for=Element><code>getElementsByTagName(<var>qualifiedName</var>)</code></dfn>
method steps are to return the <a>list of elements with qualified name <var>qualifiedName</var></a>
for <a>this</a>.

<p>The
<dfn method for=Element><code>getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
method steps are to return the <a>list of elements with namespace <var>namespace</var> and local
name <var>localName</var></a> for <a>this</a>.

<p>The <dfn method for=Element><code>getElementsByClassName(<var>classNames</var>)</code></dfn>
method steps are to return the <a>list of elements with class names <var>classNames</var></a> for
<a>this</a>.

<hr>

<p>To <dfn>insert adjacent</dfn>, given an <a for=/>element</a> <var>element</var>, string
<var>where</var>, and a <a for=/>node</a> <var>node</var>, run the steps associated with the first
<a>ASCII case-insensitive</a> match for <var>where</var>:

<dl class=switch>
 <dt>"<code>beforebegin</code>"
 <dd>
  <p>If <var>element</var>'s <a for=tree>parent</a> is null, return null.

  <p>Return the result of <a>pre-inserting</a> <var>node</var> into <var>element</var>'s
  <a for=tree>parent</a> before <var>element</var>.

 <dt>"<code>afterbegin</code>"
 <dd><p>Return the result of <a>pre-inserting</a> <var>node</var> into <var>element</var> before
 <var>element</var>'s <a for=tree>first child</a>.

 <dt>"<code>beforeend</code>"
 <dd><p>Return the result of <a>pre-inserting</a> <var>node</var> into <var>element</var> before
 null.

 <dt>"<code>afterend</code>"
 <dd>
  <p>If <var>element</var>'s <a for=tree>parent</a> is null, return null.

  <p>Return the result of <a>pre-inserting</a> <var>node</var> into <var>element</var>'s
  <a for=tree>parent</a> before <var>element</var>'s <a for=tree>next sibling</a>.

 <dt>Otherwise</dt>
 <dd><p><a>Throw</a> a "{{SyntaxError!!exception}}" {{DOMException}}.
</dl>

<p>The
<dfn method for=Element><code>insertAdjacentElement(<var>where</var>, <var>element</var>)</code></dfn>
method steps are to return the result of running <a>insert adjacent</a>, give <a>this</a>,
<var>where</var>, and <var>element</var>.

<p>The
<dfn method for=Element><code>insertAdjacentText(<var>where</var>, <var>data</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>text</var> be a new {{Text}} <a for=/>node</a> whose <a for=CharacterData>data</a>
 is <var>data</var> and <a for=Node>node document</a> is <a>this</a>'s
 <a for=Node>node document</a>.

 <li><p>Run <a>insert adjacent</a>, given <a>this</a>, <var>where</var>, and <var>text</var>.
</ol>

<p class=note>This method returns nothing because it existed before we had a chance to design it.


<h4 id=interface-namednodemap>Interface {{NamedNodeMap}}</h4>

<pre class=idl>
[Exposed=Window,
 LegacyUnenumerableNamedProperties]
interface NamedNodeMap {
  readonly attribute unsigned long length;
  getter Attr? item(unsigned long index);
  getter Attr? getNamedItem(DOMString qualifiedName);
  Attr? getNamedItemNS(DOMString? namespace, DOMString localName);
  [CEReactions] Attr? setNamedItem(Attr attr);
  [CEReactions] Attr? setNamedItemNS(Attr attr);
  [CEReactions] Attr removeNamedItem(DOMString qualifiedName);
  [CEReactions] Attr removeNamedItemNS(DOMString? namespace, DOMString localName);
};
</pre>

<p>A {{NamedNodeMap}} has an associated
<dfn export id=concept-namednodemap-element for=NamedNodeMap>element</dfn> (an
<a for=/>element</a>).

<p>A {{NamedNodeMap}} object's
<dfn export id=concept-namednodemap-attribute for=NamedNodeMap>attribute list</dfn> is its
<a for=NamedNodeMap>element</a>'s
<a for=Element>attribute list</a>.

<hr>

<p>A {{NamedNodeMap}} object's <a>supported property indices</a> are the numbers in the
range zero to its <a for=NamedNodeMap>attribute list</a>'s <a for=list>size</a> minus one, unless
the <a for=NamedNodeMap>attribute list</a> <a for=list>is empty</a>, in which case there are no
<a>supported property indices</a>.

<p>The <dfn attribute for=NamedNodeMap><code>length</code></dfn> getter steps are to return
the <a for=NamedNodeMap>attribute list</a>'s <a for=list>size</a>.

<p>The <dfn method for=NamedNodeMap><code>item(<var>index</var>)</code></dfn> method steps are:

<ol>
 <li><p>If <var>index</var> is equal to or greater than <a>this</a>'s
 <a for=NamedNodeMap>attribute list</a>'s <a for=list>size</a>, then return null.

 <li><p>Otherwise, return <a>this</a>'s <a for=NamedNodeMap>attribute list</a>[<var>index</var>].
</ol>

<p>A {{NamedNodeMap}} object's <a>supported property names</a> are the return value of running these
steps:

<ol>
 <li><p>Let <var>names</var> be the <a for=Attr>qualified names</a> of the <a>attributes</a> in this
 {{NamedNodeMap}} object's <a for=NamedNodeMap>attribute list</a>, with duplicates omitted, in
 order.
 <!-- Even though not all names that map to an attribute are listed, due to lowercasing, ECMAScript
      invariants are not violated. https://github.com/whatwg/dom/issues/141#issuecomment-168753410
      has details. -->

 <li>
  <p>If this {{NamedNodeMap}} object's <a for=NamedNodeMap>element</a> is in the
  <a>HTML namespace</a> and its <a for=Node>node document</a> is an <a>HTML document</a>, then
  <a for=list>for each</a> <var>name</var> in <var>names</var>:

  <ol>
   <li><p>Let <var>lowercaseName</var> be <var>name</var>, in <a>ASCII lowercase</a>.

   <li><p>If <var>lowercaseName</var> is not equal to <var>name</var>, remove <var>name</var> from
   <var>names</var>.
  </ol>

 <li><p>Return <var>names</var>.
</ol>

<p>The <dfn method for=NamedNodeMap><code>getNamedItem(<var>qualifiedName</var>)</code></dfn>
method steps are to return the result of <a lt="get an attribute by name">getting an attribute</a>
given <var>qualifiedName</var> and <a for=NamedNodeMap>element</a>.

<p>The
<dfn method for=NamedNodeMap><code>getNamedItemNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
method steps are to return the result of
<a lt="get an attribute by namespace and local name">getting an attribute</a> given
<var>namespace</var>, <var>localName</var>, and <a for=NamedNodeMap>element</a>.

<p>The <dfn method for=NamedNodeMap><code>setNamedItem(<var>attr</var>)</code></dfn> and
<dfn method for=NamedNodeMap><code>setNamedItemNS(<var>attr</var>)</code></dfn> method steps are
to return the result of <a lt="set an attribute">setting an attribute</a> given <var>attr</var> and
<a for=NamedNodeMap>element</a>.

<p>The <dfn method for=NamedNodeMap><code>removeNamedItem(<var>qualifiedName</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a lt="remove an attribute by name">removing an attribute</a> given
 <var>qualifiedName</var> and <a for=NamedNodeMap>element</a>.

 <li><p>If <var>attr</var> is null, then <a>throw</a> a "{{NotFoundError!!exception}}"
 {{DOMException}}.

 <li><p>Return <var>attr</var>.
</ol>

<p>The
<dfn method for=NamedNodeMap><code>removeNamedItemNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a lt="remove an attribute by namespace and local name">removing an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <a for=NamedNodeMap>element</a>.

 <li><p>If <var>attr</var> is null, then <a>throw</a> a "{{NotFoundError!!exception}}"
 {{DOMException}}.

 <li><p>Return <var>attr</var>.
</ol>


<h4 id=interface-attr>Interface {{Attr}}</h4>

<pre class=idl>
[Exposed=Window]
interface Attr : Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString name;
  [CEReactions] attribute DOMString value;

  readonly attribute Element? ownerElement;

  readonly attribute boolean specified; // useless; always returns true
};</pre>

<p>{{Attr}} <a for=/>nodes</a> are simply known as
<dfn export id=concept-attribute lt="attribute">attributes</dfn>. They are sometimes referred
to as <em>content attributes</em> to avoid confusion with IDL attributes.

<a>Attributes</a> have a
<dfn export id=concept-attribute-namespace for=Attr>namespace</dfn> (null or a non-empty string),
<dfn export id=concept-attribute-namespace-prefix for=Attr>namespace prefix</dfn> (null or a non-empty string),
<dfn export id=concept-attribute-local-name for=Attr>local name</dfn> (a non-empty string),
<dfn export id=concept-attribute-value for=Attr>value</dfn> (a string), and
<dfn export id=concept-attribute-element for=Attr>element</dfn> (null or an
<a for=/>element</a>).

<p class=note>If designed today they would just have a name and value. ☹

<p>An <a>attribute</a>'s
<dfn export id=concept-attribute-qualified-name for=Attr>qualified name</dfn> is its
<a for=Attr>local name</a> if its <a for=Attr>namespace prefix</a> is null, and its
<a for=Attr>namespace prefix</a>, followed by "<code>:</code>", followed by its
<a for=Attr>local name</a>, otherwise.

<p class=note>User agents could have this as an internal slot as an optimization.

When an <a>attribute</a> is created, its
<a for=Attr>local name</a> is given. Unless explicitly
given when an <a>attribute</a> is created, its
<a for=Attr>namespace</a>,
<a for=Attr>namespace prefix</a>, and
<a for=Attr>element</a> are set to null, and its
<a for=Attr>value</a> is set to the empty string.

An
<dfn export id=concept-named-attribute lt="named attribute"><code><var>A</var></code> attribute</dfn>
is an <a>attribute</a> whose
<a for=Attr>local name</a> is
<code><var>A</var></code> and whose
<a for=Attr>namespace</a> and
<a for=Attr>namespace prefix</a> are
null.

<hr>

<p>The <dfn attribute for=Attr><code>namespaceURI</code></dfn> getter steps are to return
<a>this</a>'s <a for=Attr>namespace</a>.

<p>The <dfn attribute for=Attr><code>prefix</code></dfn> getter steps are to return <a>this</a>'s
<a for=Attr>namespace prefix</a>.

<p>The <dfn attribute for=Attr><code>localName</code></dfn> getter steps are to return
<a>this</a>'s <a for=Attr>local name</a>.

<p>The <dfn attribute for=Attr><code>name</code></dfn> getter steps are to return <a>this</a>'s
<a for=Attr>qualified name</a>.

<p>The <dfn attribute for=Attr><code>value</code></dfn> getter steps are to return <a>this</a>'s
<a for=Attr>value</a>.

<p>To <dfn>set an existing attribute value</dfn>, given an <a>attribute</a> <var>attribute</var> and
string <var>value</var>, run these steps:

<ol>
 <li><p>If <var>attribute</var>'s <a for=Attr>element</a> is null, then set <var>attribute</var>'s
 <a for=Attr>value</a> to <var>value</var>.

 <li><p>Otherwise, <a lt="change an attribute">change</a> <var>attribute</var> to <var>value</var>.
</ol>

<p>The {{Attr/value}} setter steps are to <a>set an existing attribute value</a> with <a>this</a>
and the given value.

<hr>

<p>The <dfn attribute for=Attr><code>ownerElement</code></dfn> getter steps are to return
<a>this</a>'s <a for=Attr>element</a>.

<hr>

<p>The <dfn attribute for=Attr><code>specified</code></dfn> getter steps are to return true.


<h3 id=interface-characterdata>Interface {{CharacterData}}</h3>

<pre class=idl>
[Exposed=Window]
interface CharacterData : Node {
  attribute [LegacyNullToEmptyString] DOMString data;
  readonly attribute unsigned long length;
  DOMString substringData(unsigned long offset, unsigned long count);
  undefined appendData(DOMString data);
  undefined insertData(unsigned long offset, DOMString data);
  undefined deleteData(unsigned long offset, unsigned long count);
  undefined replaceData(unsigned long offset, unsigned long count, DOMString data);
};
</pre>

<p class=note>{{CharacterData}} is an abstract interface. You cannot get a direct instance of it. It
is used by {{Text}}, {{ProcessingInstruction}}, and {{Comment}} <a for=/>nodes</a>.

<p>Each <a for=/>node</a> inheriting from the {{CharacterData}} interface has an associated mutable
string called <dfn export id=concept-cd-data for=CharacterData>data</dfn>.

<p>To <dfn export id=concept-cd-replace>replace data</dfn> of node <var>node</var> with offset
<var>offset</var>, count <var>count</var>, and data <var>data</var>, run these steps:

<ol>
 <li>Let <var>length</var> be <var>node</var>'s <a for=Node>length</a>.

 <li>If <var>offset</var> is greater than <var>length</var>, then <a>throw</a> an
 "{{IndexSizeError!!exception}}" {{DOMException}}.

 <li>If <var>offset</var> plus <var>count</var> is greater than <var>length</var>, then set
 <var>count</var> to <var>length</var> minus <var>offset</var>.

 <li><p><a>Queue a mutation record</a> of "<code>characterData</code>" for <var>node</var> with
 null, null, <var>node</var>'s <a for=CharacterData>data</a>, « », « », null, and null.

 <li>Insert <var>data</var> into <var>node</var>'s
 <a for=CharacterData>data</a> after <var>offset</var>
 <a>code units</a>.

 <li>Let <var>delete offset</var> be <var>offset</var> + <var>data</var>'s <a for=string>length</a>.

 <li>Starting from <var>delete offset</var>
 <a>code units</a>, remove
 <var>count</var>
 <a>code units</a> from
 <var>node</var>'s <a for=CharacterData>data</a>.

 <!-- ranges -->
 <li><p>For each <a>live range</a> whose <a for=range>start node</a> is <var>node</var> and
 <a for=range>start offset</a> is greater than <var>offset</var> but less than or equal to
 <var>offset</var> plus <var>count</var>, set its <a for=range>start offset</a> to
 <var>offset</var>.

 <li><p>For each <a>live range</a> whose <a for=range>end node</a> is <var>node</var> and
 <a for=range>end offset</a> is greater than <var>offset</var> but less than or equal to
 <var>offset</var> plus <var>count</var>, set its <a for=range>end offset</a> to <var>offset</var>.

 <li><p>For each <a>live range</a> whose <a for=range>start node</a> is <var>node</var> and
 <a for=range>start offset</a> is greater than <var>offset</var> plus <var>count</var>, increase its
 <a for=range>start offset</a> by <var>data</var>'s <a for=string>length</a> and decrease it by
 <var>count</var>.

 <li><p>For each <a>live range</a> whose <a for=range>end node</a> is <var>node</var> and
 <a for=range>end offset</a> is greater than <var>offset</var> plus <var>count</var>, increase its
 <a for=range>end offset</a> by <var>data</var>'s <a for=string>length</a> and decrease it by
 <var>count</var>.

 <li>If <var>node</var>'s <a>parent</a> is non-null, then run the <a>children changed steps</a> for
 <var>node</var>'s <a>parent</a>.
</ol>
<!-- delete happens after insert for better cursor positioning with editing
https://www.w3.org/Bugs/Public/show_bug.cgi?id=13153 -->

<!-- If you set a node's data to a new value (e.g., using the data
attribute):

IE 9: Acts like the node was deleted and recreated, moves the boundary
points up to the parent
Firefox 4: Resets the offset to 0, always
Chrome 11 dev: Resets the offset to 0, except it does nothing if the new
data is the same as the old data
Opera 11: Sets a start offset to 0 and an end offset to the end of the
data, always

The spec originally followed WebKit, since it seemed to make the most sense.
Opera's approach of setting end offsets to the length of the new data
arguably makes more sense, but that's debatable, and it's greatly
outnumbered. However, after some feedback by bzbarsky that checking for
equality is expensive, I removed the special case and matched Firefox:

https://www.w3.org/Bugs/Public/show_bug.cgi?id=13250

Authors who want WebKit-like behavior can always use replaceData() instead.

XXX replaceData is the same as setting data these days -->


To <dfn export for="CharacterData, Text, Comment, ProcessingInstruction" id=concept-cd-substring>substring data</dfn> with node
<var>node</var>, offset <var>offset</var>, and count
<var>count</var>, run these steps:

<ol>
 <li>Let <var>length</var> be <var>node</var>'s <a for=Node>length</a>.

 <li>If <var>offset</var> is greater than <var>length</var>, then <a>throw</a> an
 "{{IndexSizeError!!exception}}" {{DOMException}}.

 <li>If <var>offset</var> plus <var>count</var> is
 greater than <var>length</var>, return a string whose value is the
 <a>code units</a> from the
 <var>offset</var><sup>th</sup>
 <a>code unit</a> to the end of
 <var>node</var>'s <a for=CharacterData>data</a>, and then
 return.

 <li>Return a string whose value is the
 <a>code units</a> from the
 <var>offset</var><sup>th</sup>
 <a>code unit</a> to the
 <var>offset</var>+<var>count</var><sup>th</sup>
 <a>code unit</a> in <var>node</var>'s
 <a for=CharacterData>data</a>.
</ol>

<p>The <dfn attribute for=CharacterData><code>data</code></dfn> getter steps are to return
<a>this</a>'s <a for=CharacterData>data</a>. Its setter must <a>replace data</a> with node
<a>this</a>, offset 0, count <a>this</a>'s <a for=Node>length</a>, and data new value.

<p>The <dfn attribute for=CharacterData><code>length</code></dfn> getter steps are to return
<a>this</a>'s <a for=Node>length</a>.

<p>The
<dfn method for=CharacterData><code>substringData(<var>offset</var>, <var>count</var>)</code></dfn>
method steps are to return the result of running <a>substring data</a> with node <a>this</a>,
offset <var>offset</var>, and count <var>count</var>.

<p>The <dfn method for=CharacterData><code>appendData(<var>data</var>)</code></dfn> method steps are
to <a>replace data</a> with node <a>this</a>, offset <a>this</a>'s <a for=Node>length</a>, count 0,
and data <var>data</var>.

<p>The
<dfn method for=CharacterData><code>insertData(<var>offset</var>, <var>data</var>)</code></dfn>
method steps are to <a>replace data</a> with node <a>this</a>, offset <var>offset</var>, count 0,
and data <var>data</var>.

<p>The
<dfn method for=CharacterData><code>deleteData(<var>offset</var>, <var>count</var>)</code></dfn>
method steps are to <a>replace data</a> with node <a>this</a>, offset <var>offset</var>, count
<var>count</var>, and data the empty string.

<p>The
<dfn method for=CharacterData><code>replaceData(<var>offset</var>, <var>count</var>, <var>data</var>)</code></dfn>
method steps are to <a>replace data</a> with node <a>this</a>, offset <var>offset</var>, count
<var>count</var>, and data <var>data</var>.


<h3 id=interface-text>Interface {{Text}}</h3>

<pre class=idl>
[Exposed=Window]
interface Text : CharacterData {
  constructor(optional DOMString data = "");

  [NewObject] Text splitText(unsigned long offset);
  readonly attribute DOMString wholeText;
};
</pre>

<dl class=domintro>
 <dt><code><var>text</var> = new <a constructor lt=Text()>Text([<var>data</var> = ""])</a></code>
 <dd>Returns a new {{Text}} <a for=/>node</a> whose
 <a for=CharacterData>data</a> is <var>data</var>.

 <dt><code><var>text</var> . {{Text/splitText(offset)}}</code>
 <dd>Splits <a for=CharacterData>data</a> at the given
 <var>offset</var> and returns the remainder as {{Text}}
 <a for=/>node</a>.

 <dt><code><var>text</var> . {{Text/wholeText}}</code>
 <dd>Returns the combined <a for=CharacterData>data</a> of all direct
 {{Text}} <a for=/>node</a>
 <a for=tree>siblings</a>.
</dl>

<hr>

<p>An <dfn export>exclusive {{Text}} node</dfn> is a {{Text}} <a for=/>node</a> that is not a
{{CDATASection}} <a for=/>node</a>.

<p>The <dfn export>contiguous {{Text}} nodes</dfn> of a <a for=/>node</a> <var>node</var> are
<var>node</var>, <var>node</var>'s <a>previous sibling</a> {{Text}} <a for=/>node</a>, if any, and
its <a>contiguous <code>Text</code> nodes</a>, and <var>node</var>'s <a for=tree>next sibling</a>
{{Text}} <a for=/>node</a>, if any, and its <a>contiguous <code>Text</code> nodes</a>, avoiding any
duplicates.

<p>The <dfn export>contiguous exclusive {{Text}} nodes</dfn> of a <a for=/>node</a> <var>node</var>
are <var>node</var>, <var>node</var>'s <a>previous sibling</a>
<a>exclusive <code>Text</code> node</a>, if any, and its
<a>contiguous exclusive <code>Text</code> nodes</a>, and <var>node</var>'s
<a for=tree>next sibling</a> <a>exclusive <code>Text</code> node</a>, if any, and its
<a>contiguous exclusive <code>Text</code> nodes</a>, avoiding any duplicates.

<p>The <dfn export id=concept-child-text-content>child text content</dfn> of a <a for=/>node</a>
<var>node</var> is the <a for=string>concatenation</a> of the <a for=CharacterData>data</a> of all
the {{Text}} <a for=/>node</a> <a for=tree>children</a> of <var>node</var>, in <a>tree order</a>.

<p>The <dfn export id=concept-descendant-text-content>descendant text content</dfn> of a
<a for=/>node</a> <var>node</var> is the <a for=string>concatenation</a> of the
<a for=CharacterData>data</a> of all the {{Text}} <a for=/>node</a> <a>descendants</a> of
<var>node</var>, in <a>tree order</a>.

<hr>

<p>The <dfn constructor for=Text lt=Text(data)><code>new Text(<var>data</var>)</code></dfn>
constructor steps are to set <a>this</a>'s <a for=CharacterData>data</a> to <var>data</var> and
<a>this</a>'s <a for=Node>node document</a> to <a>current global object</a>'s
<a>associated <code>Document</code></a>.

<p>To <dfn export id=concept-text-split lt="split a Text node">split</dfn> a {{Text}}
<a for=/>node</a> <var>node</var> with offset <var>offset</var>, run these steps:

<ol>
 <li>Let <var>length</var> be <var>node</var>'s <a for=Node>length</a>.

 <li>If <var>offset</var> is greater than <var>length</var>, then <a>throw</a> an
 "{{IndexSizeError!!exception}}" {{DOMException}}.

 <li>Let <var>count</var> be <var>length</var> minus
 <var>offset</var>.

 <li>Let <var>new data</var> be the result of
 <a lt="substring data">substringing data</a> with node
 <var>node</var>, offset <var>offset</var>, and count
 <var>count</var>.

 <li>Let <var>new node</var> be a new {{Text}}
 <a for=/>node</a>, with the same
 <a for=Node>node document</a> as
 <var>node</var>. Set <var>new node</var>'s
 <a for=CharacterData>data</a> to <var>new data</var>.

 <li>Let <var>parent</var> be <var>node</var>'s
 <a for=tree>parent</a>.

 <li>
  <p>If <var>parent</var> is not null, then:

  <ol>
   <li><p><a for=/>Insert</a> <var>new node</var> into <var>parent</var> before <var>node</var>'s
   <a for=tree>next sibling</a>.
   <!-- Do this before we replace data, so that the data replacement won't
   mutate ranges prematurely:
   https://www.w3.org/Bugs/Public/show_bug.cgi?id=15325 -->

   <li><p>For each <a>live range</a> whose <a for=range>start node</a> is <var>node</var> and
   <a for=range>start offset</a> is greater than <var>offset</var>, set its
   <a for=range>start node</a> to <var>new node</var> and decrease its <a for=range>start offset</a>
   by <var>offset</var>.

   <li><p>For each <a>live range</a> whose <a for=range>end node</a> is <var>node</var> and
   <a for=range>end offset</a> is greater than <var>offset</var>, set its <a for=range>end node</a>
   to <var>new node</var> and decrease its <a for=range>end offset</a> by <var>offset</var>.

   <!-- This shit is complicated:
        https://www.w3.org/Bugs/Public/show_bug.cgi?id=19968 -->
   <li><p>For each <a>live range</a> whose <a for=range>start node</a> is <var>parent</var> and
   <a for=range>start offset</a> is equal to the <a for=tree>index</a> of <var>node</var> plus 1,
   increase its <a for=range>start offset</a> by 1.

   <li><p>For each <a>live range</a> whose <a for=range>end node</a> is <var>parent</var> and
   <a for=range>end offset</a> is equal to the <a for=tree>index</a> of <var>node</var> plus 1,
   increase its <a for=range>end offset</a> by 1.
  </ol>

 <li><a>Replace data</a> with node
 <var>node</var>, offset <var>offset</var>, count
 <var>count</var>, and data the empty string.

 <li>Return <var>new node</var>.
</ol>

<p>The <dfn method for=Text><code>splitText(<var>offset</var>)</code></dfn> method steps are to
<a lt="split a Text node">split</a> <a>this</a> with offset <var>offset</var>.

<p>The <dfn attribute for=Text><code>wholeText</code></dfn> getter steps are to return the
<a for=string>concatenation</a> of the <a for=CharacterData>data</a> of the
<a>contiguous <code>Text</code> nodes</a> of <a>this</a>, in <a>tree order</a>.


<h3 id=interface-cdatasection>Interface {{CDATASection}}</h3>

<pre class=idl>
[Exposed=Window]
interface CDATASection : Text {
};</pre>


<h3 id=interface-processinginstruction>Interface {{ProcessingInstruction}}</h3>

<pre class=idl>
[Exposed=Window]
interface ProcessingInstruction : CharacterData {
  readonly attribute DOMString target;
};</pre>

<p>{{ProcessingInstruction}} <a for=/>nodes</a> have an associated
<dfn export id=concept-pi-target for=ProcessingInstruction>target</dfn>.

<p>The <dfn attribute for=ProcessingInstruction>target</dfn> getter steps are to return
<a>this</a>'s <a for=ProcessingInstruction>target</a>.


<h3 id=interface-comment>Interface {{Comment}}</h3>

<pre class=idl>
[Exposed=Window]
interface Comment : CharacterData {
  constructor(optional DOMString data = "");
};
</pre>

<dl class=domintro>
 <dt><code><var ignore>comment</var> = new <a constructor lt="Comment()">Comment([<var>data</var> = ""])</a></code>
 <dd>Returns a new {{Comment}} <a for=/>node</a> whose
 <a for=CharacterData>data</a> is <var>data</var>.
</dl>

<p>The <dfn constructor for=Comment lt=Comment(data)><code>new Comment(<var>data</var>)</code></dfn>
constructor steps are to set <a>this</a>'s <a for=CharacterData>data</a> to <var>data</var> and
<a>this</a>'s <a for=Node>node document</a> to <a>current global object</a>'s
<a>associated <code>Document</code></a>.



<h2 id=ranges>Ranges</h2>

<h3 id=introduction-to-dom-ranges>Introduction to "DOM Ranges"</h3>

<p>{{StaticRange}} and {{Range}} objects (<a>ranges</a>) represent a sequence of content within a
<a>node tree</a>. Each <a>range</a> has a <a for=range>start</a> and an <a for=range>end</a> which
are <a>boundary points</a>. A <a>boundary point</a> is a <a for=/>tuple</a> consisting of a
<a for="boundary point">node</a> and an <a for="boundary point">offset</a>. So in other words, a
<a>range</a> represents a piece of content within a <a>node tree</a> between two
<a>boundary points</a>.

<p><a>Ranges</a> are frequently used in editing for selecting and copying content.

<ul class=domTree>
 <li class=t1>{{Element}}: <code>p</code>
  <ul>
   <li class=t1>{{Element}}: <code class=lang-markup>&lt;img src="insanity-wolf" alt="Little-endian BOM; decode as big-endian!"></code>
   <li class=t3>{{Text}}: <span>&nbsp;CSS 2.1 syndata is&nbsp;</span>
   <li class=t1>{{Element}}: <code class=lang-markup>&lt;em></code>
    <ul>
     <li class=t3>{{Text}}: <span>awesome</span>
    </ul>
   <li class=t3>{{Text}}: <span>!</span>
  </ul>
</ul>
<!-- http://w3cmemes.tumblr.com/post/35332222321/css-2-1-syndata-is-awesome -->

<p>In the <a>node tree</a> above, a
<a>range</a> can be used to represent the sequence
“syndata is awes”. Assuming <var ignore>p</var> is assigned to the
<code>p</code> <a for=/>element</a>, and
<var ignore>em</var> to the <code>em</code>
<a for=/>element</a>, this would be done as follows:

<pre class=lang-javascript><code>
var range = new Range(),
    firstText = p.childNodes[1],
    secondText = em.firstChild
range.setStart(firstText, 9) // do not forget the leading space
range.setEnd(secondText, 4)
// range now stringifies to the aforementioned quote
</code></pre>

<p class=note><a>Attributes</a> such as <code>src</code> and <code>alt</code> in the
<a>node tree</a> above cannot be represented by a <a>range</a>. <a>Ranges</a> are only useful for
<a for=/>nodes</a>.

<p>{{Range}} objects, unlike {{StaticRange}} objects, are affected by mutations to the
<a>node tree</a>. Therefore they are also known as <a>live ranges</a>. Such mutations will not
invalidate them and will try to ensure that it still represents the same piece of content.
Necessarily, a <a>live range</a> might itself be modified as part of the mutation to the
<a>node tree</a> when, e.g., part of the content it represents is mutated.

<p class=note>See the <a for=/>insert</a> and <a for=/>remove</a> algorithms, the
{{Node/normalize()}} method, and the <a>replace data</a> and <a lt="split a Text node">split</a>
algorithms for details.

<p>Updating <a>live ranges</a> in response to <a>node tree</a> mutations can be expensive. For every
<a>node tree</a> change, all affected {{Range}} objects need to be updated. Even if the application
is uninterested in some <a>live ranges</a>, it still has to pay the cost of keeping them up-to-date
when a mutation occurs.

<p>A {{StaticRange}} object is a lightweight <a>range</a> that does not update when the
<a>node tree</a> mutates. It is therefore not subject to the same maintenance cost as
<a>live ranges</a>.


<h3 id=boundary-points>Boundary points</h3>

<p>A <dfn export id=concept-range-bp>boundary point</dfn> is a <a for=/>tuple</a> consisting of a
<dfn export for="boundary point">node</dfn> (a <a for=/>node</a>) and an
<dfn export id=concept-range-bp-offset for="boundary point">offset</dfn> (a non-negative integer).

<p class=note>A correct <a>boundary point</a>'s <a for="boundary point">offset</a> will
be between 0 and the <a>boundary point</a>'s <a for="boundary point">node</a>'s
<a for=Node>length</a>, inclusive.

<p>The <dfn export id=concept-range-bp-position for="boundary point">position</dfn> of a
<a>boundary point</a> (<var>nodeA</var>, <var>offsetA</var>) relative to a <a>boundary point</a>
(<var>nodeB</var>, <var>offsetB</var>) is
<dfn export id=concept-range-bp-before for="boundary point">before</dfn>,
<dfn export id=concept-range-bp-equal for="boundary point">equal</dfn>, or
<dfn export id=concept-range-bp-after for="boundary point">after</dfn>, as returned by these steps:

<ol>
 <li><p>Assert: <var>nodeA</var> and <var>nodeB</var> have the same <a for=tree>root</a>.

 <li>If <var>nodeA</var> is <var>nodeB</var>, then return <a for="boundary point">equal</a> if
 <var>offsetA</var> is <var>offsetB</var>, <a for="boundary point">before</a> if <var>offsetA</var>
 is less than <var>offsetB</var>, and <a for="boundary point">after</a> if <var>offsetA</var> is
 greater than <var>offsetB</var>.

 <li><p>If <var>nodeA</var> is <a>following</a> <var>nodeB</var>, then if the
 <a for="boundary point">position</a> of (<var>nodeB</var>, <var>offsetB</var>) relative to
 (<var>nodeA</var>, <var>offsetA</var>) is <a for="boundary point">before</a>, return
 <a for="boundary point">after</a>, and if it is <a for="boundary point">after</a>, return
 <a for="boundary point">before</a>.

 <li>
  <p>If <var>nodeA</var> is an <a>ancestor</a> of <var>nodeB</var>:

  <ol>
   <li><p>Let <var>child</var> be <var>nodeB</var>.

   <li><p>While <var>child</var> is not a <a for=tree>child</a> of <var>nodeA</var>, set
   <var>child</var> to its <a for=tree>parent</a>.

   <li><p>If <var>child</var>'s <a for=tree>index</a> is less than <var>offsetA</var>, then return
   <a for="boundary point">after</a>.
  </ol>

 <li><p>Return <a for="boundary point">before</a>.
</ol>


<h3 id=interface-abstractrange>Interface {{AbstractRange}}</h3>

<pre class=idl>
[Exposed=Window]
interface AbstractRange {
  readonly attribute Node startContainer;
  readonly attribute unsigned long startOffset;
  readonly attribute Node endContainer;
  readonly attribute unsigned long endOffset;
  readonly attribute boolean collapsed;
};
</pre>

<p>Objects implementing the {{AbstractRange}} interface are known as
<dfn export id=concept-range lt="range">ranges</dfn>.

<p>A <a>range</a> has two associated <a>boundary points</a> — a
<dfn export id=concept-range-start for=range>start</dfn> and
<dfn export id=concept-range-end for=range>end</dfn>.

<p>For convenience, a <a>range</a>'s
<dfn export id=concept-range-start-node for=range>start node</dfn> is its <a for=range>start</a>'s
<a for="boundary point">node</a>, its
<dfn export id=concept-range-start-offset for=range>start offset</dfn> is its
<a for=range>start</a>'s <a for="boundary point">offset</a>, its
<dfn export id=concept-range-end-node for=range>end node</dfn> is its <a for=range>end</a>'s
<a for="boundary point">node</a>,  and its
<dfn export id=concept-range-end-offset for=range>end offset</dfn> is its <a for=range>end</a>'s
<a for="boundary point">offset</a>.

<p>A <a>range</a> is <dfn for=range export>collapsed</dfn> if its <a for=range>start node</a> is its
<a for=range>end node</a> and its <a for=range>start offset</a> is its <a for=range>end offset</a>.

<dl class=domintro>
 <dt><code><var>node</var> = <var>range</var> . <a attribute for=AbstractRange>startContainer</a></code>
 <dd>Returns <var>range</var>'s <a for=range>start node</a>.

 <dt><code><var>offset</var> = <var>range</var> . <a attribute for=AbstractRange>startOffset</a></code>
 <dd>Returns <var>range</var>'s <a for=range>start offset</a>.

 <dt><code><var>node</var> = <var>range</var> . <a attribute for=AbstractRange>endContainer</a></code>
 <dd>Returns <var>range</var>'s <a for=range>end node</a>.

 <dt><code><var>offset</var> = <var>range</var> . <a attribute for=AbstractRange>endOffset</a></code>
 <dd>Returns <var>range</var>'s <a for=range>end offset</a>.

 <dt><code><var ignore>collapsed</var> = <var>range</var> . <a attribute for=AbstractRange>collapsed</a></code>
 <dd>Returns true if <var>range</var> is <a for=range>collapsed</a>; otherwise false.
</dl>

<p>The
<dfn id=dom-range-startcontainer attribute for=AbstractRange><code>startContainer</code></dfn>
getter steps are to return <a>this</a>'s <a for=range>start node</a>.

<p>The <dfn id=dom-range-startoffset attribute for=AbstractRange><code>startOffset</code></dfn>
getter steps are to return <a>this</a>'s <a for=range>start offset</a>.

<p>The <dfn id=dom-range-endcontainer attribute for=AbstractRange><code>endContainer</code></dfn>
getter steps are to return <a>this</a>'s <a for=range>end node</a>.

<p>The <dfn id=dom-range-endoffset attribute for=AbstractRange><code>endOffset</code></dfn>
getter steps are to return <a>this</a>'s <a for=range>end offset</a>.

<p>The <dfn id=dom-range-collapsed attribute for=AbstractRange><code>collapsed</code></dfn>
getter steps are to return true if <a>this</a> is <a for=range>collapsed</a>; otherwise false.


<h3 id=interface-staticrange>Interface {{StaticRange}}</h3>

<pre class=idl>
dictionary StaticRangeInit {
  required Node startContainer;
  required unsigned long startOffset;
  required Node endContainer;
  required unsigned long endOffset;
};

[Exposed=Window]
interface StaticRange : AbstractRange {
  constructor(StaticRangeInit init);
};
</pre>

<dl class=domintro>
 <dt><code><var ignore>staticRange</var> = new <a constructor lt="StaticRange(init)">StaticRange</a>(init)</code>
 <dd><p>Returns a new <a>range</a> object that does not update when the <a>node tree</a> mutates.
</dl>

<p>The
<dfn constructor for=StaticRange lt="StaticRange(init)"><code>new StaticRange(<var>init</var>)</code></dfn>
constructor steps are:

<ol>
 <li><p>If <var>init</var>["{{StaticRangeInit/startContainer}}"] or
 <var>init</var>["{{StaticRangeInit/endContainer}}"] is a {{DocumentType}} or {{Attr}}
 <a for=/>node</a>, then <a>throw</a> an "{{InvalidNodeTypeError!!exception}}" {{DOMException}}.

 <li><p>Set <a>this</a>'s <a for=range>start</a> to
 (<var>init</var>["{{StaticRangeInit/startContainer}}"],
 <var>init</var>["{{StaticRangeInit/startOffset}}"]) and <a for=range>end</a> to
 (<var>init</var>["{{StaticRangeInit/endContainer}}"],
 <var>init</var>["{{StaticRangeInit/endOffset}}"]).
</ol>

<p>A {{StaticRange}} is <dfn for=StaticRange export>valid</dfn> if all of the following are true:

<ul>
 <li><p>Its <a for=range>start</a> and <a for=range>end</a> are in the same <a>node tree</a>.

 <li><p>Its <a for=range>start offset</a> is between 0 and its <a for=range>start node</a>'s
 <a>length</a>, inclusive.

 <li><p>Its <a for=range>end offset</a> is between 0 and its <a for=range>end node</a>'s
 <a>length</a>, inclusive.

 <li><p>Its <a for=range>start</a> is <a for="boundary point">before</a> or
 <a for="boundary point">equal</a> to its <a for=range>end</a>.
</ul>


<h3 id=interface-range>Interface {{Range}}</h3>

<pre class=idl>
[Exposed=Window]
interface Range : AbstractRange {
  constructor();

  readonly attribute Node commonAncestorContainer;

  undefined setStart(Node node, unsigned long offset);
  undefined setEnd(Node node, unsigned long offset);
  undefined setStartBefore(Node node);
  undefined setStartAfter(Node node);
  undefined setEndBefore(Node node);
  undefined setEndAfter(Node node);
  undefined collapse(optional boolean toStart = false);
  undefined selectNode(Node node);
  undefined selectNodeContents(Node node);

  const unsigned short START_TO_START = 0;
  const unsigned short START_TO_END = 1;
  const unsigned short END_TO_END = 2;
  const unsigned short END_TO_START = 3;
  short compareBoundaryPoints(unsigned short how, Range sourceRange);

  [CEReactions] undefined deleteContents();
  [CEReactions, NewObject] DocumentFragment extractContents();
  [CEReactions, NewObject] DocumentFragment cloneContents();
  [CEReactions] undefined insertNode(Node node);
  [CEReactions] undefined surroundContents(Node newParent);

  [NewObject] Range cloneRange();
  undefined detach();

  boolean isPointInRange(Node node, unsigned long offset);
  short comparePoint(Node node, unsigned long offset);

  boolean intersectsNode(Node node);

  stringifier;
};
</pre>

<p>Objects implementing the {{Range}} interface are known as
<dfn export id=concept-live-range>live ranges</dfn>.

<p class=note>Algorithms that modify a <a>tree</a> (in particular the <a for=/>insert</a>,
<a for=/>remove</a>, <a>replace data</a>, and <a lt="split a Text node">split</a> algorithms) modify
<a>live ranges</a> associated with that <a>tree</a>.

<p>The <dfn export id=concept-range-root for="live range">root</dfn> of a <a>live range</a> is the
<a for=tree>root</a> of its <a for=range>start node</a>.
<!-- start and end have an identical root -->

<p>A <a for=/>node</a> <var>node</var> is <dfn export for="live range" id=contained>contained</dfn>
in a <a>live range</a> <var>range</var> if <var>node</var>'s <a for=tree>root</a> is
<var>range</var>'s <a for="live range">root</a>, and (<var>node</var>, 0) is
<a for="boundary point">after</a> <var>range</var>'s <a for=range>start</a>, and
(<var>node</var>, <var>node</var>'s <a>length</a>) is <a for="boundary point">before</a>
<var>range</var>'s <a for=range>end</a>.

<p>A <a for=/>node</a> is
<dfn export for="live range" id=partially-contained>partially contained</dfn> in a <a>live range</a>
if it's an <a for=tree>inclusive ancestor</a> of the <a>live range</a>'s <a for=range>start node</a>
but not its <a for=range>end node</a>, or vice versa.

<div class=note>
 <p>Some facts to better understand these definitions:

 <ul>
  <li><p>The content that one would think of as being within the <a>live range</a> consists of all
  <a for="live range">contained</a> <a for=/>nodes</a>, plus possibly some of the contents of the
  <a for=range>start node</a> and <a for=range>end node</a> if those are {{CharacterData}}
  <a for=/>nodes</a>.

  <li><p>The <a for=/>nodes</a> that are contained in a <a>live range</a> will generally not be
  contiguous, because the <a for=tree>parent</a> of a <a for="live range">contained</a>
  <a for=/>node</a> will not always be <a for="live range">contained</a>.

  <li><p>However, the <a>descendants</a> of a <a for="live range">contained</a> <a for=/>node</a>
  are <a for="live range">contained</a>, and if two <a for=tree>siblings</a> are
  <a for="live range">contained</a>, so are any <a for=tree>siblings</a> that lie between them.

  <li><p>The <a for=range>start node</a> and <a for=range>end node</a> of a <a>live range</a> are
  never <a for="live range">contained</a> within it.

  <li><p>The first <a for="live range">contained</a> <a for=/>node</a> (if there are any) will
  always be after the <a for=range>start node</a>, and the last <a for="live range">contained</a>
  <a for=/>node</a> will always be equal to or before the <a for=range>end node</a>'s last
  <a>descendant</a>.

  <li><p>There exists a <a for="live range">partially contained</a> <a for=/>node</a> if and only if
  the <a for=range>start node</a> and <a for=range>end node</a> are different.

  <li><p>The {{Range/commonAncestorContainer}} attribute value is neither
  <a for="live range">contained</a> nor <a for="live range">partially contained</a>.

  <li><p>If the <a for=range>start node</a> is an <a>ancestor</a> of the <a for=range>end node</a>,
  the common <a for=tree>inclusive ancestor</a> will be the <a for=range>start node</a>. Exactly one
  of its <a for=tree>children</a> will be <a for="live range">partially contained</a>, and a
  <a for=tree>child</a> will be <a for="live range">contained</a> if and only if it
  <a lt="preceding">precedes</a> the <a for="live range">partially contained</a>
  <a for=tree>child</a>. If the <a for=range>end node</a> is an <a>ancestor</a> of the
  <a for=range>start node</a>, the opposite holds.

  <li><p>If the <a for=range>start node</a> is not an <a for=tree>inclusive ancestor</a> of the
  <a for=range>end node</a>, nor vice versa, the common <a for=tree>inclusive ancestor</a> will be
  distinct from both of them. Exactly two of its <a for=tree>children</a> will be
  <a for="live range">partially contained</a>, and a <a for=tree>child</a> will be contained if and
  only if it lies between those two.
 </ul>
</div>

<hr>

<dl class=domintro>
 <dt><code><var>range</var> = new <a constructor>Range()</a></code>
 <dd>Returns a new <a>live range</a>.
</dl>

<p>The <dfn constructor for=Range lt="Range()"><code>new Range()</code></dfn> constructor steps are
to set <a>this</a>'s <a for=range>start</a> and <a for=range>end</a> to
(<a>current global object</a>'s <a>associated <code>Document</code></a>, 0).

<hr>

<dl class=domintro>
 <dt><var>container</var> = <var>range</var> . {{Range/commonAncestorContainer}}
 <dd>Returns the <a for=/>node</a>, furthest away from
 the <a>document</a>, that is an
 <a>ancestor</a> of both
 <var>range</var>'s
 <a for=range>start node</a> and
 <a for=range>end node</a>.
</dl>

<p>The <dfn attribute for=Range><code>commonAncestorContainer</code></dfn> getter steps are:

<ol>
 <li>Let <var>container</var> be
 <a for=range>start node</a>.

 <li>While <var>container</var> is not an
 <a for=tree>inclusive ancestor</a> of
 <a for=range>end node</a>, let
 <var>container</var> be <var>container</var>'s
 <a for=tree>parent</a>.

 <li>Return <var>container</var>.
</ol>

<hr>

<p>To
<dfn export id=concept-range-bp-set lt="set the start|set the end" for=Range>set the start or end</dfn>
of a <var>range</var> to a <a>boundary point</a> (<var>node</var>, <var>offset</var>), run these
steps:

<ol>
 <li>If <var>node</var> is a <a>doctype</a>, then <a>throw</a> an
 "{{InvalidNodeTypeError!!exception}}" {{DOMException}}.

 <li>If <var>offset</var> is greater than <var>node</var>'s <a>length</a>, then <a>throw</a> an
 "{{IndexSizeError!!exception}}" {{DOMException}}.

 <li>Let <var>bp</var> be the
 <a>boundary point</a>
 (<var>node</var>, <var>offset</var>).

 <li>
  <dl class=switch>
   <dt>If these steps were invoked as "set the start"
   <dd>
    <ol>
     <li>If <var>range</var>'s
     <a for="live range">root</a> is not equal to
     <var>node</var>'s <a for=tree>root</a>,
     or if <var>bp</var> is
     <a for="boundary point">after</a> the
     <var>range</var>'s <a for=range>end</a>, set
     <var>range</var>'s <a for=range>end</a>
     to <var>bp</var>.

     <li>Set <var>range</var>'s
     <a for=range>start</a> to <var>bp</var>.
    </ol>
   <dt>If these steps were invoked as "set the end"
   <dd>
    <ol>
     <li>If <var>range</var>'s
     <a for="live range">root</a> is not equal to
     <var>node</var>'s <a for=tree>root</a>,
     or if <var>bp</var> is
     <a for="boundary point">before</a> the
     <var>range</var>'s <a for=range>start</a>, set
     <var>range</var>'s <a for=range>start</a>
     to <var>bp</var>.

     <li>Set <var>range</var>'s
     <a for=range>end</a> to <var>bp</var>.
    </ol>
  </dl>
</ol>

<p>The <dfn method for=Range><code>setStart(<var>node</var>, <var>offset</var>)</code></dfn> method
steps are to <a>set the start</a> of <a>this</a> to <a>boundary point</a>
(<var>node</var>, <var>offset</var>).

<p>The <dfn method for=Range><code>setEnd(<var>node</var>, <var>offset</var>)</code></dfn> method
steps are to <a>set the end</a> of <a>this</a> to <a>boundary point</a>
(<var>node</var>, <var>offset</var>).

<p>The <dfn method for=Range><code>setStartBefore(<var>node</var>)</code></dfn> method steps are:

<ol>
 <li>Let <var>parent</var> be <var>node</var>'s
 <a for=tree>parent</a>.

 <li>If <var>parent</var> is null, then <a>throw</a> an "{{InvalidNodeTypeError!!exception}}"
 {{DOMException}}.

 <li><a>Set the start</a> of
 <a>this</a> to
 <a>boundary point</a>
 (<var>parent</var>, <var>node</var>'s
 <a for=tree>index</a>).
</ol>

<p>The <dfn method for=Range><code>setStartAfter(<var>node</var>)</code></dfn> method steps are:

<ol>
 <li><p>Let <var>parent</var> be <var>node</var>'s <a for=tree>parent</a>.

 <li><p>If <var>parent</var> is null, then <a>throw</a> an "{{InvalidNodeTypeError!!exception}}"
 {{DOMException}}.

 <li><p><a>Set the start</a> of <a>this</a> to <a>boundary point</a>
 (<var>parent</var>, <var>node</var>'s <a for=tree>index</a> plus 1).
</ol>

<p>The <dfn method for=Range><code>setEndBefore(<var>node</var>)</code></dfn> method steps are:

<ol>
 <li>Let <var>parent</var> be <var>node</var>'s
 <a for=tree>parent</a>.

 <li>If <var>parent</var> is null, then <a>throw</a> an "{{InvalidNodeTypeError!!exception}}"
 {{DOMException}}.

 <li><a>Set the end</a> of
 <a>this</a> to
 <a>boundary point</a>
 (<var>parent</var>, <var>node</var>'s <a for=tree>index</a>).
</ol>

<p>The <dfn method for=Range><code>setEndAfter(<var>node</var>)</code></dfn> method steps are:

<ol>
 <li><p>Let <var>parent</var> be <var>node</var>'s <a for=tree>parent</a>.

 <li><p>If <var>parent</var> is null, then <a>throw</a> an "{{InvalidNodeTypeError!!exception}}"
 {{DOMException}}.

 <li><p><a>Set the end</a> of <a>this</a> to <a>boundary point</a>
 (<var>parent</var>, <var>node</var>'s <a for=tree>index</a> plus 1).
</ol>

<p>The <dfn method for=Range><code>collapse(<var>toStart</var>)</code></dfn> method steps are to, if
<var>toStart</var> is true, set <a for=range>end</a> to <a for=range>start</a>; otherwise set
<a for=range>start</a> to <a for=range>end</a>.

<p>To <dfn export id=concept-range-select for=range>select</dfn> a <a for=/>node</a> <var>node</var>
within a <a>range</a> <var>range</var>, run these steps:

<ol>
 <li><p>Let <var>parent</var> be <var>node</var>'s <a for=tree>parent</a>.

 <li><p>If <var>parent</var> is null, then <a>throw</a> an "{{InvalidNodeTypeError!!exception}}"
 {{DOMException}}.

 <li><p>Let <var>index</var> be <var>node</var>'s <a for=tree>index</a>.

 <li><p>Set <var>range</var>'s <a for=range>start</a> to <a>boundary point</a>
 (<var>parent</var>, <var>index</var>).

 <li><p>Set <var>range</var>'s <a for=range>end</a> to <a>boundary point</a>
 (<var>parent</var>, <var>index</var> plus 1).
</ol>

<p>The <dfn method for=Range><code>selectNode(<var>node</var>)</code></dfn> method steps are to
<a for=range>select</a> <var>node</var> within <a>this</a>.

<p>The <dfn method for=Range><code>selectNodeContents(<var>node</var>)</code></dfn> method steps
are:

<ol>
 <li>If <var>node</var> is a
 <a>doctype</a>,
 <a>throw</a> an
 "{{InvalidNodeTypeError!!exception}}" {{DOMException}}.

 <li>Let <var>length</var> be the
 <a>length</a> of <var>node</var>.

 <li>Set <a for=range>start</a> to the
 <a>boundary point</a>
 (<var>node</var>, 0).

 <li>Set <a for=range>end</a> to the
 <a>boundary point</a>
 (<var>node</var>, <var>length</var>).
</ol>

<hr>

<p>The
<dfn method for=Range><code>compareBoundaryPoints(<var>how</var>, <var>sourceRange</var>)</code></dfn>
method steps are:

<ol>
 <li>
  <p>If <var>how</var> is not one of

  <ul class=brief>
   <li>{{Range/START_TO_START}},
   <li>{{Range/START_TO_END}},
   <li>{{Range/END_TO_END}}, and
   <li>{{Range/END_TO_START}},
  </ul>

  <p>then <a>throw</a> a "{{NotSupportedError!!exception}}" {{DOMException}}.
 <!--
 Apparent behaviors from black-box testing:

 IE9: Converts to unsigned short per WebIDL, then throws "Error: Invalid
 argument." if it's not 0-3.

 Firefox 12.0a1: Converts to unsigned short per WebIDL, then throws
 NS_ERROR_ILLEGAL_VALUE if it's not 0-3.

 Chrome 17 dev: Converts to unsigned *long* per WebIDL, and treats bad values
 as 0.  Never throws.

 Opera Next 12.00 alpha: Throws NotSupportedError unless the value is -0, 0, 1,
 2, 3, or an integer equal to one of these modulo 2^32.  (In particular, it
 throws on NaN, Infinity, and -Infinity instead of treating them as 0 per
 WebIDL.)

 The spec follows IE9/Gecko, except that we throw NotSupportedError (like
 Opera) instead of a nonstandard exception type.
 -->

 <li>If <a>this</a>'s <a for="live range">root</a> is not the same as <var>sourceRange</var>'s
 <a for="live range">root</a>, then <a>throw</a> a "{{WrongDocumentError!!exception}}" {{DOMException}}.

 <li>
  If <var>how</var> is:
  <dl class=switch>
   <dt>{{Range/START_TO_START}}:
   <dd>
    Let <var>this point</var> be <a>this</a>'s
    <a for=range>start</a>.
    Let <var>other point</var> be <var>sourceRange</var>'s
    <a for=range>start</a>.

   <dt>{{Range/START_TO_END}}:
   <dd>
    Let <var>this point</var> be <a>this</a>'s
    <a for=range>end</a>.
    Let <var>other point</var> be <var>sourceRange</var>'s
    <a for=range>start</a>.

    <dt>{{Range/END_TO_END}}:
    <dd>
     Let <var>this point</var> be <a>this</a>'s
     <a for=range>end</a>.
     Let <var>other point</var> be <var>sourceRange</var>'s
     <a for=range>end</a>.

    <dt>{{Range/END_TO_START}}:
    <dd>
     Let <var>this point</var> be <a>this</a>'s
     <a for=range>start</a>.
     Let <var>other point</var> be <var>sourceRange</var>'s
     <a for=range>end</a>.
   </dl>

  <li>
   <p>If the <a for="boundary point">position</a> of <var>this point</var> relative to
   <var>other point</var> is

   <dl class=switch>
    <dt><a for="boundary point">before</a>
    <dd>Return &minus;1.

    <dt><a for="boundary point">equal</a>
    <dd>Return 0.

    <dt><a for="boundary point">after</a>
    <dd>Return 1.
   </dl>
</ol>

<p>The <dfn method for=Range><code>deleteContents()</code></dfn> method steps are:

<ol>
 <li><p>If <a>this</a> is <a for=range>collapsed</a>, then return.
 <!-- This might actually make no difference, but it's not immediately
 obvious what would happen otherwise if the start/end were text/comment:
 are all the substeps of the next step actually no-ops, or could some have
 side effects? -->

 <li>Let <var>original start node</var>,
 <var>original start offset</var>, <var>original end node</var>,
 and <var>original end offset</var> be <a>this</a>'s
 <a for=range>start node</a>,
 <a for=range>start offset</a>,
 <a for=range>end node</a>, and
 <a for=range>end offset</a>, respectively.

 <li><p>If <var>original start node</var> is <var>original end node</var> and it is a
 {{CharacterData}} <a for=/>node</a>, then
 <a>replace data</a> with node
 <var>original start node</var>, offset
 <var>original start offset</var>, count
 <var>original end offset</var> minus
 <var>original start offset</var>, and data the empty string, and then return.

 <li>Let <var>nodes to remove</var> be a list of all the
 <a for=/>nodes</a> that are <a for="live range">contained</a> in
 <a>this</a>, in
 <a>tree order</a>, omitting any
 <a for=/>node</a> whose
 <a for=tree>parent</a> is also
 <a for="live range">contained</a> in <a>this</a>.

 <li>If <var>original start node</var> is an
 <a for=tree>inclusive ancestor</a> of
 <var>original end node</var>, set
 <var>new node</var> to <var>original start node</var> and
 <var>new offset</var> to <var>original start offset</var>.

 <li>
  Otherwise:
  <ol>
   <li>Let <var>reference node</var> equal
   <var>original start node</var>.

   <li>While <var>reference node</var>'s
   <a for=tree>parent</a> is not null and is not an
   <a for=tree>inclusive ancestor</a> of
   <var>original end node</var>, set <var>reference node</var>
   to its <a for=tree>parent</a>.

   <li>
    Set <var>new node</var> to the
    <a for=tree>parent</a> of
    <var>reference node</var>, and <var>new offset</var> to one
    plus the <a for=tree>index</a> of
    <var>reference node</var>.

    <p class=note>If <var>reference node</var>'s
    <a for=tree>parent</a> were null, it would be the
    <a for="live range">root</a> of
    <a>this</a>, so would be an
    <a for=tree>inclusive ancestor</a> of
    <var>original end node</var>, and we could not reach this point.
  </ol>

 <li><p>If <var>original start node</var> is a {{CharacterData}} <a for=/>node</a>, then
 <a>replace data</a> with node
 <var>original start node</var>, offset
 <var>original start offset</var>, count
 <var>original start node</var>'s
 <a>length</a> minus
 <var>original start offset</var>, data the empty string.

 <li><p>For each <var>node</var> in <var>nodes to remove</var>, in <a>tree order</a>,
 <a for=/>remove</a> <var>node</var>.

 <li><p>If <var>original end node</var> is a {{CharacterData}} <a for=/>node</a>, then
 <a>replace data</a> with node
 <var>original end node</var>, offset 0, count
 <var>original end offset</var> and data the empty string.

 <li>Set <a for=range>start</a> and
 <a for=range>end</a> to
 (<var>new node</var>, <var>new offset</var>).
</ol>

<p>To <dfn export id=concept-range-extract for="live range">extract</dfn> a <a>live range</a>
<var>range</var>, run these steps:

<ol>
 <li><p>Let <var>fragment</var> be a new {{DocumentFragment}} <a for=/>node</a> whose
 <a for=Node>node document</a> is <var>range</var>'s <a for=range>start node</a>'s
 <a for=Node>node document</a>.

 <li><p>If <var>range</var> is <a for=range>collapsed</a>, then return <var>fragment</var>.
 <!-- This is only really needed when the start and end nodes are
 text/comment, to avoid creating an empty clone as the child of the
 fragment. (Opera 11 actually does include such an empty clone, it seems,
 but Gecko and WebKit do not as of March 2011, so we follow them.)
 Otherwise, the following steps are all no-ops. But it's simplest to include
 this step anyway. -->

 <li>Let <var>original start node</var>, <var>original start offset</var>,
 <var>original end node</var>, and <var>original end offset</var> be
 <var>range</var>'s <a for=range>start node</a>,
 <a for=range>start offset</a>,
 <a for=range>end node</a>, and
 <a for=range>end offset</a>, respectively.

 <li>
  <p>If <var>original start node</var> is <var>original end node</var> and it is a
  {{CharacterData}} <a for=/>node</a>, then:

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>original start node</var>.

   <li>Set the <a for=CharacterData>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, and count
   <var>original end offset</var> minus
   <var>original start offset</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li><a>Replace data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, count
   <var>original end offset</var> minus
   <var>original start offset</var>, and data the empty string.

   <li>Return <var>fragment</var>.
  </ol>

 <li>Let <var>common ancestor</var> be
 <var>original start node</var>.

 <li>While <var>common ancestor</var> is not an
 <a for=tree>inclusive ancestor</a> of
 <var>original end node</var>, set <var>common ancestor</var> to
 its own <a for=tree>parent</a>.

 <li>Let <var>first partially contained child</var> be null.

 <li>If <var>original start node</var> is <em>not</em> an
 <a for=tree>inclusive ancestor</a> of
 <var>original end node</var>, set <var>first partially contained child</var>
 to the first <a for=tree>child</a> of
 <var>common ancestor</var> that is <a for="live range">partially contained</a> in
 <var>range</var>.

 <li>Let <var>last partially contained child</var> be null.

 <li>
  If <var>original end node</var> is <em>not</em> an
  <a for=tree>inclusive ancestor</a> of
  <var>original start node</var>, set
  <var>last partially contained child</var> to the last
  <a for=tree>child</a> of <var>common ancestor</var> that is
  <a for="live range">partially contained</a> in <var>range</var>.

  <p class=note>These variable assignments do actually always make sense.
  For instance, if <var>original start node</var> is not an
  <a for=tree>inclusive ancestor</a> of
  <var>original end node</var>, <var>original start node</var> is itself
  <a for="live range">partially contained</a> in <var>range</var>, and so are all its
  <a>ancestors</a> up until a
  <a for=tree>child</a> of <var>common ancestor</var>.
  <var>common ancestor</var> cannot be <var>original start node</var>, because
  it has to be an <a for=tree>inclusive ancestor</a> of
  <var>original end node</var>. The other case is similar. Also, notice that the two
  <a for=tree>children</a> will never be equal if both are defined.

 <li>Let <var>contained children</var> be a list of all
 <a for=tree>children</a> of
 <var>common ancestor</var> that are <a for="live range">contained</a> in
 <var>range</var>, in <a>tree order</a>.

 <li>
  <p>If any member of <var>contained children</var> is a <a>doctype</a>, then <a>throw</a> a
  "{{HierarchyRequestError!!exception}}" {{DOMException}}.
  <!-- Firefox 4.0 actually removes the non-DocumentType nodes before
  throwing the exception. Opera 11.00 removes the DocumentType too, and
  doesn't throw. I go with IE9 and Chrome 12 dev, which don't remove any
  nodes. DOM 2 Range doesn't specify what exactly happens here, except that
  an exception should be thrown. -->

  <p class=note>We do not have to worry about the first or last partially
  contained node, because a <a>doctype</a> can never be
  partially contained. It cannot be a boundary point of a range, and it
  cannot be the ancestor of anything.

 <li>If <var>original start node</var> is an
 <a for=tree>inclusive ancestor</a> of
 <var>original end node</var>, set <var>new node</var> to
 <var>original start node</var> and <var>new offset</var> to
 <var>original start offset</var>.

 <li>
  Otherwise:
  <ol>
   <li>Let <var>reference node</var> equal <var>original start node</var>.

   <li>While <var>reference node</var>'s
   <a for=tree>parent</a> is not null and is not an
   <a for=tree>inclusive ancestor</a> of
   <var>original end node</var>, set <var>reference node</var> to its
   <a for=tree>parent</a>.

   <li>
    Set <var>new node</var> to the
    <a for=tree>parent</a> of <var>reference node</var>, and
    <var>new offset</var> to one plus <var>reference node</var>'s
    <a for=tree>index</a>.

    <p class=note>If <var>reference node</var>'s
    <a for=tree>parent</a> is null, it would be the
    <a for="live range">root</a> of <var>range</var>, so would be an
    <a for=tree>inclusive ancestor</a> of
    <var>original end node</var>, and we could not reach this point.
  </ol>

  <!-- Now we start with mutations, so we can't refer to this anymore unless we carefully consider
  how it will have mutated. -->

 <li>
  <p>If <var>first partially contained child</var> is a {{CharacterData}} <a for=/>node</a>, then:

  <p class=note>In this case, <var>first partially contained child</var> is
  <var>original start node</var>.

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>original start node</var>.

   <li>Set the <a for=CharacterData>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, and count
   <var>original start node</var>'s
   <a>length</a> minus
   <var>original start offset</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li><a>Replace data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, count
   <var>original start node</var>'s
   <a>length</a> minus
   <var>original start offset</var>, and data the empty string.
  </ol>

 <li>
  Otherwise, if <var>first partially contained child</var> is not
  null:

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>first partially contained child</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li>Let <var>subrange</var> be a new <a>live range</a>
   whose <a for=range>start</a> is
   (<var>original start node</var>, <var>original start offset</var>) and
   whose <a for=range>end</a> is
   (<var>first partially contained child</var>, <var>first partially contained child</var>'s <a>length</a>).

   <li><p>Let <var>subfragment</var> be the result of <a for="live range">extracting</a>
   <var>subrange</var>.

   <li><a>Append</a> <var>subfragment</var> to
   <var>clone</var>.
  </ol>

 <li>For each <var>contained child</var> in <var>contained children</var>,
 <a>append</a> <var>contained child</var> to
 <var>fragment</var>.

 <li>
  <p>If <var>last partially contained child</var> is a {{CharacterData}} <a for=/>node</a>, then:

  <p class=note>In this case, <var>last partially contained child</var> is
  <var>original end node</var>.

  <ol>
   <li>Let <var>clone</var> be a <a lt="clone a node">clone</a> of
   <var>original end node</var>.

   <li>Set the <a for=CharacterData>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original end node</var>, offset 0, and count
   <var>original end offset</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li><a>Replace data</a> with node
   <var>original end node</var>, offset 0, count
   <var>original end offset</var>, and data the empty string.
  </ol>

 <li>
  Otherwise, if <var>last partially contained child</var> is not
  null:

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>last partially contained child</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li>Let <var>subrange</var> be a new <a>live range</a>
   whose <a for=range>start</a> is
   (<var>last partially contained child</var>, 0) and whose
   <a for=range>end</a> is
   (<var>original end node</var>, <var>original end offset</var>).

   <li><p>Let <var>subfragment</var> be the result of <a for="live range">extracting</a>
   <var>subrange</var>.

   <li><a>Append</a> <var>subfragment</var> to
   <var>clone</var>.
  </ol>

 <li>Set <var>range</var>'s <a for=range>start</a> and
 <a for=range>end</a> to
 (<var>new node</var>, <var>new offset</var>).

 <li>Return <var>fragment</var>.
</ol>

<p>The <dfn method for=Range><code>extractContents()</code></dfn> method steps are to return the
result of <a for="live range">extracting</a> <a>this</a>.

<p>To
<dfn export id=concept-range-clone for="live range" lt="clone the contents|cloning the contents">clone the contents</dfn>
of a <a>live range</a> <var>range</var>, run these steps:

<ol>
 <li><p>Let <var>fragment</var> be a new {{DocumentFragment}} <a for=/>node</a> whose
 <a for=Node>node document</a> is <var>range</var>'s <a for=range>start node</a>'s
 <a for=Node>node document</a>.

 <li><p>If <var>range</var> is <a for=range>collapsed</a>, then return <var>fragment</var>.
 <!-- This is only really needed when the start and end nodes are
 text/comment, to avoid creating an empty clone as the child of the
 fragment. (Opera 11 actually does include such an empty clone, it seems,
 but Gecko and WebKit do not as of March 2011, so we follow them.)
 Otherwise, the following steps are all no-ops. But it's simplest to include
 this step anyway. -->

 <li>Let <var>original start node</var>, <var>original start offset</var>,
 <var>original end node</var>, and <var>original end offset</var> be
 <var>range</var>'s <a for=range>start node</a>,
 <a for=range>start offset</a>,
 <a for=range>end node</a>, and
 <a for=range>end offset</a>, respectively.

 <li>
  <p>If <var>original start node</var> is <var>original end node</var> and it is a
  {{CharacterData}} <a for=/>node</a>, then:

  <ol>
   <li>Let <var>clone</var> be a <a lt="clone a node">clone</a> of
   <var>original start node</var>.

   <li>Set the <a for=CharacterData>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, and count
   <var>original end offset</var> minus
   <var>original start offset</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li>Return <var>fragment</var>.
  </ol>

 <li>Let <var>common ancestor</var> be
 <var>original start node</var>.

 <li>While <var>common ancestor</var> is not an
 <a for=tree>inclusive ancestor</a> of
 <var>original end node</var>, set
 <var>common ancestor</var> to its own
 <a for=tree>parent</a>.

 <li>Let <var>first partially contained child</var> be null.

 <li>If <var>original start node</var> is <em>not</em> an
 <a for=tree>inclusive ancestor</a> of
 <var>original end node</var>, set <var>first partially contained child</var>
 to the first <a for=tree>child</a> of
 <var>common ancestor</var> that is <a for="live range">partially contained</a> in
 <var>range</var>.

 <li>Let <var>last partially contained child</var> be null.

 <li>
  If <var>original end node</var> is <em>not</em> an
  <a for=tree>inclusive ancestor</a> of
  <var>original start node</var>, set
  <var>last partially contained child</var> to the last
  <a for=tree>child</a> of <var>common ancestor</var> that is
  <a for="live range">partially contained</a> in <var>range</var>.

  <p class=note>These variable assignments do actually always make sense.
  For instance, if <var>original start node</var> is not an
  <a for=tree>inclusive ancestor</a> of
  <var>original end node</var>, <var>original start node</var> is itself
  <a for="live range">partially contained</a> in <var>range</var>, and so are all its
  <a>ancestors</a> up until a
  <a for=tree>child</a> of <var>common ancestor</var>.
  <var>common ancestor</var> cannot be <var>original start node</var>, because
  it has to be an <a for=tree>inclusive ancestor</a> of
  <var>original end node</var>. The other case is similar. Also, notice that the two
  <a for=tree>children</a> will never be equal if both are defined.

 <li>Let <var>contained children</var> be a list of all
 <a for=tree>children</a> of
 <var>common ancestor</var> that are <a for="live range">contained</a> in
 <var>range</var>, in <a>tree order</a>.

 <li>
  <p>If any member of <var>contained children</var> is a <a>doctype</a>, then <a>throw</a> a
  "{{HierarchyRequestError!!exception}}" {{DOMException}}.

  <p class=note>We do not have to worry about the first or last partially
  contained node, because a <a>doctype</a> can never be
  partially contained. It cannot be a boundary point of a range, and it
  cannot be the ancestor of anything.

 <li>
  <p>If <var>first partially contained child</var> is a {{CharacterData}} <a for=/>node</a>, then:

  <p class=note>In this case, <var>first partially contained child</var> is
  <var>original start node</var>.

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>original start node</var>.

   <li>Set the <a for=CharacterData>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, and count
   <var>original start node</var>'s
   <a>length</a> minus
   <var>original start offset</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.
  </ol>

 <li>
  Otherwise, if <var>first partially contained child</var> is not
  null:

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>first partially contained child</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li>Let <var>subrange</var> be a new <a>live range</a>
   whose <a for=range>start</a> is
   (<var>original start node</var>, <var>original start offset</var>) and
   whose <a for=range>end</a> is
   (<var>first partially contained child</var>, <var>first partially contained child</var>'s <a>length</a>).

   <li><p>Let <var>subfragment</var> be the result of <a for="live range">cloning the contents</a>
   of <var>subrange</var>.

   <li><a>Append</a> <var>subfragment</var> to
   <var>clone</var>.
  </ol>

 <li>
  For each <var>contained child</var> in
  <var>contained children</var>:

  <ol>
   <li>Let <var>clone</var> be a <a lt="clone a node">clone</a> of
   <var>contained child</var> with the <i>clone children flag</i> set.

   <li><a>Append</a> <var>clone</var> to
   <var>fragment</var>.
  </ol>

 <li>
  <p>If <var>last partially contained child</var> is a {{CharacterData}} <a for=/>node</a>, then:

  <p class=note>In this case, <var>last partially contained child</var> is
  <var>original end node</var>.

  <ol>
   <li>Let <var>clone</var> be a <a lt="clone a node">clone</a> of
   <var>original end node</var>.

   <li>Set the <a for=CharacterData>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original end node</var>, offset 0, and count
   <var>original end offset</var>.

   <li><a>Append</a> <var>clone</var> to
   <var>fragment</var>.
  </ol>

 <li>
  Otherwise, if <var>last partially contained child</var> is not
  null:

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>last partially contained child</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li>Let <var>subrange</var> be a new <a>live range</a>
   whose <a for=range>start</a> is
   (<var>last partially contained child</var>, 0) and whose
   <a for=range>end</a> is
   (<var>original end node</var>, <var>original end offset</var>).

   <li><p>Let <var>subfragment</var> be the result of <a for="live range">cloning the contents</a>
   of <var>subrange</var>.

   <li><a>Append</a> <var>subfragment</var> to
   <var>clone</var>.
  </ol>

 <li>Return <var>fragment</var>.
</ol>

<p>The <dfn method for=Range><code>cloneContents()</code></dfn> method steps are to return the
result of <a for="live range">cloning the contents</a> of <a>this</a>.

<p>To <dfn export id=concept-range-insert for="live range">insert</dfn> a <a for=/>node</a>
<var>node</var> into a <a>live range</a> <var>range</var>, run these steps:

<ol>
 <li>If <var>range</var>'s <a for=range>start node</a> is a {{ProcessingInstruction}} or {{Comment}}
 <a for=/>node</a>, is a {{Text}} <a for=/>node</a> whose <a for=tree>parent</a> is null, or is
 <var>node</var>, then <a>throw</a> a "{{HierarchyRequestError!!exception}}" {{DOMException}}.

 <!--
 Behavior for Text node with null parent:

 IE9: Allows it to go through, resulting in the text/comment node having a non-null previousSibling but a null parentNode. (?!)
 Firefox 4.0: Throws non-standard exception
 Chrome 12 dev: Throws "HierarchyRequestError"
 Opera 11.00: Doesn't come up, doesn't allow ranges on detached nodes

 IE is clearly crazy, and non-standard exceptions are no good, so we go with
 WebKit.

 For a Comment node, see https://www.w3.org/Bugs/Public/show_bug.cgi?id=15350.
 IE9, Firefox 12.0a1, and Chrome 17 dev all agree on throwing a
 HierarchyRequestError.  Opera Next 12.00 alpha splits the comment, same as a
 text node.
 -->
 <li>Let <var>referenceNode</var> be null.

 <li>If <var>range</var>'s <a for=range>start node</a>
 is a {{Text}} <a for=/>node</a>,
 set <var>referenceNode</var> to that {{Text}}
 <a for=/>node</a>. <!-- This will change when we split
 it. -->

 <li>Otherwise, set <var>referenceNode</var> to the
 <a for=tree>child</a> of
 <a for=range>start node</a> whose
 <a for=tree>index</a> is
 <a for=range>start offset</a>, and null if
 there is no such <a for=tree>child</a>.

 <li>Let <var>parent</var> be <var>range</var>'s
 <a for=range>start node</a> if <var>referenceNode</var>
 is null, and <var>referenceNode</var>'s
 <a for=tree>parent</a> otherwise.

 <!-- IE9 and Chrome 12 dev throw an exception before splitting the text
 node if the insertBefore() is going to throw an exception (at least if the
 new node is the parent of the start node, for instance). Firefox 4.0 and
 Opera 11.00 don't.  Now that we have "ensure pre-insertion validity," we go
 with the IE/Chrome behavior because it's more correct.

 IE9 doesn't call splitText() if the offset is 0. This makes sense, but I go
 with what all other browsers do. -->
 <li><a>Ensure pre-insertion validity</a>
 of <var>node</var> into <var>parent</var> before
 <var>referenceNode</var>.

 <li>If <var>range</var>'s <a for=range>start node</a> is a {{Text}} <a for=/>node</a>, set
 <var>referenceNode</var> to the result of <a lt="split a Text node">splitting</a> it with
 offset <var>range</var>'s <a for=range>start offset</a>.

 <li>If <var>node</var> is <var>referenceNode</var>, set <var>referenceNode</var> to its
 <a for=tree>next sibling</a>.
 <!-- Because we're about to remove node from its parent. -->

 <li><p>If <var>node</var>'s <a for=tree>parent</a> is non-null, then <a for=/>remove</a>
 <var>node</var>.

 <!-- Browsers disagree on how to handle the case where the range is
 collapsed: do you increment the end offset so the node is now included, or
 not?  DOM 2 Range says no, and Firefox 12.0a1 follows that, but IE9, Chrome
 17 dev, and Opera Next 12.00 alpha all do increment.  Apparently this
 traces back to Acid3 at one point requiring the non-standard behavior.
 Previously the spec matched DOM 2 Range, but it changed to match the
 majority of browsers.  See
 https://www.w3.org/Bugs/Public/show_bug.cgi?id=15297.

 We have to be careful here, because if node is a DocumentFragment, we might
 have inserted any number of nodes, including zero.  One corner case is if
 we insert an empty DocumentFragment and the range is collapsed in a text
 node.  In that case, the text node gets split, but browsers disagree on
 what to do with the range's end.  IE9 leaves it in place; Chrome 17 dev
 moves it to the parent element, before the reference node; Opera Next 12.00
 alpha moves it to the beginning of the new text node.  The spec follows
 WebKit just because it happens to be easier for me to spec.

 The logic for how much to increment the position by is copied from the
 "insert" algorithm.  Getting the new offset right was surprisingly tricky.
 -->
 <li>Let <var>newOffset</var> be <var>parent</var>'s
 <a>length</a> if <var>referenceNode</var> is null,
 and <var>referenceNode</var>'s <a for=tree>index</a>
 otherwise.

 <li>Increase <var>newOffset</var> by <var>node</var>'s
 <a>length</a> if <var>node</var> is a
 {{DocumentFragment}} <a for=/>node</a>, and one otherwise.

 <li><a>Pre-insert</a>
 <var>node</var> into <var>parent</var> before <var>referenceNode</var>.

 <li><p>If <var>range</var> is <a for=range>collapsed</a>, then set <var>range</var>'s
 <a for=range>end</a> to (<var>parent</var>, <var>newOffset</var>).
</ol>

<p>The <dfn method for=Range><code>insertNode(<var>node</var>)</code></dfn> method steps are to
<a for="live range">insert</a> <var>node</var> into <a>this</a>.

<p>The <dfn method for=Range><code>surroundContents(<var>newParent</var>)</code></dfn> method steps
are:

<!--
IE9 and Chrome 12 dev throw exceptions before doing any DOM mutations in at
least some cases, so they don't wind up modifying the DOM halfway. Like if you
try surrounding a selection with an ancestor. As with insertNode(), this is
slightly nicer, but Firefox 4.0 and Opera 11.00 don't do this, and their
behavior is slightly easier to spec, so I go with them for exceptions that are
thrown by things we call, like insertNode(). However, for
BAD_BOUNDARYPOINTS_ERR/INVALID_NODE_TYPE_ERR that we throw ourselves, I do the
check first thing, which matches everyone but Firefox.
-->

<ol>
 <li><p>If a non-{{Text}} <a for=/>node</a> is <a for="live range">partially contained</a> in
 <a>this</a>, then <a>throw</a> an "{{InvalidStateError!!exception}}" {{DOMException}}.
 <!-- XXX Could we rephrase this condition to be more algorithmic and less
 declarative?-->

 <li>
  <p>If <var>newParent</var> is a {{Document}}, {{DocumentType}}, or {{DocumentFragment}}
  <a for=/>node</a>, then <a>throw</a> an "{{InvalidNodeTypeError!!exception}}" {{DOMException}}.

  <p class=note>For historical reasons {{CharacterData}}
  <a for=/>nodes</a> are not checked here and end up throwing later on as a side effect.

 <li><p>Let <var>fragment</var> be the result of <a for="live range">extracting</a> <a>this</a>.
 <!-- If the range contains a DocumentType, Firefox 4.0 and Opera 11.00 don't
 immediately throw here. Firefox removes the non-DocumentType nodes and
 throws, Opera removes all nodes and doesn't throw. This applies to
 extractContents() proper, and also affects surroundContents(). I match DOM 2
 Range, IE9, and Chrome 12 dev. -->

 <li><p>If <var>newParent</var> has <a for=tree>children</a>, then <a for=Node>replace all</a> with
 null within <var>newParent</var>.

 <li><p><a for="live range">Insert</a> <var>newParent</var> into <a>this</a>.

 <li><p><a>Append</a> <var>fragment</var> to <var>newParent</var>.

 <li><p><a for=range>Select</a> <var>newParent</var> within <a>this</a>.
 <!-- Generally this isn't needed, because insertNode() will already do it,
 but it makes a difference in at least one corner case (when the original
 range lies in a single text node). -->
</ol>

<p>The <dfn method for=Range><code>cloneRange()</code></dfn> method steps are to return a new
<a>live range</a> with the same <a for=range>start</a> and <a for=range>end</a> as <a>this</a>.

<p>The <dfn method for=Range><code>detach()</code></dfn> method steps are to do nothing.
<span class=note>Its functionality (disabling a {{Range}} object) was removed, but the method itself
is preserved for compatibility.</span>

<hr>

<dl class=domintro>
 <dt><var ignore>position</var> = <var>range</var> . {{Range/comparePoint(node, offset)}}
 <dd>Returns &minus;1 if the point is before the range, 0 if the point is
 in the range, and 1 if the point is after the range.

 <dt><var ignore>intersects</var> = <var>range</var> . {{Range/intersectsNode(node)}}
 <dd>Returns whether <var>range</var> intersects
 <var>node</var>.
</dl>

<div class=impl>

<p>The <dfn method for=Range><code>isPointInRange(<var>node</var>, <var>offset</var>)</code></dfn>
method steps are:
<!-- Tested October 2011 on Firefox 9.0a2 and Chrome 16 dev.  IE9 and Opera
11.50 don't support the method. -->

<ol>
 <li>If <var>node</var>'s <a for=tree>root</a> is different from <a>this</a>'s
 <a for="live range">root</a>, return false.
 <!-- This happens even if the offset is negative or too large, or if the node
 is a doctype, in both Firefox 9.0a2 and Chrome 16 dev. -->

 <li>If <var>node</var> is a <a>doctype</a>, then <a>throw</a> an
 "{{InvalidNodeTypeError!!exception}}" {{DOMException}}.
 <!-- Firefox 9.0a2 doesn't throw.  It ignores the offset and returns true or
 false depending on whether the doctype itself is in the range.  This makes
 some sense, but it doesn't match how other Range APIs handle doctypes, and
 having the second argument mandatory but ignored is just weird.  Thus I go
 with Chrome 16 dev, although I can see the merit in how Gecko works here. -->

 <li>If <var>offset</var> is greater than <var>node</var>'s <a>length</a>, then <a>throw</a> an
 "{{IndexSizeError!!exception}}" {{DOMException}}.
 <!-- Firefox 9.0a2 doesn't throw.  It seems to return true if the node is
 completely contained in the range, like with selectNode(), and false otherwise -
 even if all boundary points in the node are contained in the range, like
 with selectNodeContents().  This is weird, and inconsistent with other Range
 APIs, so I go with Chrome 16 dev.  This is probably an authoring bug, so it's
 best to throw anyway. -->

 <li>If (<var>node</var>, <var>offset</var>) is
 <a for="boundary point">before</a>
 <a for=range>start</a> or
 <a for="boundary point">after</a>
 <a for=range>end</a>, return false.

 <li>Return true.
</ol>

<p>The <dfn method for=Range><code>comparePoint(<var>node</var>, <var>offset</var>)</code></dfn>
method steps are:
<!-- IE9 doesn't support this method at all.  Firefox 12.0a1, Chrome 17 dev,
and Opera Next 12.00 alpha all do. -->

<ol>
 <li>If <var>node</var>'s <a for=tree>root</a> is different from <a>this</a>'s
 <a for="live range">root</a>, then <a>throw</a> a "{{WrongDocumentError!!exception}}" {{DOMException}}.
 <!-- Opera Next 12.00 alpha seems to return -1 in this case.  The spec matches
 Firefox 12.0a1 and Chrome 17 dev. -->

 <li>If <var>node</var> is a <a>doctype</a>, then <a>throw</a> an
 "{{InvalidNodeTypeError!!exception}}" {{DOMException}}.
 <!-- This matches Chrome 17 dev instead of Firefox 12.0a1 and Opera Next 12.00
 alpha, which don't throw and seem to just ignore the offset instead.  See
 comment for isPointInRange(). -->

 <li>If <var>offset</var> is greater than <var>node</var>'s <a>length</a>, then <a>throw</a> an
 "{{IndexSizeError!!exception}}" {{DOMException}}.
 <!-- This matches Chrome 17 dev instead of Firefox 12.0a1 and Opera Next 12.00
 alpha, which don't throw.  See comment for isPointInRange(). -->

 <li>If (<var>node</var>, <var>offset</var>) is
 <a for="boundary point">before</a>
 <a for=range>start</a>, return &minus;1.

 <li>If (<var>node</var>, <var>offset</var>) is
 <a for="boundary point">after</a>
 <a for=range>end</a>, return 1.

 <li>Return 0.
</ol>

<hr>

<p>The <dfn method for=Range><code>intersectsNode(<var>node</var>)</code></dfn> method steps are:
<!-- Supported by Chrome 17 dev and Opera Next 12.00 alpha, but not IE9 or
Firefox 12.0a1. -->

<ol>
 <li>If <var>node</var>'s <a for=tree>root</a>
 is different from <a>this</a>'s
 <a for="live range">root</a>, return false.
 <!-- It seems like for doctypes, Opera Next 12.00 alpha throws
 InvalidNodeTypeError instead of returning false.  The spec follows Chrome
 17 dev. -->

 <li>Let <var>parent</var> be <var>node</var>'s
 <a for=tree>parent</a>.

 <li>If <var>parent</var> is null, return true.
 <!-- browsers currently throw, but are willing to change
      https://www.w3.org/Bugs/Public/show_bug.cgi?id=16759 -->

 <li>Let <var>offset</var> be <var>node</var>'s
 <a for=tree>index</a>.

 <li>If (<var>parent</var>, <var>offset</var>) is
 <a for="boundary point">before</a>
 <a for=range>end</a> and (<var>parent</var>,
 <var>offset</var> plus 1) is
 <a for="boundary point">after</a>
 <a for=range>start</a>, return true.

 <li>Return false.
</ol>

</div>

<hr>

<p>The <dfn export for=Range id=dom-range-stringifier>stringification behavior</dfn> must run
these steps:

<ol>
 <li><p>Let <var>s</var> be the empty string.

 <li><p>If <a>this</a>'s <a for=range>start node</a> is <a>this</a>'s <a for=range>end node</a> and
 it is a {{Text}} <a for=/>node</a>, then return the substring of that {{Text}} <a for=/>node</a>'s
 <a for=CharacterData>data</a> beginning at <a>this</a>'s <a for=range>start offset</a> and ending
 at <a>this</a>'s <a for=range>end offset</a>.

 <li><p>If <a>this</a>'s <a for=range>start node</a> is a {{Text}} <a for=/>node</a>, then append
 the substring of that <a for=/>node</a>'s <a for=CharacterData>data</a> from <a>this</a>'s
 <a for=range>start offset</a> until the end to <var>s</var>.

 <li><p>Append the <a for=string>concatenation</a> of the <a for=CharacterData>data</a> of all
 {{Text}} <a for=/>nodes</a> that are <a for="live range">contained</a> in <a>this</a>, in
 <a>tree order</a>, to <var>s</var>.

 <li><p>If <a>this</a>'s <a for=range>end node</a> is a {{Text}} <a for=/>node</a>, then
 append the substring of that <a for=/>node</a>'s <a for=CharacterData>data</a> from its start until
 <a>this</a>'s <a for=range>end offset</a> to <var>s</var>.

 <li><p>Return <var>s</var>.
</ol>

<hr>

<p class=note>The {{createContextualFragment()}}, {{Range/getClientRects()}},
and {{Range/getBoundingClientRect()}} methods are defined in other specifications.
[[DOM-Parsing]]
[[CSSOM-VIEW]]



<h2 id="traversal">Traversal</h2>

<p>{{NodeIterator}} and {{TreeWalker}} objects can be used to filter and traverse <a for=/>node</a>
<a>trees</a>.

<p>Each {{NodeIterator}} and {{TreeWalker}} object has an associated
<dfn noexport id=concept-traversal-active for=traversal>active flag</dfn> to avoid recursive
invocations. It is initially unset.

<p>Each {{NodeIterator}} and {{TreeWalker}} object also has an associated
<dfn noexport id=concept-traversal-root for=traversal>root</dfn> (a <a for=/>node</a>), a
<dfn noexport id=concept-traversal-whattoshow for=traversal>whatToShow</dfn> (a bitmask), and a
<dfn noexport id=concept-traversal-filter for=traversal>filter</dfn> (a callback).

<p>To <dfn noexport id=concept-node-filter>filter</dfn> a <a for=/>node</a> <var>node</var> within
a {{NodeIterator}} or {{TreeWalker}} object <var>traverser</var>, run these steps:

<ol>
 <li><p>If <var>traverser</var>'s <a for=traversal>active flag</a> is set, then throw an
 "{{InvalidStateError!!exception}}" {{DOMException}}.

 <li><p>Let <var>n</var> be <var>node</var>'s {{Node/nodeType}} attribute value &minus; 1.

 <li><p>If the <var>n</var><sup>th</sup> bit (where 0 is the least significant bit) of
 <var>traverser</var>'s <a for=traversal>whatToShow</a> is not set, then return
 {{NodeFilter/FILTER_SKIP}}.
 <!-- !((1 << (node.nodeType - 1)) & whatToShow) -->

 <li><p>If <var>traverser</var>'s <a for=traversal>filter</a> is null, then return
 {{NodeFilter/FILTER_ACCEPT}}.

 <li><p>Set <var>traverser</var>'s <a for=traversal>active flag</a>.

 <li><p>Let <var>result</var> be the return value of <a>call a user object's operation</a> with
 <var>traverser</var>'s <a for=traversal>filter</a>, "<code>acceptNode</code>", and
 « <var>node</var> ». If this throws an exception, then unset <var>traverser</var>'s
 <a for=traversal>active flag</a> and rethrow the exception.

 <li><p>Unset <var>traverser</var>'s <a for=traversal>active flag</a>.

 <li><p>Return <var>result</var>.
</ol>


<h3 id="interface-nodeiterator">Interface {{NodeIterator}}</h3>

<pre class=idl>
[Exposed=Window]
interface NodeIterator {
  [SameObject] readonly attribute Node root;
  readonly attribute Node referenceNode;
  readonly attribute boolean pointerBeforeReferenceNode;
  readonly attribute unsigned long whatToShow;
  readonly attribute NodeFilter? filter;

  Node? nextNode();
  Node? previousNode();

  undefined detach();
};
</pre>

<p class=note>{{NodeIterator}} objects can be created using the
{{createNodeIterator()}} method on {{Document}} objects.

<p>Each {{NodeIterator}} object has an associated
<dfn noexport for=NodeIterator id="iterator-collection">iterator collection</dfn>, which is a
<a for=/>collection</a> rooted at the {{NodeIterator}} object's <a for=traversal>root</a>, whose
filter matches any <a for=/>node</a>.

<p>Each {{NodeIterator}} object also has an associated <dfn for=NodeIterator>reference</dfn> (a
<a for=/>node</a>) and <dfn for=NodeIterator>pointer before reference</dfn> (a boolean).

<p class=note>As mentioned earlier, {{NodeIterator}} objects have an associated
<a for=traversal>active flag</a>, <a for=traversal>root</a>, <a for=traversal>whatToShow</a>, and
<a for=traversal>filter</a> as well.

<p>The <dfn><code>NodeIterator</code> pre-removing steps</dfn> given a <var>nodeIterator</var> and
<var>toBeRemovedNode</var>, are as follows:

<ol>
 <li><p>If <var>toBeRemovedNode</var> is not an <a for=tree>inclusive ancestor</a> of
 <var>nodeIterator</var>'s <a for=NodeIterator>reference</a>, or <var>toBeRemovedNode</var> is
 <var>nodeIterator</var>'s <a for=traversal>root</a>, then return.

 <li>
  <p>If <var>nodeIterator</var>'s <a for=NodeIterator>pointer before reference</a> is true, then:

  <ol>
   <li><p>Let <var>next</var> be <var>toBeRemovedNode</var>'s first <a>following</a>
   <a for=/>node</a> that is an <a>inclusive descendant</a> of <var>nodeIterator</var>'s
   <a for=traversal>root</a> and is not an <a>inclusive descendant</a> of
   <var>toBeRemovedNode</var>, and null if there is no such <a for=/>node</a>.

   <li><p>If <var>next</var> is non-null, then set <var>nodeIterator</var>'s
   <a for=NodeIterator>reference</a> to <var>next</var> and return.

   <li>
    <p>Otherwise, set <var>nodeIterator</var>'s <a for=NodeIterator>pointer before reference</a> to
    false.

    <p class=note>Steps are not terminated here.
  </ol>

 <li><p>Set <var>nodeIterator</var>'s <a for=NodeIterator>reference</a> to
 <var>toBeRemovedNode</var>'s <a for=tree>parent</a>, if <var>toBeRemovedNode</var>'s
 <a>previous sibling</a> is null, and to the <a>inclusive descendant</a> of
 <var>toBeRemovedNode</var>'s <a>previous sibling</a> that appears last in <a>tree order</a>
 otherwise.
</ol>

<hr>

<p>The <dfn attribute for=NodeIterator><code>root</code></dfn> getter steps are to return
<a>this</a>'s <a for=traversal>root</a>.

<p>The <dfn attribute for=NodeIterator><code>referenceNode</code></dfn> getter steps are to return
<a>this</a>'s <a for=NodeIterator>reference</a>.

<p>The <dfn attribute for=NodeIterator><code>pointerBeforeReferenceNode</code></dfn> getter steps
are to return <a>this</a>'s <a for=NodeIterator>pointer before reference</a>.

<p>The <dfn attribute for=NodeIterator><code>whatToShow</code></dfn> getter steps are to return
<a>this</a>'s <a for=traversal>whatToShow</a>.

<p>The <dfn attribute for=NodeIterator><code>filter</code></dfn> getter steps are to return
<a>this</a>'s <a for=traversal>filter</a>.

<p>To <dfn export id=concept-nodeiterator-traverse for=NodeIterator>traverse</dfn>, given a
{{NodeIterator}} object <var>iterator</var> and a direction <var>direction</var>, run these steps:

<ol>
 <li><p>Let <var>node</var> be <var>iterator</var>'s <a for=NodeIterator>reference</a>.

 <li><p>Let <var>beforeNode</var> be <var>iterator</var>'s
 <a for=NodeIterator>pointer before reference</a>.

 <li>
  <p>While true:

  <ol>
   <li>
    <p>Branch on <var>direction</var>:

    <dl class=switch>
     <dt>next
     <dd>
      <p>If <var>beforeNode</var> is false, then set <var>node</var> to the first <a for=/>node</a>
      <a>following</a> <var>node</var> in <var>iterator</var>'s
      <a for=NodeIterator>iterator collection</a>. If there is no such <a for=/>node</a>, then
      return null.

      <p>If <var>beforeNode</var> is true, then set it to false.

     <dt>previous
     <dd>
      <p>If <var>beforeNode</var> is true, then set <var>node</var> to the first <a for=/>node</a>
      <a>preceding</a> <var>node</var> in <var>iterator</var>'s
      <a for=NodeIterator>iterator collection</a>. If there is no such <a for=/>node</a>, then
      return null.

      <p>If <var>beforeNode</var> is false, then set it to true.
    </dl>

   <li><p>Let <var>result</var> be the result of <a for=/>filtering</a> <var>node</var> within
   <var>iterator</var>.

   <li><p>If <var>result</var> is {{NodeFilter/FILTER_ACCEPT}}, then <a for=iteration>break</a>.
  </ol>

 <li><p>Set <var>iterator</var>'s <a for=NodeIterator>reference</a> to <var>node</var>.

 <li><p>Set <var>iterator</var>'s <a for=NodeIterator>pointer before reference</a> to
 <var>beforeNode</var>.

 <li><p>Return <var>node</var>.
</ol>

<p>The <dfn method for=NodeIterator><code>nextNode()</code></dfn> method steps are to return the
result of <a for=NodeIterator>traversing</a> with <a>this</a> and next.

<p>The <dfn method for=NodeIterator><code>previousNode()</code></dfn> method steps are to return the
result of <a for=NodeIterator>traversing</a> with <a>this</a> and previous.

<p>The <dfn method for=NodeIterator><code>detach()</code></dfn> method steps are to do nothing.
<span class=note>Its functionality (disabling a {{NodeIterator}} object) was removed, but the method
itself is preserved for compatibility.</span>


<h3 id=interface-treewalker>Interface {{TreeWalker}}</h3>

<pre class=idl>
[Exposed=Window]
interface TreeWalker {
  [SameObject] readonly attribute Node root;
  readonly attribute unsigned long whatToShow;
  readonly attribute NodeFilter? filter;
           attribute Node currentNode;

  Node? parentNode();
  Node? firstChild();
  Node? lastChild();
  Node? previousSibling();
  Node? nextSibling();
  Node? previousNode();
  Node? nextNode();
};</pre>

<p class=note>{{TreeWalker}} objects can be created using the {{createTreeWalker()}}
method on {{Document}} objects.

<p>Each {{TreeWalker}} object has an associated <dfn for=TreeWalker>current</dfn> (a
<a for=/>node</a>).

<p class=note>As mentioned earlier {{TreeWalker}} objects have an associated
<a for=traversal>root</a>, <a for=traversal>whatToShow</a>, and <a for=traversal>filter</a> as well.

<p>The <dfn attribute for=TreeWalker><code>root</code></dfn> getter steps are to return
<a>this</a>'s <a for=traversal>root</a>.

<p>The <dfn attribute for=TreeWalker><code>whatToShow</code></dfn> getter steps are to return
<a>this</a>'s <a for=traversal>whatToShow</a>.

<p>The <dfn attribute for=TreeWalker><code>filter</code></dfn> getter steps are to return
<a>this</a>'s <a for=traversal>filter</a>.

<p>The <dfn attribute for=TreeWalker><code>currentNode</code></dfn> getter steps are to return
<a>this</a>'s <a for=TreeWalker>current</a>.

<p>The {{TreeWalker/currentNode}} setter steps are to set <a>this</a>'s
<a for=TreeWalker>current</a> to the given value.

<hr>

<p>The <dfn method for=TreeWalker><code>parentNode()</code></dfn> method steps are:

<ol>
 <li><p>Let <var>node</var> be <a>this</a>'s <a for=TreeWalker>current</a>.

 <li>
  <p>While <var>node</var> is non-null and is not <a>this</a>'s
  <a for=traversal>root</a>:

  <ol>
   <li><p>Set <var>node</var> to <var>node</var>'s <a for=tree>parent</a>.

   <li><p>If <var>node</var> is non-null and <a for=/>filtering</a> <var>node</var> within
   <a>this</a> returns {{NodeFilter/FILTER_ACCEPT}}, then set <a>this</a>'s
   <a for=TreeWalker>current</a> to <var>node</var> and return <var>node</var>.
  </ol>

 <li><p>Return null.
</ol>

<p>To <dfn noexport for=TreeWalker id=concept-traverse-children>traverse children</dfn>, given a
<var>walker</var> and <var>type</var>, run these steps:

<ol>
 <li><p>Let <var>node</var> be <var>walker</var>'s <a for=TreeWalker>current</a>.

 <li><p>Set <var>node</var> to <var>node</var>'s <a for=tree>first child</a> if <var>type</var> is
 first, and <var>node</var>'s <a for=tree>last child</a> if <var>type</var> is last.

 <li>
  <p>While <var>node</var> is non-null:

  <ol>
   <li><p>Let <var>result</var> be the result of <a for=/>filtering</a> <var>node</var> within
   <var>walker</var>.

   <li><p>If <var>result</var> is {{NodeFilter/FILTER_ACCEPT}}, then set <var>walker</var>'s
   <a for=TreeWalker>current</a> to <var>node</var> and return <var>node</var>.

   <li>
    <p>If <var>result</var> is {{NodeFilter/FILTER_SKIP}}, then:

    <ol>
     <li><p>Let <var>child</var> be <var>node</var>'s <a for=tree>first child</a> if <var>type</var>
     is first, and <var>node</var>'s <a for=tree>last child</a> if <var>type</var> is last.

     <li><p>If <var>child</var> is non-null, then set <var>node</var> to <var>child</var> and
     <a for=iteration>continue</a>.
    </ol>

   <li>
    <p>While <var>node</var> is non-null:

    <ol>
     <li><p>Let <var>sibling</var> be <var>node</var>'s <a for=tree>next sibling</a> if
     <var>type</var> is first, and <var>node</var>'s <a for=tree>previous sibling</a> if
     <var>type</var> is last.

     <li><p>If <var>sibling</var> is non-null, then set <var>node</var> to <var>sibling</var> and
     <a for=iteration>break</a>.

     <li><p>Let <var>parent</var> be <var>node</var>'s <a for=tree>parent</a>.

     <li><p>If <var>parent</var> is null, <var>walker</var>'s <a for=traversal>root</a>, or
     <var>walker</var>'s <a for=TreeWalker>current</a>, then return null.

     <li><p>Set <var>node</var> to <var>parent</var>.
    </ol>
  </ol>

 <li><p>Return null.
</ol>

<p>The <dfn method for=TreeWalker><code>firstChild()</code></dfn> method steps are to
<a>traverse children</a> with <a>this</a> and first.

<p>The <dfn method for=TreeWalker><code>lastChild()</code></dfn> method steps are to
<a>traverse children</a> with <a>this</a> and last.

<p>To <dfn noexport id=concept-traverse-siblings>traverse siblings</dfn>, given a <var>walker</var>
and <var>type</var>, run these steps:

<ol>
 <li><p>Let <var>node</var> be <var>walker</var>'s <a for=TreeWalker>current</a>.

 <li><p>If <var>node</var> is <a for=traversal>root</a>, then return null.

 <li>
  <p>While true:

  <ol>
   <li><p>Let <var>sibling</var> be <var>node</var>'s <a for=tree>next sibling</a> if
   <var>type</var> is next, and <var>node</var>'s <a for=tree>previous sibling</a> if
   <var>type</var> is previous.

   <li>
    <p>While <var>sibling</var> is non-null:

    <ol>
     <li><p>Set <var>node</var> to <var>sibling</var>.

     <li><p>Let <var>result</var> be the result of <a for=/>filtering</a> <var>node</var> within
     <var>walker</var>.

     <li><p>If <var>result</var> is {{NodeFilter/FILTER_ACCEPT}}, then set <var>walker</var>'s
     <a for=TreeWalker>current</a> to <var>node</var> and return <var>node</var>.

     <li><p>Set <var>sibling</var> to <var>node</var>'s <a for=tree>first child</a> if
     <var>type</var> is next, and <var>node</var>'s <a for=tree>last child</a> if <var>type</var> is
     previous.

     <li><p>If <var>result</var> is {{NodeFilter/FILTER_REJECT}} or <var>sibling</var> is null, then
     set <var>sibling</var> to <var>node</var>'s <a for=tree>next sibling</a> if <var>type</var> is
     next, and <var>node</var>'s <a for=tree>previous sibling</a> if <var>type</var> is previous.
    </ol>

   <li><p>Set <var>node</var> to <var>node</var>'s <a for=tree>parent</a>.

   <li><p>If <var>node</var> is null or <var>walker</var>'s <a for=traversal>root</a>, then return
   null.

   <li><p>If the return value of <a for=/>filtering</a> <var>node</var> within <var>walker</var> is
   {{NodeFilter/FILTER_ACCEPT}}, then return null.
  </ol>
</ol>

<p>The <dfn method for=TreeWalker><code>nextSibling()</code></dfn> method steps are to
<a>traverse siblings</a> with <a>this</a> and next.

<p>The <dfn method for=TreeWalker><code>previousSibling()</code></dfn> method steps are to
<a>traverse siblings</a> with <a>this</a> and previous.

<p>The <dfn method for=TreeWalker><code>previousNode()</code></dfn> method steps are:

<ol>
 <li><p>Let <var>node</var> be <a>this</a>'s <a for=TreeWalker>current</a>.

 <li>
  <p>While <var>node</var> is not <a>this</a>'s <a for=traversal>root</a>:

  <ol>
   <li><p>Let <var>sibling</var> be <var>node</var>'s <a for=tree>previous sibling</a>.

   <li>
    <p>While <var>sibling</var> is non-null:

    <ol>
     <li><p>Set <var>node</var> to <var>sibling</var>.

     <li><p>Let <var>result</var> be the result of <a for=/>filtering</a> <var>node</var> within
     <a>this</a>.

     <li>
      <p>While <var>result</var> is not {{NodeFilter/FILTER_REJECT}} and <var>node</var> has a
      <a for=tree>child</a>:

      <ol>
       <li><p>Set <var>node</var> to <var>node</var>'s <a for=tree>last child</a>.

       <li><p>Set <var>result</var> to the result of <a for=/>filtering</a> <var>node</var> within
       <a>this</a>.
      </ol>

     <li><p>If <var>result</var> is {{NodeFilter/FILTER_ACCEPT}}, then set <a>this</a>'s
     <a for=TreeWalker>current</a> to <var>node</var> and return <var>node</var>.

     <li><p>Set <var>sibling</var> to <var>node</var>'s <a for=tree>previous sibling</a>.
    </ol>

   <li><p>If <var>node</var> is <a>this</a>'s <a for=traversal>root</a> or <var>node</var>'s
   <a for=tree>parent</a> is null, then return null.

   <li><p>Set <var>node</var> to <var>node</var>'s <a for=tree>parent</a>.

   <li><p>If the return value of <a for=/>filtering</a> <var>node</var> within <a>this</a> is
   {{NodeFilter/FILTER_ACCEPT}}, then set <a>this</a>'s <a for=TreeWalker>current</a> to
   <var>node</var> and return <var>node</var>.
  </ol>

 <li><p>Return null.
</ol>

<p>The <dfn method for=TreeWalker><code>nextNode()</code></dfn> method steps are:

<ol>
 <li><p>Let <var>node</var> be <a>this</a>'s <a for=TreeWalker>current</a>.

 <li><p>Let <var>result</var> be {{NodeFilter/FILTER_ACCEPT}}.

 <li>
  <p>While true:

  <ol>
   <li>
    <p>While <var>result</var> is not {{NodeFilter/FILTER_REJECT}} and <var>node</var> has a
    <a for=tree>child</a>:

    <ol>
     <li><p>Set <var>node</var> to its <a for=tree>first child</a>.

     <li><p>Set <var>result</var> to the result of <a for=/>filtering</a> <var>node</var> within
     <a>this</a>.

     <li><p>If <var>result</var> is {{NodeFilter/FILTER_ACCEPT}}, then set <a>this</a>'s
     <a for=TreeWalker>current</a> to <var>node</var> and return <var>node</var>.
    </ol>

   <li><p>Let <var>sibling</var> be null.

   <li><p>Let <var>temporary</var> be <var>node</var>.

   <li>
    <p>While <var>temporary</var> is non-null:

    <ol>
     <li><p>If <var>temporary</var> is <a>this</a>'s <a for=traversal>root</a>, then return null.

     <li><p>Set <var>sibling</var> to <var>temporary</var>'s <a for=tree>next sibling</a>.

     <li><p>If <var>sibling</var> is non-null, then set <var>node</var> to <var>sibling</var> and
     <a for=iteration>break</a>.

     <li><p>Set <var>temporary</var> to <var>temporary</var>'s <a for=tree>parent</a>.
    </ol>

   <li><p>Set <var>result</var> to the result of <a for=/>filtering</a> <var>node</var> within
   <a>this</a>.

   <li><p>If <var>result</var> is {{NodeFilter/FILTER_ACCEPT}}, then set <a>this</a>'s
   <a for=TreeWalker>current</a> to <var>node</var> and return <var>node</var>.
  </ol>
</ol>


<h3 id="interface-nodefilter">Interface {{NodeFilter}}</h3>

<pre class=idl>
[Exposed=Window]
callback interface NodeFilter {
  // Constants for acceptNode()
  const unsigned short FILTER_ACCEPT = 1;
  const unsigned short FILTER_REJECT = 2;
  const unsigned short FILTER_SKIP = 3;

  // Constants for whatToShow
  const unsigned long SHOW_ALL = 0xFFFFFFFF;
  const unsigned long SHOW_ELEMENT = 0x1;
  const unsigned long SHOW_ATTRIBUTE = 0x2;
  const unsigned long SHOW_TEXT = 0x4;
  const unsigned long SHOW_CDATA_SECTION = 0x8;
  const unsigned long SHOW_ENTITY_REFERENCE = 0x10; // legacy
  const unsigned long SHOW_ENTITY = 0x20; // legacy
  const unsigned long SHOW_PROCESSING_INSTRUCTION = 0x40;
  const unsigned long SHOW_COMMENT = 0x80;
  const unsigned long SHOW_DOCUMENT = 0x100;
  const unsigned long SHOW_DOCUMENT_TYPE = 0x200;
  const unsigned long SHOW_DOCUMENT_FRAGMENT = 0x400;
  const unsigned long SHOW_NOTATION = 0x800; // legacy

  unsigned short acceptNode(Node node);
};
</pre>

<p class=note>{{NodeFilter}} objects can be used as <a for=traversal>filter</a> for
{{NodeIterator}} and {{TreeWalker}} objects and also provide constants for their
<a for=traversal>whatToShow</a> bitmask. A {{NodeFilter}} object is typically implemented as a
JavaScript function.

<p>These constants can be used as <a for=traversal>filter</a> return value:

<ul class=brief>
 <li><dfn const for=NodeFilter><code>FILTER_ACCEPT</code></dfn> (1);
 <li><dfn const for=NodeFilter><code>FILTER_REJECT</code></dfn> (2);
 <li><dfn const for=NodeFilter><code>FILTER_SKIP</code></dfn> (3).
</ul>

<p>These constants can be used for <a for=traversal>whatToShow</a>:

<ul class=brief>
 <li><dfn const for=NodeFilter><code>SHOW_ALL</code></dfn> (4294967295, FFFFFFFF in hexadecimal);
 <li><dfn const for=NodeFilter><code>SHOW_ELEMENT</code></dfn> (1);
 <li><dfn const for=NodeFilter><code>SHOW_ATTRIBUTE</code></dfn> (2);
 <li><dfn const for=NodeFilter><code>SHOW_TEXT</code></dfn> (4);
 <li><dfn const for=NodeFilter><code>SHOW_CDATA_SECTION</code></dfn> (8);
 <li><dfn const for=NodeFilter><code>SHOW_PROCESSING_INSTRUCTION</code></dfn> (64, 40 in hexadecimal);
 <li><dfn const for=NodeFilter><code>SHOW_COMMENT</code></dfn> (128, 80 in hexadecimal);
 <li><dfn const for=NodeFilter><code>SHOW_DOCUMENT</code></dfn> (256, 100 in hexadecimal);
 <li><dfn const for=NodeFilter><code>SHOW_DOCUMENT_TYPE</code></dfn> (512, 200 in hexadecimal);
 <li><dfn const for=NodeFilter><code>SHOW_DOCUMENT_FRAGMENT</code></dfn> (1024, 400 in hexadecimal).
</ul>



<h2 id="sets">Sets</h2>

<p class=note>Yes, the name {{DOMTokenList}} is an unfortunate legacy mishap.

<h3 id="interface-domtokenlist">Interface {{DOMTokenList}}</h3>

<pre class=idl>
[Exposed=Window]
interface DOMTokenList {
  readonly attribute unsigned long length;
  getter DOMString? item(unsigned long index);
  boolean contains(DOMString token);
  [CEReactions] undefined add(DOMString... tokens);
  [CEReactions] undefined remove(DOMString... tokens);
  [CEReactions] boolean toggle(DOMString token, optional boolean force);
  [CEReactions] boolean replace(DOMString token, DOMString newToken);
  boolean supports(DOMString token);
  [CEReactions] stringifier attribute DOMString value;
  iterable&lt;DOMString>;
};
</pre>

<p>A {{DOMTokenList}} object has an associated
<dfn export id=concept-dtl-tokens for=DOMTokenList>token set</dfn> (a <a for=/>set</a>), which is
initially empty.

<p>A {{DOMTokenList}} object also has an associated <a for=/>element</a> and an <a>attribute</a>'s
<a for=Attr>local name</a>.

<a lt="Other applicable specifications">Specifications</a> may define
<dfn export for=Node id=concept-supported-tokens>supported tokens</dfn> for a {{DOMTokenList}}'s
associated <a>attribute</a>'s <a for=Attr>local name</a>.

<p>A {{DOMTokenList}} object's
<dfn export id=concept-domtokenlist-validation for=DOMTokenList>validation steps</dfn> for a given
<var>token</var> are:

<ol>
 <li><p>If the associated <a>attribute</a>'s <a for=Attr>local name</a> does not define
 <a for=Node>supported tokens</a>, <a>throw</a> a <code>TypeError</code>.

 <li><p>Let <var>lowercase token</var> be a copy of <var>token</var>, in <a>ASCII lowercase</a>.

 <li><p>If <var>lowercase token</var> is present in <a for=Node>supported tokens</a>, return true.

 <li><p>Return false.
</ol>

<p>A {{DOMTokenList}} object's <dfn id=concept-dtl-update for="DOMTokenList">update steps</dfn> are:

<ol>
 <li><p>If the associated <a for=/>element</a> does not have an associated <a>attribute</a> and
 <a>token set</a> is empty, then return.

 <li><p><a>Set an attribute value</a> for the associated <a for=/>element</a> using associated
 <a>attribute</a>'s <a for=Attr>local name</a> and the result of running the <a>ordered set
 serializer</a> for <a>token set</a>.
</ol>

<p>A {{DOMTokenList}} object's <dfn id=concept-dtl-serialize for=DOMTokenList>serialize steps</dfn>
are to return the result of running <a>get an attribute value</a> given the associated
<a for=/>element</a> and the associated <a>attribute</a>'s <a for=Attr>local name</a>.</p>

<hr>

<p>A {{DOMTokenList}} object has these <a>attribute change steps</a> for its associated
<a for=/>element</a>:

<ol>
 <li><p>If <var>localName</var> is associated attribute's <a for=Attr>local name</a>,
 <var>namespace</var> is null, and <var>value</var> is null, then <a for=set>empty</a>
 <a>token set</a>.

 <li><p>Otherwise, if <var>localName</var> is associated attribute's <a for=Attr>local name</a>,
 <var>namespace</var> is null, then set <a>token set</a> to <var>value</var>,
 <a lt="ordered set parser">parsed</a>.
</ol>

<p>When a {{DOMTokenList}} object is created, then:

<ol>
 <li><p>Let <var>element</var> be associated <a for=/>element</a>.

 <li><p>Let <var>localName</var> be associated attribute's <a for=Attr>local name</a>.

 <li><p>Let <var>value</var> be the result of
 <a lt="get an attribute value">getting an attribute value</a> given <var>element</var> and
 <var>localName</var>.

 <li><p>Run the <a>attribute change steps</a> for <var>element</var>, <var>localName</var>,
 <var>value</var>, <var>value</var>, and null.
</ol>

<dl class=domintro>
 <dt><code><var>tokenlist</var> . {{DOMTokenList/length}}</code>
 <dd><p>Returns the number of tokens.

 <dt><code><var>tokenlist</var> . {{DOMTokenList/item(index)}}</code>
 <dt><code><var>tokenlist</var>[<var>index</var>]</code>
 <dd><p>Returns the token with index <var>index</var>.

 <dt><code><var>tokenlist</var> . {{DOMTokenList/contains(token)}}</code>
 <dd><p>Returns true if <var>token</var> is present; otherwise false.

 <dt><code><var>tokenlist</var> . <a for=DOMTokenList lt="add()">add(<var>tokens</var>&hellip;)</a></code>
 <dd>
  <p>Adds all arguments passed, except those already present.
  <p>Throws a "{{SyntaxError!!exception}}" {{DOMException}} if one of the arguments is the empty
  string.
  <p>Throws an "{{InvalidCharacterError!!exception}}" {{DOMException}} if one of the arguments
  contains any <a>ASCII whitespace</a>.

 <dt><code><var>tokenlist</var> . <a for=DOMTokenList lt="remove()">remove(<var>tokens</var>&hellip;)</a></code>
 <dd>
  <p>Removes arguments passed, if they are present.
  <p>Throws a "{{SyntaxError!!exception}}" {{DOMException}} if one of the arguments is the empty
  string.
  <p>Throws an "{{InvalidCharacterError!!exception}}" {{DOMException}} if one of the arguments
  contains any <a>ASCII whitespace</a>.

 <dt><code><var>tokenlist</var> . <a method for=DOMTokenList lt="toggle()">toggle(<var>token</var> [, <var>force</var>])</a></code>
 <dd>
  <p>If <var>force</var> is not given, "toggles" <var>token</var>, removing it if it's present and
  adding it if it's not present. If <var>force</var> is true, adds <var>token</var>
  (same as {{add()}}). If <var>force</var> is false, removes <var>token</var> (same
  as {{DOMTokenList/remove()}}).
  <p>Returns true if <var>token</var> is now present; otherwise false.
  <p>Throws a "{{SyntaxError!!exception}}" {{DOMException}} if <var>token</var> is empty.
  <p>Throws an "{{InvalidCharacterError!!exception}}" {{DOMException}} if <var>token</var> contains
  any spaces.

 <dt><code><var>tokenlist</var> . <a method for=DOMTokenList lt=replace()>replace(<var>token</var>, <var>newToken</var>)</a></code>
 <dd>
  <p>Replaces <var>token</var> with <var>newToken</var>.
  <p>Returns true if <var>token</var> was replaced with <var>newToken</var>; otherwise false.
  <p>Throws a "{{SyntaxError!!exception}}" {{DOMException}} if one of the arguments is the empty
  string.
  <p>Throws an "{{InvalidCharacterError!!exception}}" {{DOMException}} if one of the arguments
  contains any <a>ASCII whitespace</a>.

 <dt><code><var>tokenlist</var> . <a method for=DOMTokenList lt="supports()">supports(<var>token</var>)</a></code>
 <dd>
  <p>Returns true if <var>token</var> is in the associated attribute's supported tokens. Returns
  false otherwise.
  <p>Throws a <code>TypeError</code> if the associated attribute has no supported tokens defined.

 <dt><code><var>tokenlist</var> . {{DOMTokenList/value}}</code>
 <dd>
  <p>Returns the associated set as string.
  <p>Can be set, to change the associated attribute.
</dl>

<p>The <dfn attribute for=DOMTokenList><code>length</code></dfn> attribute' getter must return
<a>this</a>'s <a>token set</a>'s <a for=set>size</a>.

<p>The object's <a>supported property indices</a> are the numbers in the range zero to object's
<a>token set</a>'s <a for=set>size</a> minus one, unless <a>token set</a> <a for=set>is empty</a>,
in which case there are no <a>supported property indices</a>.

<p>The <dfn method for="DOMTokenList"><code>item(<var>index</var>)</code></dfn> method steps are:

<ol>
 <li><p>If <var>index</var> is equal to or greater than <a>this</a>'s <a>token set</a>'s
 <a for=set>size</a>, then return null.

 <li><p>Return <a>this</a>'s <a>token set</a>[<var>index</var>].
</ol>

<p>The <dfn method for="DOMTokenList"><code>contains(<var>token</var>)</code></dfn> method steps are
to return true if <a>this</a>'s <a>token set</a>[<var>token</var>] <a for=set>exists</a>; otherwise
false.

<p>The
<dfn method for="DOMTokenList" lt="add(tokens)|add()"><code>add(<var>tokens</var>&hellip;)</code></dfn>
method steps are:

<ol>
 <li>
  <p><a for=list>For each</a> <var>token</var> in <var>tokens</var>:

  <ol>
   <li><p>If <var>token</var> is the empty string, then <a>throw</a> a "{{SyntaxError!!exception}}"
   {{DOMException}}.

   <li><p>If <var>token</var> contains any <a>ASCII whitespace</a>, then <a>throw</a> an
   "{{InvalidCharacterError!!exception}}" {{DOMException}}.
  </ol>

 <li><p><a for=list>For each</a> <var>token</var> in <var>tokens</var>, <a for=set>append</a>
 <var>token</var> to <a>this</a>'s <a>token set</a>.

 <li><p>Run the <a>update steps</a>.
</ol>

<p>The
<dfn method for="DOMTokenList" lt="remove(tokens)|remove()"><code>remove(<var>tokens</var>&hellip;)</code></dfn>
method steps are:

<ol>
 <li>
  <p><a for=list>For each</a> <var>token</var> in <var>tokens</var>:

  <ol>
   <li><p>If <var>token</var> is the empty string, then <a>throw</a> a "{{SyntaxError!!exception}}"
   {{DOMException}}.

   <li><p>If <var>token</var> contains any <a>ASCII whitespace</a>, then <a>throw</a> an
   "{{InvalidCharacterError!!exception}}" {{DOMException}}.
  </ol>

 <li><p>For each <var>token</var> in <var>tokens</var>, <a for=set>remove</a> <var>token</var> from
 <a>this</a>'s <a>token set</a>.

 <li><p>Run the <a>update steps</a>.
</ol>

<p>The <dfn method for=DOMTokenList><code>toggle(<var>token</var>, <var>force</var>)</code></dfn>
method steps are:

<ol>
 <li><p>If <var>token</var> is the empty string, then <a>throw</a> a "{{SyntaxError!!exception}}"
 {{DOMException}}.

 <li><p>If <var>token</var> contains any <a>ASCII whitespace</a>, then <a>throw</a> an
 "{{InvalidCharacterError!!exception}}" {{DOMException}}.

 <li>
  <p>If <a>this</a>'s <a>token set</a>[<var>token</var>] <a for=set>exists</a>, then:

  <ol>
   <li><p>If <var>force</var> is either not given or is false, then <a for=set>remove</a>
   <var>token</var> from <a>this</a>'s <a>token set</a>, run the <a>update steps</a> and return
   false.

   <li><p>Return true.
  </ol>

 <li><p>Otherwise, if <var>force</var> not given or is true, <a for=set>append</a> <var>token</var>
 to <a>this</a>'s <a>token set</a>, run the <a>update steps</a>, and return true.

 <li><p>Return false.
</ol>

<p class=note>The <a>update steps</a> are not always run for {{DOMTokenList/toggle()}}
for web compatibility.

<p>The
<dfn method for=DOMTokenList><code>replace(<var>token</var>, <var>newToken</var>)</code></dfn>
method steps are:
<!-- Argument order based on String.prototype.replace(), not replaceChild() -->

<ol>
 <li><p>If either <var>token</var> or <var>newToken</var> is the empty string, then <a>throw</a> a
 "{{SyntaxError!!exception}}" {{DOMException}}.

 <li><p>If either <var>token</var> or <var>newToken</var> contains any <a>ASCII whitespace</a>, then
 <a>throw</a> an "{{InvalidCharacterError!!exception}}" {{DOMException}}.

 <li><p>If <a>this</a>'s <a>token set</a> does not <a for=set>contain</a> <var>token</var>, then
 return false.</p>

 <li><p><a for=set>Replace</a> <var>token</var> in <a>this</a>'s <a>token set</a> with
 <var>newToken</var>.

 <li><p>Run the <a>update steps</a>.

 <li><p>Return true.
</ol>

<p class=note>The <a>update steps</a> are not always run for {{DOMTokenList/replace()}}
for web compatibility.

<p>The
<dfn method for="DOMTokenList" lt="supports(token)"><code>supports(<var>token</var>)</code></dfn>
method steps are:

<ol>
 <li><p>Let <var>result</var> be the return value of <a>validation steps</a> called with
 <var>token</var>.

 <li><p>Return <var>result</var>.
</ol>

<p>The <dfn attribute for=DOMTokenList><code>value</code></dfn> attribute must return the
result of running <a>this</a>'s <a>serialize steps</a>.

<p>Setting the {{DOMTokenList/value}} attribute must <a>set an attribute value</a> for the
associated <a for=/>element</a> using associated <a>attribute</a>'s <a for=Attr>local name</a> and
the given value.



<h2 id=xpath>XPath</h2>

<p class=XXX><cite>DOM Level 3 XPath</cite> defined an API for evaluating <cite>XPath 1.0</cite>
expressions. These APIs are widely implemented, but have not been maintained. The interface
definitions are maintained here so that they can be updated when <cite>Web IDL</cite> changes.
Complete definitions of these APIs remain necessary and such work is tracked and can be contributed
to in <a href="https://github.com/whatwg/dom/issues/67">whatwg/dom#67</a>. [[DOM-Level-3-XPath]]
[[XPath]] [[WEBIDL]]


<h3 id=interface-xpathresult>Interface {{XPathResult}}</h3>

<pre class=idl>
[Exposed=Window]
interface XPathResult {
  const unsigned short ANY_TYPE = 0;
  const unsigned short NUMBER_TYPE = 1;
  const unsigned short STRING_TYPE = 2;
  const unsigned short BOOLEAN_TYPE = 3;
  const unsigned short UNORDERED_NODE_ITERATOR_TYPE = 4;
  const unsigned short ORDERED_NODE_ITERATOR_TYPE = 5;
  const unsigned short UNORDERED_NODE_SNAPSHOT_TYPE = 6;
  const unsigned short ORDERED_NODE_SNAPSHOT_TYPE = 7;
  const unsigned short ANY_UNORDERED_NODE_TYPE = 8;
  const unsigned short FIRST_ORDERED_NODE_TYPE = 9;

  readonly attribute unsigned short resultType;
  readonly attribute unrestricted double numberValue;
  readonly attribute DOMString stringValue;
  readonly attribute boolean booleanValue;
  readonly attribute Node? singleNodeValue;
  readonly attribute boolean invalidIteratorState;
  readonly attribute unsigned long snapshotLength;

  Node? iterateNext();
  Node? snapshotItem(unsigned long index);
};
</pre>


<h3 id=interface-xpathexpression>Interface {{XPathExpression}}</h3>

<pre class=idl>
[Exposed=Window]
interface XPathExpression {
  // XPathResult.ANY_TYPE = 0
  XPathResult evaluate(Node contextNode, optional unsigned short type = 0, optional XPathResult? result = null);
};
</pre>


<h3 id=mixin-xpathevaluatorbase>Mixin {{XPathEvaluatorBase}}</h3>

<pre class=idl>
callback interface XPathNSResolver {
  DOMString? lookupNamespaceURI(DOMString? prefix);
};

interface mixin XPathEvaluatorBase {
  [NewObject] XPathExpression createExpression(DOMString expression, optional XPathNSResolver? resolver = null);
  XPathNSResolver createNSResolver(Node nodeResolver);
  // XPathResult.ANY_TYPE = 0
  XPathResult evaluate(DOMString expression, Node contextNode, optional XPathNSResolver? resolver = null, optional unsigned short type = 0, optional XPathResult? result = null);
};
Document includes XPathEvaluatorBase;
</pre>


<h3 id=interface-xpathevaluator>Interface {{XPathEvaluator}}</h3>

<pre class=idl>
[Exposed=Window]
interface XPathEvaluator {
  constructor();
};

XPathEvaluator includes XPathEvaluatorBase;
</pre>

<p class=note>For historical reasons you can both construct {{XPathEvaluator}} and access the same
methods on {{Document}}.



<h2 id=xslt>XSLT</h2>

<p class=XXX><cite>XSL Transformations (XSLT)</cite> is a language for transforming XML documents
into other XML documents. The APIs defined in this section have been widely implemented, and are
maintained here so that they can be updated when <cite>Web IDL</cite> changes. Complete definitions
of these APIs remain necessary and such work is tracked and can be contributed to in
<a href="https://github.com/whatwg/dom/issues/181">whatwg/dom#181</a>. [[XSLT]]


<h3 id=interface-xsltprocessor>Interface {{XSLTProcessor}}</h3>

<pre class=idl>
[Exposed=Window]
interface XSLTProcessor {
  constructor();
  undefined importStylesheet(Node style);
  [CEReactions] DocumentFragment transformToFragment(Node source, Document output);
  [CEReactions] Document transformToDocument(Node source);
  undefined setParameter([LegacyNullToEmptyString] DOMString namespaceURI, DOMString localName, any value);
  any getParameter([LegacyNullToEmptyString] DOMString namespaceURI, DOMString localName);
  undefined removeParameter([LegacyNullToEmptyString] DOMString namespaceURI, DOMString localName);
  undefined clearParameters();
  undefined reset();
};
</pre>



<h2 id=security-and-privacy>Security and privacy considerations</h2>

<p>There are no known security or privacy considerations for this standard.



<h2 id=historical>Historical</h2>

<p>This standard used to contain several interfaces and interface members that have been removed.

<p>These interfaces have been removed:

<ul class=brief dfn-type="interface">
 <li><dfn><code>DOMConfiguration</code></dfn>
 <li><dfn><code>DOMError</code></dfn>
 <li><dfn><code>DOMErrorHandler</code></dfn>
 <li><dfn><code>DOMImplementationList</code></dfn>
 <li><dfn><code>DOMImplementationSource</code></dfn>
 <li><dfn><code>DOMLocator</code></dfn>
 <li><dfn><code>DOMObject</code></dfn>
 <li><dfn><code>DOMUserData</code></dfn>
 <li><dfn><code>Entity</code></dfn>
 <li><dfn><code>EntityReference</code></dfn>
 <li><dfn><code>MutationEvent</code></dfn>
 <li><dfn><code>MutationNameEvent</code></dfn>
 <li><dfn><code>NameList</code></dfn>
 <li><dfn><code>Notation</code></dfn>
 <li><dfn><code>RangeException</code></dfn>
 <li><dfn><code>TypeInfo</code></dfn>
 <li><dfn><code>UserDataHandler</code></dfn>
</ul>

<p>And these interface members have been removed:

<dl>
 <dt>{{Attr}}
 <dd>
  <ul class=brief>
   <li><dfn attribute for=Attr><code>schemaTypeInfo</code></dfn>
   <li><dfn attribute for=Attr><code>isId</code></dfn>
  </ul>

 <dt>{{Document}}
 <dd>
  <ul class=brief>
   <li><dfn method for=Document><code>createEntityReference()</code></dfn>
   <li><dfn attribute for=Document><code>xmlEncoding</code></dfn>
   <li><dfn attribute for=Document><code>xmlStandalone</code></dfn>
   <li><dfn attribute for=Document><code>xmlVersion</code></dfn>
   <li><dfn attribute for=Document><code>strictErrorChecking</code></dfn>
   <li><dfn attribute for=Document><code>domConfig</code></dfn>
   <li><dfn method for=Document><code>normalizeDocument()</code></dfn>
   <li><dfn method for=Document><code>renameNode()</code></dfn>
  </ul>

 <dt>{{DocumentType}}
 <dd>
  <ul class=brief>
   <li><dfn attribute for=DocumentType><code>entities</code></dfn>
   <li><dfn attribute for=DocumentType><code>notations</code></dfn>
   <li><dfn attribute for=DocumentType><code>internalSubset</code></dfn>
  </ul>

 <dt>{{DOMImplementation}}
 <dd>
  <ul class=brief>
   <li><dfn method for=DOMImplementation><code>getFeature()</code></dfn>
  </ul>

 <dt>{{Element}}
 <dd>
  <ul class=brief>
   <li><dfn attribute for=Element><code>schemaTypeInfo</code></dfn>
   <li><dfn method for=Element><code>setIdAttribute()</code></dfn>
   <li><dfn method for=Element><code>setIdAttributeNS()</code></dfn>
   <li><dfn method for=Element><code>setIdAttributeNode()</code></dfn>
  </ul>

 <dt>{{Node}}
 <dd>
  <ul class=brief>
   <li><dfn attribute for=Node><code>isSupported</code></dfn>
   <li><dfn method for=Node><code>getFeature()</code></dfn>
   <li><dfn method for=Node><code>getUserData()</code></dfn>
   <li><dfn method for=Node><code>setUserData()</code></dfn>
  </ul>

 <dt>{{NodeIterator}}
 <dd>
  <ul class=brief>
   <li><dfn for=NodeIterator attribute>expandEntityReferences</dfn>
  </ul>

 <dt>{{Text}}
 <dd>
  <ul class=brief>
   <li><dfn attribute for=Text><code>isElementContentWhitespace</code></dfn>
   <li><dfn method for=Text><code>replaceWholeText()</code></dfn>
  </ul>

 <dt>{{TreeWalker}}
 <dd>
  <ul class=brief>
   <li><dfn for=TreeWalker attribute>expandEntityReferences</dfn>
  </ul>
</dl>



<h2 class=no-num id="acks">Acknowledgments</h2>

<p>There have been a lot of people that have helped make DOM more interoperable over the years and
thereby furthered the goals of this standard. Likewise many people have helped making this standard
what it is today.

<p>With that, many thanks to
Adam Klein,
Adrian Bateman,
Ahmid <i>snuggs</i>,
Alex Komoroske,
Alex Russell,
Alexey Shvayka,
Andreu Botella,
Anthony Ramine,
Arkadiusz Michalski,
Arnaud Le Hors,
Arun Ranganathan,
Benjamin Gruenbaum,
Björn Höhrmann,
Boris Zbarsky,
Brandon Payton,
Brandon Slade,
Brandon Wallace,
Brian Kardell,
C. Scott Ananian,
Cameron McCormack,
Chris Dumez,
Chris Paris,
Chris Rebert,
Cyrille Tuzi,
Dan Burzo,
Daniel Clark,
Daniel Glazman,
Darin Fisher,
David Bruant,
David Flanagan,
David Håsäther,
David Hyatt,
Deepak Sherveghar,
Dethe Elza,
Dimitri Glazkov,
Domenic Denicola,
Dominic Cooney,
Dominique Hazaël-Massieux,
Don Jordan,
Doug Schepers,
Edgar Chen,
Elisée Maurer,
Elliott Sprehn,
Emilio Cobos Álvarez,
Eric Bidelman,
Erik Arvidsson,
Gary Kacmarcik,
Gavin Nicol,
Giorgio Liscio,
Glen Huang,
Glenn Adams,
Glenn Maynard,
Hajime Morrita,
Harald Alvestrand,
Hayato Ito,
Henri Sivonen,
Hongchan Choi,
Hunan Rostomyan,
Ian Hickson,
Igor Bukanov,
Jacob Rossi,
Jake Archibald<!-- technically B.J. Archibald -->,
Jake Verbaten,
James Graham,
James Greene,
James M Snell,
James Robinson,
Jeffrey Yasskin,
Jens Lindström,
Jesse McCarthy,
Jinho Bang,
João Eiras,
Joe Kesselman,
John Atkins,
John Dai,
Jonas Sicking,
Jonathan Kingston,
Jonathan Robie,
Joris van der Wel,
Joshua Bell,
J. S. Choi,
Jungkee Song,
Justin Summerlin,
Kagami Sascha Rosylight,
呂康豪 (Kang-Hao Lu),
田村健人 (Kent TAMURA),
Kevin J. Sung,
Kevin Sweeney,
Kirill Topolyan,
Koji Ishii,
Lachlan Hunt,
Lauren Wood,
Luca Casonato,
Luke Zielinski,
Magne Andersson,
Majid Valipour,
Malte Ubl,
Manish Goregaokar,
Manish Tripathi,
Marcos Caceres,
Mark Miller,
Martijn van der Ven,
Mason Freed,
Mats Palmgren,
Mounir Lamouri,
Michael Stramel,
Michael™ Smith,
Mike Champion,
Mike Taylor,
Mike West,
Nicolás Peña Moreno,
Nidhi Jaju,
Ojan Vafai,
Oliver Nightingale,
Olli Pettay,
Ondřej Žára,
Peter Sharpe,
Philip Jägenstedt,
Philippe Le Hégaret,
Piers Wombwell,
Pierre-Marie Dartus,
prosody—Gab<!-- riel --> Vereable<!-- Gaston --> <!-- Croft -->Context(,
Rafael Weinstein,
Rakina Zata Amni,
Richard Bradshaw,
Rick Byers,
Rick Waldron,
Robbert Broersma,
Robin Berjon,
Roland Steiner,
Rune <span title=Fabulous>F.</span> Halvorsen,
Russell Bicknell,
Ruud Steltenpool,
Ryosuke Niwa,
Sam Dutton,
Sam Sneddon,
Samuel Giles,
Sanket Joshi,
Sebastian Mayr,
Seo Sanghyeon,
Sergey G. Grekhov,
Shiki Okasaka,
Shinya Kawanaka,
Simon Pieters,
Stef Busking,
Steve Byrne,
Stig Halvorsen,
Tab Atkins,
Takashi Sakamoto,
Takayoshi Kochi,
Theresa O'Connor,
Theodore Dubois,
<i>timeless</i>,
Timo Tijhof,
Tobie Langel,
Tom Pixley,
Travis Leithead,
Trevor Rowbotham,
<i>triple-underscore</i>,<!--GitHub-->
Tristan Fraipont,
Veli Şenol,
Vidur Apparao,
Warren He,
Xidorn Quan,
Yash Handa,
Yehuda Katz,
Yoav Weiss,
Yoichi Osato,
Yoshinori Sano,
Yu Han,
Yusuke Abe, and
Zack Weinberg
for being awesome!

<p>This standard is written by <a lang=nl href=https://annevankesteren.nl/>Anne van Kesteren</a>
(<a href=https://www.apple.com/>Apple</a>, <a href=mailto:annevk@annevk.nl>annevk@annevk.nl</a>)
with substantial contributions from Aryeh Gregor (<a href=mailto:ayg@aryeh.name>ayg@aryeh.name</a>)
and Ms2ger (<a href="mailto:ms2ger@gmail.com">ms2ger@gmail.com</a>).

<p boilerplate=ipr>Part of the revision history of the integration points related to
<a for=Element>custom</a> elements can be found in
<a href="https://github.com/w3c/webcomponents">the w3c/webcomponents repository</a>, which is
available under the
<a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">W3C Software and Document License</a>.
